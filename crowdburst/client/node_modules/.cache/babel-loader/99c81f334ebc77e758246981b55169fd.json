{"ast":null,"code":"'use strict';\n\nvar ServerType = require('./common').ServerType;\n\nvar TopologyType = require('./common').TopologyType;\n\nvar ReadPreference = require('../topologies/read_preference');\n\nvar MongoError = require('../error').MongoError; // max staleness constants\n\n\nvar IDLE_WRITE_PERIOD = 10000;\nvar SMALLEST_MAX_STALENESS_SECONDS = 90;\n/**\n * Returns a server selector that selects for writable servers\n */\n\nfunction writableServerSelector() {\n  return function (topologyDescription, servers) {\n    return latencyWindowReducer(topologyDescription, servers.filter(function (s) {\n      return s.isWritable;\n    }));\n  };\n}\n/**\n * Reduces the passed in array of servers by the rules of the \"Max Staleness\" specification\n * found here: https://github.com/mongodb/specifications/blob/master/source/max-staleness/max-staleness.rst\n *\n * @param {ReadPreference} readPreference The read preference providing max staleness guidance\n * @param {topologyDescription} topologyDescription The topology description\n * @param {ServerDescription[]} servers The list of server descriptions to be reduced\n * @return {ServerDescription[]} The list of servers that satisfy the requirements of max staleness\n */\n\n\nfunction maxStalenessReducer(readPreference, topologyDescription, servers) {\n  if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {\n    return servers;\n  }\n\n  var maxStaleness = readPreference.maxStalenessSeconds;\n  var maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;\n\n  if (maxStaleness < maxStalenessVariance) {\n    throw new MongoError(\"maxStalenessSeconds must be at least \".concat(maxStalenessVariance, \" seconds\"));\n  }\n\n  if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {\n    throw new MongoError(\"maxStalenessSeconds must be at least \".concat(SMALLEST_MAX_STALENESS_SECONDS, \" seconds\"));\n  }\n\n  if (topologyDescription.type === TopologyType.ReplicaSetWithPrimary) {\n    var primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];\n    return servers.reduce(function (result, server) {\n      var stalenessMS = server.lastUpdateTime - server.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;\n      var staleness = stalenessMS / 1000;\n      if (staleness <= readPreference.maxStalenessSeconds) result.push(server);\n      return result;\n    }, []);\n  } else if (topologyDescription.type === TopologyType.ReplicaSetNoPrimary) {\n    var sMax = servers.reduce(function (max, s) {\n      return s.lastWriteDate > max.lastWriteDate ? s : max;\n    });\n    return servers.reduce(function (result, server) {\n      var stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;\n      var staleness = stalenessMS / 1000;\n      if (staleness <= readPreference.maxStalenessSeconds) result.push(server);\n      return result;\n    }, []);\n  }\n\n  return servers;\n}\n/**\n * Determines whether a server's tags match a given set of tags\n *\n * @param {String[]} tagSet The requested tag set to match\n * @param {String[]} serverTags The server's tags\n */\n\n\nfunction tagSetMatch(tagSet, serverTags) {\n  var keys = Object.keys(tagSet);\n  var serverTagKeys = Object.keys(serverTags);\n\n  for (var i = 0; i < keys.length; ++i) {\n    var key = keys[i];\n\n    if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Reduces a set of server descriptions based on tags requested by the read preference\n *\n * @param {ReadPreference} readPreference The read preference providing the requested tags\n * @param {ServerDescription[]} servers The list of server descriptions to reduce\n * @return {ServerDescription[]} The list of servers matching the requested tags\n */\n\n\nfunction tagSetReducer(readPreference, servers) {\n  if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {\n    return servers;\n  }\n\n  var _loop = function _loop(i) {\n    var tagSet = readPreference.tags[i];\n    var serversMatchingTagset = servers.reduce(function (matched, server) {\n      if (tagSetMatch(tagSet, server.tags)) matched.push(server);\n      return matched;\n    }, []);\n\n    if (serversMatchingTagset.length) {\n      return {\n        v: serversMatchingTagset\n      };\n    }\n  };\n\n  for (var i = 0; i < readPreference.tags.length; ++i) {\n    var _ret = _loop(i);\n\n    if (typeof _ret === \"object\") return _ret.v;\n  }\n\n  return [];\n}\n/**\n * Reduces a list of servers to ensure they fall within an acceptable latency window. This is\n * further specified in the \"Server Selection\" specification, found here:\n * https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.rst\n *\n * @param {topologyDescription} topologyDescription The topology description\n * @param {ServerDescription[]} servers The list of servers to reduce\n * @returns {ServerDescription[]} The servers which fall within an acceptable latency window\n */\n\n\nfunction latencyWindowReducer(topologyDescription, servers) {\n  var low = servers.reduce(function (min, server) {\n    return min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min);\n  }, -1);\n  var high = low + topologyDescription.localThresholdMS;\n  return servers.reduce(function (result, server) {\n    if (server.roundTripTime <= high && server.roundTripTime >= low) result.push(server);\n    return result;\n  }, []);\n} // filters\n\n\nfunction primaryFilter(server) {\n  return server.type === ServerType.RSPrimary;\n}\n\nfunction secondaryFilter(server) {\n  return server.type === ServerType.RSSecondary;\n}\n\nfunction nearestFilter(server) {\n  return server.type === ServerType.RSSecondary || server.type === ServerType.RSPrimary;\n}\n\nfunction knownFilter(server) {\n  return server.type !== ServerType.Unknown;\n}\n/**\n * Returns a function which selects servers based on a provided read preference\n *\n * @param {ReadPreference} readPreference The read preference to select with\n */\n\n\nfunction readPreferenceServerSelector(readPreference) {\n  if (!readPreference.isValid()) {\n    throw new TypeError('Invalid read preference specified');\n  }\n\n  return function (topologyDescription, servers) {\n    var commonWireVersion = topologyDescription.commonWireVersion;\n\n    if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {\n      throw new MongoError(\"Minimum wire version '\".concat(readPreference.minWireVersion, \"' required, but found '\").concat(commonWireVersion, \"'\"));\n    }\n\n    if (topologyDescription.type === TopologyType.Unknown) {\n      return [];\n    }\n\n    if (topologyDescription.type === TopologyType.Single || topologyDescription.type === TopologyType.Sharded) {\n      return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));\n    }\n\n    var mode = readPreference.mode;\n\n    if (mode === ReadPreference.PRIMARY) {\n      return servers.filter(primaryFilter);\n    }\n\n    if (mode === ReadPreference.PRIMARY_PREFERRED) {\n      var result = servers.filter(primaryFilter);\n\n      if (result.length) {\n        return result;\n      }\n    }\n\n    var filter = mode === ReadPreference.NEAREST ? nearestFilter : secondaryFilter;\n    var selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))));\n\n    if (mode === ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {\n      return servers.filter(primaryFilter);\n    }\n\n    return selectedServers;\n  };\n}\n\nmodule.exports = {\n  writableServerSelector: writableServerSelector,\n  readPreferenceServerSelector: readPreferenceServerSelector\n};","map":{"version":3,"sources":["/Users/S/Desktop/nodeprotake2/node_modules/mongodb/lib/core/sdam/server_selection.js"],"names":["ServerType","require","TopologyType","ReadPreference","MongoError","IDLE_WRITE_PERIOD","SMALLEST_MAX_STALENESS_SECONDS","writableServerSelector","topologyDescription","servers","latencyWindowReducer","filter","s","isWritable","maxStalenessReducer","readPreference","maxStalenessSeconds","maxStaleness","maxStalenessVariance","heartbeatFrequencyMS","type","ReplicaSetWithPrimary","primary","Array","from","values","primaryFilter","reduce","result","server","stalenessMS","lastUpdateTime","lastWriteDate","staleness","push","ReplicaSetNoPrimary","sMax","max","tagSetMatch","tagSet","serverTags","keys","Object","serverTagKeys","i","length","key","indexOf","tagSetReducer","tags","isArray","serversMatchingTagset","matched","low","min","roundTripTime","Math","high","localThresholdMS","RSPrimary","secondaryFilter","RSSecondary","nearestFilter","knownFilter","Unknown","readPreferenceServerSelector","isValid","TypeError","commonWireVersion","minWireVersion","Single","Sharded","mode","PRIMARY","PRIMARY_PREFERRED","NEAREST","selectedServers","SECONDARY_PREFERRED","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst ServerType = require('./common').ServerType;\nconst TopologyType = require('./common').TopologyType;\nconst ReadPreference = require('../topologies/read_preference');\nconst MongoError = require('../error').MongoError;\n\n// max staleness constants\nconst IDLE_WRITE_PERIOD = 10000;\nconst SMALLEST_MAX_STALENESS_SECONDS = 90;\n\n/**\n * Returns a server selector that selects for writable servers\n */\nfunction writableServerSelector() {\n  return function(topologyDescription, servers) {\n    return latencyWindowReducer(\n      topologyDescription,\n      servers.filter(s => s.isWritable)\n    );\n  };\n}\n\n/**\n * Reduces the passed in array of servers by the rules of the \"Max Staleness\" specification\n * found here: https://github.com/mongodb/specifications/blob/master/source/max-staleness/max-staleness.rst\n *\n * @param {ReadPreference} readPreference The read preference providing max staleness guidance\n * @param {topologyDescription} topologyDescription The topology description\n * @param {ServerDescription[]} servers The list of server descriptions to be reduced\n * @return {ServerDescription[]} The list of servers that satisfy the requirements of max staleness\n */\nfunction maxStalenessReducer(readPreference, topologyDescription, servers) {\n  if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {\n    return servers;\n  }\n\n  const maxStaleness = readPreference.maxStalenessSeconds;\n  const maxStalenessVariance =\n    (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;\n  if (maxStaleness < maxStalenessVariance) {\n    throw new MongoError(`maxStalenessSeconds must be at least ${maxStalenessVariance} seconds`);\n  }\n\n  if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {\n    throw new MongoError(\n      `maxStalenessSeconds must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`\n    );\n  }\n\n  if (topologyDescription.type === TopologyType.ReplicaSetWithPrimary) {\n    const primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];\n    return servers.reduce((result, server) => {\n      const stalenessMS =\n        server.lastUpdateTime -\n        server.lastWriteDate -\n        (primary.lastUpdateTime - primary.lastWriteDate) +\n        topologyDescription.heartbeatFrequencyMS;\n\n      const staleness = stalenessMS / 1000;\n      if (staleness <= readPreference.maxStalenessSeconds) result.push(server);\n      return result;\n    }, []);\n  } else if (topologyDescription.type === TopologyType.ReplicaSetNoPrimary) {\n    const sMax = servers.reduce((max, s) => (s.lastWriteDate > max.lastWriteDate ? s : max));\n    return servers.reduce((result, server) => {\n      const stalenessMS =\n        sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;\n\n      const staleness = stalenessMS / 1000;\n      if (staleness <= readPreference.maxStalenessSeconds) result.push(server);\n      return result;\n    }, []);\n  }\n\n  return servers;\n}\n\n/**\n * Determines whether a server's tags match a given set of tags\n *\n * @param {String[]} tagSet The requested tag set to match\n * @param {String[]} serverTags The server's tags\n */\nfunction tagSetMatch(tagSet, serverTags) {\n  const keys = Object.keys(tagSet);\n  const serverTagKeys = Object.keys(serverTags);\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Reduces a set of server descriptions based on tags requested by the read preference\n *\n * @param {ReadPreference} readPreference The read preference providing the requested tags\n * @param {ServerDescription[]} servers The list of server descriptions to reduce\n * @return {ServerDescription[]} The list of servers matching the requested tags\n */\nfunction tagSetReducer(readPreference, servers) {\n  if (\n    readPreference.tags == null ||\n    (Array.isArray(readPreference.tags) && readPreference.tags.length === 0)\n  ) {\n    return servers;\n  }\n\n  for (let i = 0; i < readPreference.tags.length; ++i) {\n    const tagSet = readPreference.tags[i];\n    const serversMatchingTagset = servers.reduce((matched, server) => {\n      if (tagSetMatch(tagSet, server.tags)) matched.push(server);\n      return matched;\n    }, []);\n\n    if (serversMatchingTagset.length) {\n      return serversMatchingTagset;\n    }\n  }\n\n  return [];\n}\n\n/**\n * Reduces a list of servers to ensure they fall within an acceptable latency window. This is\n * further specified in the \"Server Selection\" specification, found here:\n * https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.rst\n *\n * @param {topologyDescription} topologyDescription The topology description\n * @param {ServerDescription[]} servers The list of servers to reduce\n * @returns {ServerDescription[]} The servers which fall within an acceptable latency window\n */\nfunction latencyWindowReducer(topologyDescription, servers) {\n  const low = servers.reduce(\n    (min, server) => (min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min)),\n    -1\n  );\n\n  const high = low + topologyDescription.localThresholdMS;\n\n  return servers.reduce((result, server) => {\n    if (server.roundTripTime <= high && server.roundTripTime >= low) result.push(server);\n    return result;\n  }, []);\n}\n\n// filters\nfunction primaryFilter(server) {\n  return server.type === ServerType.RSPrimary;\n}\n\nfunction secondaryFilter(server) {\n  return server.type === ServerType.RSSecondary;\n}\n\nfunction nearestFilter(server) {\n  return server.type === ServerType.RSSecondary || server.type === ServerType.RSPrimary;\n}\n\nfunction knownFilter(server) {\n  return server.type !== ServerType.Unknown;\n}\n\n/**\n * Returns a function which selects servers based on a provided read preference\n *\n * @param {ReadPreference} readPreference The read preference to select with\n */\nfunction readPreferenceServerSelector(readPreference) {\n  if (!readPreference.isValid()) {\n    throw new TypeError('Invalid read preference specified');\n  }\n\n  return function(topologyDescription, servers) {\n    const commonWireVersion = topologyDescription.commonWireVersion;\n    if (\n      commonWireVersion &&\n      readPreference.minWireVersion &&\n      readPreference.minWireVersion > commonWireVersion\n    ) {\n      throw new MongoError(\n        `Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`\n      );\n    }\n\n    if (topologyDescription.type === TopologyType.Unknown) {\n      return [];\n    }\n\n    if (\n      topologyDescription.type === TopologyType.Single ||\n      topologyDescription.type === TopologyType.Sharded\n    ) {\n      return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));\n    }\n\n    const mode = readPreference.mode;\n    if (mode === ReadPreference.PRIMARY) {\n      return servers.filter(primaryFilter);\n    }\n\n    if (mode === ReadPreference.PRIMARY_PREFERRED) {\n      const result = servers.filter(primaryFilter);\n      if (result.length) {\n        return result;\n      }\n    }\n\n    const filter = mode === ReadPreference.NEAREST ? nearestFilter : secondaryFilter;\n    const selectedServers = latencyWindowReducer(\n      topologyDescription,\n      tagSetReducer(\n        readPreference,\n        maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))\n      )\n    );\n\n    if (mode === ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {\n      return servers.filter(primaryFilter);\n    }\n\n    return selectedServers;\n  };\n}\n\nmodule.exports = {\n  writableServerSelector,\n  readPreferenceServerSelector\n};\n"]},"metadata":{},"sourceType":"script"}