{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar ServerType = require('./common').ServerType;\n\nvar ServerDescription = require('./server_description').ServerDescription;\n\nvar WIRE_CONSTANTS = require('../wireprotocol/constants');\n\nvar TopologyType = require('./common').TopologyType; // contstants related to compatability checks\n\n\nvar MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nvar MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nvar MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nvar MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION; // Representation of a deployment of servers\n\nvar TopologyDescription = /*#__PURE__*/function () {\n  /**\n   * Create a TopologyDescription\n   *\n   * @param {string} topologyType\n   * @param {Map<string, ServerDescription>} serverDescriptions the a map of address to ServerDescription\n   * @param {string} setName\n   * @param {number} maxSetVersion\n   * @param {ObjectId} maxElectionId\n   */\n  function TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, options) {\n    _classCallCheck(this, TopologyDescription);\n\n    options = options || {}; // TODO: consider assigning all these values to a temporary value `s` which\n    //       we use `Object.freeze` on, ensuring the internal state of this type\n    //       is immutable.\n\n    this.type = topologyType || TopologyType.Unknown;\n    this.setName = setName || null;\n    this.maxSetVersion = maxSetVersion || null;\n    this.maxElectionId = maxElectionId || null;\n    this.servers = serverDescriptions || new Map();\n    this.stale = false;\n    this.compatible = true;\n    this.compatibilityError = null;\n    this.logicalSessionTimeoutMinutes = null;\n    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 0;\n    this.localThresholdMS = options.localThresholdMS || 0;\n    this.commonWireVersion = commonWireVersion || null; // save this locally, but don't display when printing the instance out\n\n    Object.defineProperty(this, 'options', {\n      value: options,\n      enumberable: false\n    }); // determine server compatibility\n\n    var _iterator = _createForOfIteratorHelper(this.servers.values()),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var serverDescription = _step.value;\n        if (serverDescription.type === ServerType.Unknown) continue;\n\n        if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {\n          this.compatible = false;\n          this.compatibilityError = \"Server at \".concat(serverDescription.address, \" requires wire version \").concat(serverDescription.minWireVersion, \", but this version of the driver only supports up to \").concat(MAX_SUPPORTED_WIRE_VERSION, \" (MongoDB \").concat(MAX_SUPPORTED_SERVER_VERSION, \")\");\n        }\n\n        if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {\n          this.compatible = false;\n          this.compatibilityError = \"Server at \".concat(serverDescription.address, \" reports wire version \").concat(serverDescription.maxWireVersion, \", but this version of the driver requires at least \").concat(MIN_SUPPORTED_WIRE_VERSION, \" (MongoDB \").concat(MIN_SUPPORTED_SERVER_VERSION, \").\");\n          break;\n        }\n      } // Whenever a client updates the TopologyDescription from an ismaster response, it MUST set\n      // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes\n      // value among ServerDescriptions of all data-bearing server types. If any have a null\n      // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be\n      // set to null.\n\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    var readableServers = Array.from(this.servers.values()).filter(function (s) {\n      return s.isReadable;\n    });\n    this.logicalSessionTimeoutMinutes = readableServers.reduce(function (result, server) {\n      if (server.logicalSessionTimeoutMinutes == null) return null;\n      if (result == null) return server.logicalSessionTimeoutMinutes;\n      return Math.min(result, server.logicalSessionTimeoutMinutes);\n    }, null);\n  }\n  /**\n   * Returns a new TopologyDescription based on the SrvPollingEvent\n   * @param {SrvPollingEvent} ev The event\n   */\n\n\n  _createClass(TopologyDescription, [{\n    key: \"updateFromSrvPollingEvent\",\n    value: function updateFromSrvPollingEvent(ev) {\n      var newAddresses = ev.addresses();\n      var serverDescriptions = new Map(this.servers);\n\n      var _iterator2 = _createForOfIteratorHelper(this.servers),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var server = _step2.value;\n\n          if (newAddresses.has(server[0])) {\n            newAddresses.delete(server[0]);\n          } else {\n            serverDescriptions.delete(server[0]);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      if (serverDescriptions.size === this.servers.size && newAddresses.size === 0) {\n        return this;\n      }\n\n      var _iterator3 = _createForOfIteratorHelper(newAddresses),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var address = _step3.value;\n          serverDescriptions.set(address, new ServerDescription(address));\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, this.options, null);\n    }\n    /**\n     * Returns a copy of this description updated with a given ServerDescription\n     *\n     * @param {ServerDescription} serverDescription\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(serverDescription) {\n      var address = serverDescription.address; // NOTE: there are a number of prime targets for refactoring here\n      //       once we support destructuring assignments\n      // potentially mutated values\n\n      var topologyType = this.type;\n      var setName = this.setName;\n      var maxSetVersion = this.maxSetVersion;\n      var maxElectionId = this.maxElectionId;\n      var commonWireVersion = this.commonWireVersion;\n      var serverType = serverDescription.type;\n      var serverDescriptions = new Map(this.servers); // update common wire version\n\n      if (serverDescription.maxWireVersion !== 0) {\n        if (commonWireVersion == null) {\n          commonWireVersion = serverDescription.maxWireVersion;\n        } else {\n          commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);\n        }\n      } // update the actual server description\n\n\n      serverDescriptions.set(address, serverDescription);\n\n      if (topologyType === TopologyType.Single) {\n        // once we are defined as single, that never changes\n        return new TopologyDescription(TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, this.options);\n      }\n\n      if (topologyType === TopologyType.Unknown) {\n        if (serverType === ServerType.Standalone) {\n          serverDescriptions.delete(address);\n        } else {\n          topologyType = topologyTypeForServerType(serverType);\n        }\n      }\n\n      if (topologyType === TopologyType.Sharded) {\n        if ([ServerType.Mongos, ServerType.Unknown].indexOf(serverType) === -1) {\n          serverDescriptions.delete(address);\n        }\n      }\n\n      if (topologyType === TopologyType.ReplicaSetNoPrimary) {\n        if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {\n          serverDescriptions.delete(address);\n        }\n\n        if (serverType === ServerType.RSPrimary) {\n          var result = updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId);\n          topologyType = result[0], setName = result[1], maxSetVersion = result[2], maxElectionId = result[3];\n        } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {\n          var _result = updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription);\n\n          topologyType = _result[0], setName = _result[1];\n        }\n      }\n\n      if (topologyType === TopologyType.ReplicaSetWithPrimary) {\n        if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {\n          serverDescriptions.delete(address);\n          topologyType = checkHasPrimary(serverDescriptions);\n        } else if (serverType === ServerType.RSPrimary) {\n          var _result2 = updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId);\n\n          topologyType = _result2[0], setName = _result2[1], maxSetVersion = _result2[2], maxElectionId = _result2[3];\n        } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {\n          topologyType = updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription);\n        } else {\n          topologyType = checkHasPrimary(serverDescriptions);\n        }\n      }\n\n      return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, this.options);\n    }\n  }, {\n    key: \"hasServer\",\n\n    /**\n     * Determines if the topology has a definition for the provided address\n     *\n     * @param {String} address\n     * @return {Boolean} Whether the topology knows about this server\n     */\n    value: function hasServer(address) {\n      return this.servers.has(address);\n    }\n  }, {\n    key: \"error\",\n    get: function get() {\n      var descriptionsWithError = Array.from(this.servers.values()).filter(function (sd) {\n        return sd.error;\n      });\n\n      if (descriptionsWithError.length > 0) {\n        return descriptionsWithError[0].error;\n      }\n    }\n    /**\n     * Determines if the topology description has any known servers\n     */\n\n  }, {\n    key: \"hasKnownServers\",\n    get: function get() {\n      return Array.from(this.servers.values()).some(function (sd) {\n        return sd.type !== ServerType.Unknown;\n      });\n    }\n    /**\n     * Determines if this topology description has a data-bearing server available.\n     */\n\n  }, {\n    key: \"hasDataBearingServers\",\n    get: function get() {\n      return Array.from(this.servers.values()).some(function (sd) {\n        return sd.isDataBearing;\n      });\n    }\n  }]);\n\n  return TopologyDescription;\n}();\n\nfunction topologyTypeForServerType(serverType) {\n  if (serverType === ServerType.Mongos) return TopologyType.Sharded;\n  if (serverType === ServerType.RSPrimary) return TopologyType.ReplicaSetWithPrimary;\n  return TopologyType.ReplicaSetNoPrimary;\n}\n\nfunction compareObjectId(oid1, oid2) {\n  if (oid1 == null) {\n    return -1;\n  }\n\n  if (oid2 == null) {\n    return 1;\n  }\n\n  if (oid1.id instanceof Buffer && oid2.id instanceof Buffer) {\n    var oid1Buffer = oid1.id;\n    var oid2Buffer = oid2.id;\n    return oid1Buffer.compare(oid2Buffer);\n  }\n\n  var oid1String = oid1.toString();\n  var oid2String = oid2.toString();\n  return oid1String.localeCompare(oid2String);\n}\n\nfunction updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId) {\n  setName = setName || serverDescription.setName;\n\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n  }\n\n  var electionId = serverDescription.electionId ? serverDescription.electionId : null;\n\n  if (serverDescription.setVersion && electionId) {\n    if (maxSetVersion && maxElectionId) {\n      if (maxSetVersion > serverDescription.setVersion || compareObjectId(maxElectionId, electionId) > 0) {\n        // this primary is stale, we must remove it\n        serverDescriptions.set(serverDescription.address, new ServerDescription(serverDescription.address));\n        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n      }\n    }\n\n    maxElectionId = serverDescription.electionId;\n  }\n\n  if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {\n    maxSetVersion = serverDescription.setVersion;\n  } // We've heard from the primary. Is it the same primary as before?\n\n\n  var _iterator4 = _createForOfIteratorHelper(serverDescriptions.keys()),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var address = _step4.value;\n      var server = serverDescriptions.get(address);\n\n      if (server.type === ServerType.RSPrimary && server.address !== serverDescription.address) {\n        // Reset old primary's type to Unknown.\n        serverDescriptions.set(address, new ServerDescription(server.address)); // There can only be one primary\n\n        break;\n      }\n    } // Discover new hosts from this primary's response.\n\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  serverDescription.allHosts.forEach(function (address) {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  }); // Remove hosts not in the response.\n\n  var currentAddresses = Array.from(serverDescriptions.keys());\n  var responseAddresses = serverDescription.allHosts;\n  currentAddresses.filter(function (addr) {\n    return responseAddresses.indexOf(addr) === -1;\n  }).forEach(function (address) {\n    serverDescriptions.delete(address);\n  });\n  return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n}\n\nfunction updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription) {\n  if (setName == null) {\n    throw new TypeError('setName is required');\n  }\n\n  if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return checkHasPrimary(serverDescriptions);\n}\n\nfunction updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription) {\n  var topologyType = TopologyType.ReplicaSetNoPrimary;\n  setName = setName || serverDescription.setName;\n\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [topologyType, setName];\n  }\n\n  serverDescription.allHosts.forEach(function (address) {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  });\n\n  if (serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return [topologyType, setName];\n}\n\nfunction checkHasPrimary(serverDescriptions) {\n  var _iterator5 = _createForOfIteratorHelper(serverDescriptions.keys()),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var addr = _step5.value;\n\n      if (serverDescriptions.get(addr).type === ServerType.RSPrimary) {\n        return TopologyType.ReplicaSetWithPrimary;\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  return TopologyType.ReplicaSetNoPrimary;\n}\n\nmodule.exports = {\n  TopologyDescription: TopologyDescription\n};","map":{"version":3,"sources":["/Users/S/Desktop/nodeprotake2/node_modules/mongodb/lib/core/sdam/topology_description.js"],"names":["ServerType","require","ServerDescription","WIRE_CONSTANTS","TopologyType","MIN_SUPPORTED_SERVER_VERSION","MAX_SUPPORTED_SERVER_VERSION","MIN_SUPPORTED_WIRE_VERSION","MAX_SUPPORTED_WIRE_VERSION","TopologyDescription","topologyType","serverDescriptions","setName","maxSetVersion","maxElectionId","commonWireVersion","options","type","Unknown","servers","Map","stale","compatible","compatibilityError","logicalSessionTimeoutMinutes","heartbeatFrequencyMS","localThresholdMS","Object","defineProperty","value","enumberable","values","serverDescription","minWireVersion","address","maxWireVersion","readableServers","Array","from","filter","s","isReadable","reduce","result","server","Math","min","ev","newAddresses","addresses","has","delete","size","set","serverType","Single","Standalone","topologyTypeForServerType","Sharded","Mongos","indexOf","ReplicaSetNoPrimary","RSPrimary","updateRsFromPrimary","RSSecondary","RSArbiter","RSOther","updateRsNoPrimaryFromMember","ReplicaSetWithPrimary","checkHasPrimary","updateRsWithPrimaryFromMember","descriptionsWithError","sd","error","length","some","isDataBearing","compareObjectId","oid1","oid2","id","Buffer","oid1Buffer","oid2Buffer","compare","oid1String","toString","oid2String","localeCompare","electionId","setVersion","keys","get","allHosts","forEach","currentAddresses","responseAddresses","addr","TypeError","me","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst ServerType = require('./common').ServerType;\nconst ServerDescription = require('./server_description').ServerDescription;\nconst WIRE_CONSTANTS = require('../wireprotocol/constants');\nconst TopologyType = require('./common').TopologyType;\n\n// contstants related to compatability checks\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\n\n// Representation of a deployment of servers\nclass TopologyDescription {\n  /**\n   * Create a TopologyDescription\n   *\n   * @param {string} topologyType\n   * @param {Map<string, ServerDescription>} serverDescriptions the a map of address to ServerDescription\n   * @param {string} setName\n   * @param {number} maxSetVersion\n   * @param {ObjectId} maxElectionId\n   */\n  constructor(\n    topologyType,\n    serverDescriptions,\n    setName,\n    maxSetVersion,\n    maxElectionId,\n    commonWireVersion,\n    options\n  ) {\n    options = options || {};\n\n    // TODO: consider assigning all these values to a temporary value `s` which\n    //       we use `Object.freeze` on, ensuring the internal state of this type\n    //       is immutable.\n    this.type = topologyType || TopologyType.Unknown;\n    this.setName = setName || null;\n    this.maxSetVersion = maxSetVersion || null;\n    this.maxElectionId = maxElectionId || null;\n    this.servers = serverDescriptions || new Map();\n    this.stale = false;\n    this.compatible = true;\n    this.compatibilityError = null;\n    this.logicalSessionTimeoutMinutes = null;\n    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 0;\n    this.localThresholdMS = options.localThresholdMS || 0;\n    this.commonWireVersion = commonWireVersion || null;\n\n    // save this locally, but don't display when printing the instance out\n    Object.defineProperty(this, 'options', { value: options, enumberable: false });\n\n    // determine server compatibility\n    for (const serverDescription of this.servers.values()) {\n      if (serverDescription.type === ServerType.Unknown) continue;\n\n      if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n      }\n\n      if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;\n        break;\n      }\n    }\n\n    // Whenever a client updates the TopologyDescription from an ismaster response, it MUST set\n    // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes\n    // value among ServerDescriptions of all data-bearing server types. If any have a null\n    // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be\n    // set to null.\n    const readableServers = Array.from(this.servers.values()).filter(s => s.isReadable);\n    this.logicalSessionTimeoutMinutes = readableServers.reduce((result, server) => {\n      if (server.logicalSessionTimeoutMinutes == null) return null;\n      if (result == null) return server.logicalSessionTimeoutMinutes;\n      return Math.min(result, server.logicalSessionTimeoutMinutes);\n    }, null);\n  }\n\n  /**\n   * Returns a new TopologyDescription based on the SrvPollingEvent\n   * @param {SrvPollingEvent} ev The event\n   */\n  updateFromSrvPollingEvent(ev) {\n    const newAddresses = ev.addresses();\n    const serverDescriptions = new Map(this.servers);\n    for (const server of this.servers) {\n      if (newAddresses.has(server[0])) {\n        newAddresses.delete(server[0]);\n      } else {\n        serverDescriptions.delete(server[0]);\n      }\n    }\n\n    if (serverDescriptions.size === this.servers.size && newAddresses.size === 0) {\n      return this;\n    }\n\n    for (const address of newAddresses) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n\n    return new TopologyDescription(\n      this.type,\n      serverDescriptions,\n      this.setName,\n      this.maxSetVersion,\n      this.maxElectionId,\n      this.commonWireVersion,\n      this.options,\n      null\n    );\n  }\n\n  /**\n   * Returns a copy of this description updated with a given ServerDescription\n   *\n   * @param {ServerDescription} serverDescription\n   */\n  update(serverDescription) {\n    const address = serverDescription.address;\n    // NOTE: there are a number of prime targets for refactoring here\n    //       once we support destructuring assignments\n\n    // potentially mutated values\n    let topologyType = this.type;\n    let setName = this.setName;\n    let maxSetVersion = this.maxSetVersion;\n    let maxElectionId = this.maxElectionId;\n    let commonWireVersion = this.commonWireVersion;\n\n    const serverType = serverDescription.type;\n    let serverDescriptions = new Map(this.servers);\n\n    // update common wire version\n    if (serverDescription.maxWireVersion !== 0) {\n      if (commonWireVersion == null) {\n        commonWireVersion = serverDescription.maxWireVersion;\n      } else {\n        commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);\n      }\n    }\n\n    // update the actual server description\n    serverDescriptions.set(address, serverDescription);\n\n    if (topologyType === TopologyType.Single) {\n      // once we are defined as single, that never changes\n      return new TopologyDescription(\n        TopologyType.Single,\n        serverDescriptions,\n        setName,\n        maxSetVersion,\n        maxElectionId,\n        commonWireVersion,\n        this.options\n      );\n    }\n\n    if (topologyType === TopologyType.Unknown) {\n      if (serverType === ServerType.Standalone) {\n        serverDescriptions.delete(address);\n      } else {\n        topologyType = topologyTypeForServerType(serverType);\n      }\n    }\n\n    if (topologyType === TopologyType.Sharded) {\n      if ([ServerType.Mongos, ServerType.Unknown].indexOf(serverType) === -1) {\n        serverDescriptions.delete(address);\n      }\n    }\n\n    if (topologyType === TopologyType.ReplicaSetNoPrimary) {\n      if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {\n        serverDescriptions.delete(address);\n      }\n\n      if (serverType === ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(\n          serverDescriptions,\n          setName,\n          serverDescription,\n          maxSetVersion,\n          maxElectionId\n        );\n\n        (topologyType = result[0]),\n          (setName = result[1]),\n          (maxSetVersion = result[2]),\n          (maxElectionId = result[3]);\n      } else if (\n        [ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0\n      ) {\n        const result = updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription);\n        (topologyType = result[0]), (setName = result[1]);\n      }\n    }\n\n    if (topologyType === TopologyType.ReplicaSetWithPrimary) {\n      if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {\n        serverDescriptions.delete(address);\n        topologyType = checkHasPrimary(serverDescriptions);\n      } else if (serverType === ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(\n          serverDescriptions,\n          setName,\n          serverDescription,\n          maxSetVersion,\n          maxElectionId\n        );\n\n        (topologyType = result[0]),\n          (setName = result[1]),\n          (maxSetVersion = result[2]),\n          (maxElectionId = result[3]);\n      } else if (\n        [ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0\n      ) {\n        topologyType = updateRsWithPrimaryFromMember(\n          serverDescriptions,\n          setName,\n          serverDescription\n        );\n      } else {\n        topologyType = checkHasPrimary(serverDescriptions);\n      }\n    }\n\n    return new TopologyDescription(\n      topologyType,\n      serverDescriptions,\n      setName,\n      maxSetVersion,\n      maxElectionId,\n      commonWireVersion,\n      this.options\n    );\n  }\n\n  get error() {\n    const descriptionsWithError = Array.from(this.servers.values()).filter(sd => sd.error);\n    if (descriptionsWithError.length > 0) {\n      return descriptionsWithError[0].error;\n    }\n  }\n\n  /**\n   * Determines if the topology description has any known servers\n   */\n  get hasKnownServers() {\n    return Array.from(this.servers.values()).some(sd => sd.type !== ServerType.Unknown);\n  }\n\n  /**\n   * Determines if this topology description has a data-bearing server available.\n   */\n  get hasDataBearingServers() {\n    return Array.from(this.servers.values()).some(sd => sd.isDataBearing);\n  }\n\n  /**\n   * Determines if the topology has a definition for the provided address\n   *\n   * @param {String} address\n   * @return {Boolean} Whether the topology knows about this server\n   */\n  hasServer(address) {\n    return this.servers.has(address);\n  }\n}\n\nfunction topologyTypeForServerType(serverType) {\n  if (serverType === ServerType.Mongos) return TopologyType.Sharded;\n  if (serverType === ServerType.RSPrimary) return TopologyType.ReplicaSetWithPrimary;\n  return TopologyType.ReplicaSetNoPrimary;\n}\n\nfunction compareObjectId(oid1, oid2) {\n  if (oid1 == null) {\n    return -1;\n  }\n\n  if (oid2 == null) {\n    return 1;\n  }\n\n  if (oid1.id instanceof Buffer && oid2.id instanceof Buffer) {\n    const oid1Buffer = oid1.id;\n    const oid2Buffer = oid2.id;\n    return oid1Buffer.compare(oid2Buffer);\n  }\n\n  const oid1String = oid1.toString();\n  const oid2String = oid2.toString();\n  return oid1String.localeCompare(oid2String);\n}\n\nfunction updateRsFromPrimary(\n  serverDescriptions,\n  setName,\n  serverDescription,\n  maxSetVersion,\n  maxElectionId\n) {\n  setName = setName || serverDescription.setName;\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n  }\n\n  const electionId = serverDescription.electionId ? serverDescription.electionId : null;\n  if (serverDescription.setVersion && electionId) {\n    if (maxSetVersion && maxElectionId) {\n      if (\n        maxSetVersion > serverDescription.setVersion ||\n        compareObjectId(maxElectionId, electionId) > 0\n      ) {\n        // this primary is stale, we must remove it\n        serverDescriptions.set(\n          serverDescription.address,\n          new ServerDescription(serverDescription.address)\n        );\n\n        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n      }\n    }\n\n    maxElectionId = serverDescription.electionId;\n  }\n\n  if (\n    serverDescription.setVersion != null &&\n    (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)\n  ) {\n    maxSetVersion = serverDescription.setVersion;\n  }\n\n  // We've heard from the primary. Is it the same primary as before?\n  for (const address of serverDescriptions.keys()) {\n    const server = serverDescriptions.get(address);\n\n    if (server.type === ServerType.RSPrimary && server.address !== serverDescription.address) {\n      // Reset old primary's type to Unknown.\n      serverDescriptions.set(address, new ServerDescription(server.address));\n\n      // There can only be one primary\n      break;\n    }\n  }\n\n  // Discover new hosts from this primary's response.\n  serverDescription.allHosts.forEach(address => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  });\n\n  // Remove hosts not in the response.\n  const currentAddresses = Array.from(serverDescriptions.keys());\n  const responseAddresses = serverDescription.allHosts;\n  currentAddresses\n    .filter(addr => responseAddresses.indexOf(addr) === -1)\n    .forEach(address => {\n      serverDescriptions.delete(address);\n    });\n\n  return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n}\n\nfunction updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription) {\n  if (setName == null) {\n    throw new TypeError('setName is required');\n  }\n\n  if (\n    setName !== serverDescription.setName ||\n    (serverDescription.me && serverDescription.address !== serverDescription.me)\n  ) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return checkHasPrimary(serverDescriptions);\n}\n\nfunction updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription) {\n  let topologyType = TopologyType.ReplicaSetNoPrimary;\n\n  setName = setName || serverDescription.setName;\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [topologyType, setName];\n  }\n\n  serverDescription.allHosts.forEach(address => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  });\n\n  if (serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return [topologyType, setName];\n}\n\nfunction checkHasPrimary(serverDescriptions) {\n  for (const addr of serverDescriptions.keys()) {\n    if (serverDescriptions.get(addr).type === ServerType.RSPrimary) {\n      return TopologyType.ReplicaSetWithPrimary;\n    }\n  }\n\n  return TopologyType.ReplicaSetNoPrimary;\n}\n\nmodule.exports = {\n  TopologyDescription\n};\n"]},"metadata":{},"sourceType":"script"}