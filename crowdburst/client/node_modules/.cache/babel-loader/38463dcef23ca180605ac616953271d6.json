{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _get = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Server = require('./server');\n\nvar Cursor = require('../cursor');\n\nvar MongoError = require('../core').MongoError;\n\nvar TopologyBase = require('./topology_base').TopologyBase;\n\nvar Store = require('./topology_base').Store;\n\nvar CReplSet = require('../core').ReplSet;\n\nvar MAX_JS_INT = require('../utils').MAX_JS_INT;\n\nvar translateOptions = require('../utils').translateOptions;\n\nvar filterOptions = require('../utils').filterOptions;\n\nvar mergeOptions = require('../utils').mergeOptions;\n/**\n * @fileOverview The **ReplSet** class is a class that represents a Replicaset topology and is\n * used to construct connections.\n *\n * **ReplSet Should not be used, use MongoClient.connect**\n */\n// Allowed parameters\n\n\nvar legalOptionNames = ['ha', 'haInterval', 'replicaSet', 'rs_name', 'secondaryAcceptableLatencyMS', 'connectWithNoPrimary', 'poolSize', 'ssl', 'checkServerIdentity', 'sslValidate', 'sslCA', 'sslCert', 'ciphers', 'ecdhCurve', 'sslCRL', 'sslKey', 'sslPass', 'socketOptions', 'bufferMaxEntries', 'store', 'auto_reconnect', 'autoReconnect', 'emitError', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectTimeoutMS', 'socketTimeoutMS', 'strategy', 'debug', 'family', 'loggerLevel', 'logger', 'reconnectTries', 'appname', 'domainsEnabled', 'servername', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'maxStalenessSeconds', 'promiseLibrary', 'minSize', 'monitorCommands'];\n/**\n * Creates a new ReplSet instance\n * @class\n * @deprecated\n * @param {Server[]} servers A seedlist of servers participating in the replicaset.\n * @param {object} [options] Optional settings.\n * @param {boolean} [options.ha=true] Turn on high availability monitoring.\n * @param {number} [options.haInterval=10000] Time between each replicaset status check.\n * @param {string} [options.replicaSet] The name of the replicaset to connect to.\n * @param {number} [options.secondaryAcceptableLatencyMS=15] Sets the range of servers to pick when using NEAREST (lowest ping ms + the latency fence, ex: range of 1 to (1 + 15) ms)\n * @param {boolean} [options.connectWithNoPrimary=false] Sets if the driver should connect even if no primary is available\n * @param {number} [options.poolSize=5] Number of connections in the connection pool for each server instance, set to 5 as default for legacy reasons.\n * @param {boolean} [options.ssl=false] Use ssl connection (needs to have a mongod server with ssl support)\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {boolean} [options.sslValidate=false] Validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {array} [options.sslCA] Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {array} [options.sslCRL] Array of revocation certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {(Buffer|string)} [options.sslCert] String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher.\n * @param {string} [options.ciphers] Passed directly through to tls.createSecureContext. See https://nodejs.org/dist/latest-v9.x/docs/api/tls.html#tls_tls_createsecurecontext_options for more info.\n * @param {string} [options.ecdhCurve] Passed directly through to tls.createSecureContext. See https://nodejs.org/dist/latest-v9.x/docs/api/tls.html#tls_tls_createsecurecontext_options for more info.\n * @param {(Buffer|string)} [options.sslKey] String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {(Buffer|string)} [options.sslPass] String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {string} [options.servername] String containing the server name requested via TLS SNI.\n * @param {object} [options.socketOptions] Socket options\n * @param {boolean} [options.socketOptions.noDelay=true] TCP Socket NoDelay option.\n * @param {boolean} [options.socketOptions.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.socketOptions.keepAliveInitialDelay=30000] The number of milliseconds to wait before initiating keepAlive on the TCP socket\n * @param {number} [options.socketOptions.connectTimeoutMS=10000] How long to wait for a connection to be established before timing out\n * @param {number} [options.socketOptions.socketTimeoutMS=360000] How long a send or receive on a socket can take before timing out\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\n * @param {number} [options.maxStalenessSeconds=undefined] The max staleness to secondary reads (values under 10 seconds cannot be guaranteed);\n * @param {boolean} [options.monitorCommands=false] Enable command monitoring for this topology\n * @fires ReplSet#connect\n * @fires ReplSet#ha\n * @fires ReplSet#joined\n * @fires ReplSet#left\n * @fires ReplSet#fullsetup\n * @fires ReplSet#open\n * @fires ReplSet#close\n * @fires ReplSet#error\n * @fires ReplSet#timeout\n * @fires ReplSet#parseError\n * @fires ReplSet#commandStarted\n * @fires ReplSet#commandSucceeded\n * @fires ReplSet#commandFailed\n * @property {string} parserType the parser type used (c++ or js).\n * @return {ReplSet} a ReplSet instance.\n */\n\nvar ReplSet = /*#__PURE__*/function (_TopologyBase) {\n  _inherits(ReplSet, _TopologyBase);\n\n  var _super = _createSuper(ReplSet);\n\n  function ReplSet(servers, options) {\n    var _this;\n\n    _classCallCheck(this, ReplSet);\n\n    _this = _super.call(this);\n    options = options || {};\n\n    var self = _assertThisInitialized(_this); // Filter the options\n\n\n    options = filterOptions(options, legalOptionNames); // Ensure all the instances are Server\n\n    for (var i = 0; i < servers.length; i++) {\n      if (!(servers[i] instanceof Server)) {\n        throw MongoError.create({\n          message: 'all seed list instances must be of the Server type',\n          driver: true\n        });\n      }\n    } // Stored options\n\n\n    var storeOptions = {\n      force: false,\n      bufferMaxEntries: typeof options.bufferMaxEntries === 'number' ? options.bufferMaxEntries : MAX_JS_INT\n    }; // Shared global store\n\n    var store = options.store || new Store(self, storeOptions); // Build seed list\n\n    var seedlist = servers.map(function (x) {\n      return {\n        host: x.host,\n        port: x.port\n      };\n    }); // Clone options\n\n    var clonedOptions = mergeOptions({}, {\n      disconnectHandler: store,\n      cursorFactory: Cursor,\n      reconnect: false,\n      emitError: typeof options.emitError === 'boolean' ? options.emitError : true,\n      size: typeof options.poolSize === 'number' ? options.poolSize : 5,\n      monitorCommands: typeof options.monitorCommands === 'boolean' ? options.monitorCommands : false\n    }); // Translate any SSL options and other connectivity options\n\n    clonedOptions = translateOptions(clonedOptions, options); // Socket options\n\n    var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0 ? options.socketOptions : options; // Translate all the options to the core types\n\n    clonedOptions = translateOptions(clonedOptions, socketOptions); // Create the ReplSet\n\n    var coreTopology = new CReplSet(seedlist, clonedOptions); // Listen to reconnect event\n\n    coreTopology.on('reconnect', function () {\n      self.emit('reconnect');\n      store.execute();\n    }); // Internal state\n\n    _this.s = {\n      // Replicaset\n      coreTopology: coreTopology,\n      // Server capabilities\n      sCapabilities: null,\n      // Debug tag\n      tag: options.tag,\n      // Store options\n      storeOptions: storeOptions,\n      // Cloned options\n      clonedOptions: clonedOptions,\n      // Store\n      store: store,\n      // Options\n      options: options,\n      // Server Session Pool\n      sessionPool: null,\n      // Active client sessions\n      sessions: new Set(),\n      // Promise library\n      promiseLibrary: options.promiseLibrary || Promise\n    }; // Debug\n\n    if (clonedOptions.debug) {\n      // Last ismaster\n      Object.defineProperty(_assertThisInitialized(_this), 'replset', {\n        enumerable: true,\n        get: function get() {\n          return coreTopology;\n        }\n      });\n    }\n\n    return _this;\n  } // Connect method\n\n\n  _createClass(ReplSet, [{\n    key: \"connect\",\n    value: function connect(_options, callback) {\n      var self = this;\n      if ('function' === typeof _options) callback = _options, _options = {};\n      if (_options == null) _options = {};\n      if (!('function' === typeof callback)) callback = null;\n      _options = Object.assign({}, this.s.clonedOptions, _options);\n      self.s.options = _options; // Update bufferMaxEntries\n\n      self.s.storeOptions.bufferMaxEntries = typeof _options.bufferMaxEntries === 'number' ? _options.bufferMaxEntries : -1; // Actual handler\n\n      var errorHandler = function errorHandler(event) {\n        return function (err) {\n          if (event !== 'error') {\n            self.emit(event, err);\n          }\n        };\n      }; // Clear out all the current handlers left over\n\n\n      var events = ['timeout', 'error', 'close', 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'serverClosed', 'topologyOpening', 'topologyClosed', 'topologyDescriptionChanged', 'commandStarted', 'commandSucceeded', 'commandFailed', 'joined', 'left', 'ping', 'ha'];\n      events.forEach(function (e) {\n        self.s.coreTopology.removeAllListeners(e);\n      }); // relay the event\n\n      var relay = function relay(event) {\n        return function (t, server) {\n          self.emit(event, t, server);\n        };\n      }; // Replset events relay\n\n\n      var replsetRelay = function replsetRelay(event) {\n        return function (t, server) {\n          self.emit(event, t, server.lastIsMaster(), server);\n        };\n      }; // Relay ha\n\n\n      var relayHa = function relayHa(t, state) {\n        self.emit('ha', t, state);\n\n        if (t === 'start') {\n          self.emit('ha_connect', t, state);\n        } else if (t === 'end') {\n          self.emit('ha_ismaster', t, state);\n        }\n      }; // Set up serverConfig listeners\n\n\n      self.s.coreTopology.on('joined', replsetRelay('joined'));\n      self.s.coreTopology.on('left', relay('left'));\n      self.s.coreTopology.on('ping', relay('ping'));\n      self.s.coreTopology.on('ha', relayHa); // Set up SDAM listeners\n\n      self.s.coreTopology.on('serverDescriptionChanged', relay('serverDescriptionChanged'));\n      self.s.coreTopology.on('serverHeartbeatStarted', relay('serverHeartbeatStarted'));\n      self.s.coreTopology.on('serverHeartbeatSucceeded', relay('serverHeartbeatSucceeded'));\n      self.s.coreTopology.on('serverHeartbeatFailed', relay('serverHeartbeatFailed'));\n      self.s.coreTopology.on('serverOpening', relay('serverOpening'));\n      self.s.coreTopology.on('serverClosed', relay('serverClosed'));\n      self.s.coreTopology.on('topologyOpening', relay('topologyOpening'));\n      self.s.coreTopology.on('topologyClosed', relay('topologyClosed'));\n      self.s.coreTopology.on('topologyDescriptionChanged', relay('topologyDescriptionChanged'));\n      self.s.coreTopology.on('commandStarted', relay('commandStarted'));\n      self.s.coreTopology.on('commandSucceeded', relay('commandSucceeded'));\n      self.s.coreTopology.on('commandFailed', relay('commandFailed'));\n      self.s.coreTopology.on('fullsetup', function () {\n        self.emit('fullsetup', self, self);\n      });\n      self.s.coreTopology.on('all', function () {\n        self.emit('all', null, self);\n      }); // Connect handler\n\n      var connectHandler = function connectHandler() {\n        // Set up listeners\n        self.s.coreTopology.once('timeout', errorHandler('timeout'));\n        self.s.coreTopology.once('error', errorHandler('error'));\n        self.s.coreTopology.once('close', errorHandler('close')); // Emit open event\n\n        self.emit('open', null, self); // Return correctly\n\n        try {\n          callback(null, self);\n        } catch (err) {\n          process.nextTick(function () {\n            throw err;\n          });\n        }\n      }; // Error handler\n\n\n      var connectErrorHandler = function connectErrorHandler() {\n        return function (err) {\n          ['timeout', 'error', 'close'].forEach(function (e) {\n            self.s.coreTopology.removeListener(e, connectErrorHandler);\n          });\n          self.s.coreTopology.removeListener('connect', connectErrorHandler); // Destroy the replset\n\n          self.s.coreTopology.destroy(); // Try to callback\n\n          try {\n            callback(err);\n          } catch (err) {\n            if (!self.s.coreTopology.isConnected()) process.nextTick(function () {\n              throw err;\n            });\n          }\n        };\n      }; // Set up listeners\n\n\n      self.s.coreTopology.once('timeout', connectErrorHandler('timeout'));\n      self.s.coreTopology.once('error', connectErrorHandler('error'));\n      self.s.coreTopology.once('close', connectErrorHandler('close'));\n      self.s.coreTopology.once('connect', connectHandler); // Start connection\n\n      self.s.coreTopology.connect(_options);\n    }\n  }, {\n    key: \"close\",\n    value: function close(forceClosed, callback) {\n      var _this2 = this;\n\n      ['timeout', 'error', 'close', 'joined', 'left'].forEach(function (e) {\n        return _this2.removeAllListeners(e);\n      });\n\n      _get(_getPrototypeOf(ReplSet.prototype), \"close\", this).call(this, forceClosed, callback);\n    }\n  }]);\n\n  return ReplSet;\n}(TopologyBase);\n\nObject.defineProperty(ReplSet.prototype, 'haInterval', {\n  enumerable: true,\n  get: function get() {\n    return this.s.coreTopology.s.haInterval;\n  }\n});\n/**\n * A replset connect event, used to verify that the connection is up and running\n *\n * @event ReplSet#connect\n * @type {ReplSet}\n */\n\n/**\n * The replset high availability event\n *\n * @event ReplSet#ha\n * @type {function}\n * @param {string} type The stage in the high availability event (start|end)\n * @param {boolean} data.norepeat This is a repeating high availability process or a single execution only\n * @param {number} data.id The id for this high availability request\n * @param {object} data.state An object containing the information about the current replicaset\n */\n\n/**\n * A server member left the replicaset\n *\n * @event ReplSet#left\n * @type {function}\n * @param {string} type The type of member that left (primary|secondary|arbiter)\n * @param {Server} server The server object that left\n */\n\n/**\n * A server member joined the replicaset\n *\n * @event ReplSet#joined\n * @type {function}\n * @param {string} type The type of member that joined (primary|secondary|arbiter)\n * @param {Server} server The server object that joined\n */\n\n/**\n * ReplSet open event, emitted when replicaset can start processing commands.\n *\n * @event ReplSet#open\n * @type {Replset}\n */\n\n/**\n * ReplSet fullsetup event, emitted when all servers in the topology have been connected to.\n *\n * @event ReplSet#fullsetup\n * @type {Replset}\n */\n\n/**\n * ReplSet close event\n *\n * @event ReplSet#close\n * @type {object}\n */\n\n/**\n * ReplSet error event, emitted if there is an error listener.\n *\n * @event ReplSet#error\n * @type {MongoError}\n */\n\n/**\n * ReplSet timeout event\n *\n * @event ReplSet#timeout\n * @type {object}\n */\n\n/**\n * ReplSet parseError event\n *\n * @event ReplSet#parseError\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command was started, if command monitoring is enabled\n *\n * @event ReplSet#commandStarted\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command succeeded, if command monitoring is enabled\n *\n * @event ReplSet#commandSucceeded\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command failed, if command monitoring is enabled\n *\n * @event ReplSet#commandFailed\n * @type {object}\n */\n\nmodule.exports = ReplSet;","map":{"version":3,"sources":["/Users/S/Desktop/nodeprotake2/node_modules/mongodb/lib/topologies/replset.js"],"names":["Server","require","Cursor","MongoError","TopologyBase","Store","CReplSet","ReplSet","MAX_JS_INT","translateOptions","filterOptions","mergeOptions","legalOptionNames","servers","options","self","i","length","create","message","driver","storeOptions","force","bufferMaxEntries","store","seedlist","map","x","host","port","clonedOptions","disconnectHandler","cursorFactory","reconnect","emitError","size","poolSize","monitorCommands","socketOptions","Object","keys","coreTopology","on","emit","execute","s","sCapabilities","tag","sessionPool","sessions","Set","promiseLibrary","Promise","debug","defineProperty","enumerable","get","_options","callback","assign","errorHandler","event","err","events","forEach","e","removeAllListeners","relay","t","server","replsetRelay","lastIsMaster","relayHa","state","connectHandler","once","process","nextTick","connectErrorHandler","removeListener","destroy","isConnected","connect","forceClosed","prototype","haInterval","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Server = require('./server');\nconst Cursor = require('../cursor');\nconst MongoError = require('../core').MongoError;\nconst TopologyBase = require('./topology_base').TopologyBase;\nconst Store = require('./topology_base').Store;\nconst CReplSet = require('../core').ReplSet;\nconst MAX_JS_INT = require('../utils').MAX_JS_INT;\nconst translateOptions = require('../utils').translateOptions;\nconst filterOptions = require('../utils').filterOptions;\nconst mergeOptions = require('../utils').mergeOptions;\n\n/**\n * @fileOverview The **ReplSet** class is a class that represents a Replicaset topology and is\n * used to construct connections.\n *\n * **ReplSet Should not be used, use MongoClient.connect**\n */\n\n// Allowed parameters\nvar legalOptionNames = [\n  'ha',\n  'haInterval',\n  'replicaSet',\n  'rs_name',\n  'secondaryAcceptableLatencyMS',\n  'connectWithNoPrimary',\n  'poolSize',\n  'ssl',\n  'checkServerIdentity',\n  'sslValidate',\n  'sslCA',\n  'sslCert',\n  'ciphers',\n  'ecdhCurve',\n  'sslCRL',\n  'sslKey',\n  'sslPass',\n  'socketOptions',\n  'bufferMaxEntries',\n  'store',\n  'auto_reconnect',\n  'autoReconnect',\n  'emitError',\n  'keepAlive',\n  'keepAliveInitialDelay',\n  'noDelay',\n  'connectTimeoutMS',\n  'socketTimeoutMS',\n  'strategy',\n  'debug',\n  'family',\n  'loggerLevel',\n  'logger',\n  'reconnectTries',\n  'appname',\n  'domainsEnabled',\n  'servername',\n  'promoteLongs',\n  'promoteValues',\n  'promoteBuffers',\n  'maxStalenessSeconds',\n  'promiseLibrary',\n  'minSize',\n  'monitorCommands'\n];\n\n/**\n * Creates a new ReplSet instance\n * @class\n * @deprecated\n * @param {Server[]} servers A seedlist of servers participating in the replicaset.\n * @param {object} [options] Optional settings.\n * @param {boolean} [options.ha=true] Turn on high availability monitoring.\n * @param {number} [options.haInterval=10000] Time between each replicaset status check.\n * @param {string} [options.replicaSet] The name of the replicaset to connect to.\n * @param {number} [options.secondaryAcceptableLatencyMS=15] Sets the range of servers to pick when using NEAREST (lowest ping ms + the latency fence, ex: range of 1 to (1 + 15) ms)\n * @param {boolean} [options.connectWithNoPrimary=false] Sets if the driver should connect even if no primary is available\n * @param {number} [options.poolSize=5] Number of connections in the connection pool for each server instance, set to 5 as default for legacy reasons.\n * @param {boolean} [options.ssl=false] Use ssl connection (needs to have a mongod server with ssl support)\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {boolean} [options.sslValidate=false] Validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {array} [options.sslCA] Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {array} [options.sslCRL] Array of revocation certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {(Buffer|string)} [options.sslCert] String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher.\n * @param {string} [options.ciphers] Passed directly through to tls.createSecureContext. See https://nodejs.org/dist/latest-v9.x/docs/api/tls.html#tls_tls_createsecurecontext_options for more info.\n * @param {string} [options.ecdhCurve] Passed directly through to tls.createSecureContext. See https://nodejs.org/dist/latest-v9.x/docs/api/tls.html#tls_tls_createsecurecontext_options for more info.\n * @param {(Buffer|string)} [options.sslKey] String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {(Buffer|string)} [options.sslPass] String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {string} [options.servername] String containing the server name requested via TLS SNI.\n * @param {object} [options.socketOptions] Socket options\n * @param {boolean} [options.socketOptions.noDelay=true] TCP Socket NoDelay option.\n * @param {boolean} [options.socketOptions.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.socketOptions.keepAliveInitialDelay=30000] The number of milliseconds to wait before initiating keepAlive on the TCP socket\n * @param {number} [options.socketOptions.connectTimeoutMS=10000] How long to wait for a connection to be established before timing out\n * @param {number} [options.socketOptions.socketTimeoutMS=360000] How long a send or receive on a socket can take before timing out\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\n * @param {number} [options.maxStalenessSeconds=undefined] The max staleness to secondary reads (values under 10 seconds cannot be guaranteed);\n * @param {boolean} [options.monitorCommands=false] Enable command monitoring for this topology\n * @fires ReplSet#connect\n * @fires ReplSet#ha\n * @fires ReplSet#joined\n * @fires ReplSet#left\n * @fires ReplSet#fullsetup\n * @fires ReplSet#open\n * @fires ReplSet#close\n * @fires ReplSet#error\n * @fires ReplSet#timeout\n * @fires ReplSet#parseError\n * @fires ReplSet#commandStarted\n * @fires ReplSet#commandSucceeded\n * @fires ReplSet#commandFailed\n * @property {string} parserType the parser type used (c++ or js).\n * @return {ReplSet} a ReplSet instance.\n */\nclass ReplSet extends TopologyBase {\n  constructor(servers, options) {\n    super();\n\n    options = options || {};\n    var self = this;\n\n    // Filter the options\n    options = filterOptions(options, legalOptionNames);\n\n    // Ensure all the instances are Server\n    for (var i = 0; i < servers.length; i++) {\n      if (!(servers[i] instanceof Server)) {\n        throw MongoError.create({\n          message: 'all seed list instances must be of the Server type',\n          driver: true\n        });\n      }\n    }\n\n    // Stored options\n    var storeOptions = {\n      force: false,\n      bufferMaxEntries:\n        typeof options.bufferMaxEntries === 'number' ? options.bufferMaxEntries : MAX_JS_INT\n    };\n\n    // Shared global store\n    var store = options.store || new Store(self, storeOptions);\n\n    // Build seed list\n    var seedlist = servers.map(function(x) {\n      return { host: x.host, port: x.port };\n    });\n\n    // Clone options\n    var clonedOptions = mergeOptions(\n      {},\n      {\n        disconnectHandler: store,\n        cursorFactory: Cursor,\n        reconnect: false,\n        emitError: typeof options.emitError === 'boolean' ? options.emitError : true,\n        size: typeof options.poolSize === 'number' ? options.poolSize : 5,\n        monitorCommands:\n          typeof options.monitorCommands === 'boolean' ? options.monitorCommands : false\n      }\n    );\n\n    // Translate any SSL options and other connectivity options\n    clonedOptions = translateOptions(clonedOptions, options);\n\n    // Socket options\n    var socketOptions =\n      options.socketOptions && Object.keys(options.socketOptions).length > 0\n        ? options.socketOptions\n        : options;\n\n    // Translate all the options to the core types\n    clonedOptions = translateOptions(clonedOptions, socketOptions);\n\n    // Create the ReplSet\n    var coreTopology = new CReplSet(seedlist, clonedOptions);\n\n    // Listen to reconnect event\n    coreTopology.on('reconnect', function() {\n      self.emit('reconnect');\n      store.execute();\n    });\n\n    // Internal state\n    this.s = {\n      // Replicaset\n      coreTopology: coreTopology,\n      // Server capabilities\n      sCapabilities: null,\n      // Debug tag\n      tag: options.tag,\n      // Store options\n      storeOptions: storeOptions,\n      // Cloned options\n      clonedOptions: clonedOptions,\n      // Store\n      store: store,\n      // Options\n      options: options,\n      // Server Session Pool\n      sessionPool: null,\n      // Active client sessions\n      sessions: new Set(),\n      // Promise library\n      promiseLibrary: options.promiseLibrary || Promise\n    };\n\n    // Debug\n    if (clonedOptions.debug) {\n      // Last ismaster\n      Object.defineProperty(this, 'replset', {\n        enumerable: true,\n        get: function() {\n          return coreTopology;\n        }\n      });\n    }\n  }\n\n  // Connect method\n  connect(_options, callback) {\n    var self = this;\n    if ('function' === typeof _options) (callback = _options), (_options = {});\n    if (_options == null) _options = {};\n    if (!('function' === typeof callback)) callback = null;\n    _options = Object.assign({}, this.s.clonedOptions, _options);\n    self.s.options = _options;\n\n    // Update bufferMaxEntries\n    self.s.storeOptions.bufferMaxEntries =\n      typeof _options.bufferMaxEntries === 'number' ? _options.bufferMaxEntries : -1;\n\n    // Actual handler\n    var errorHandler = function(event) {\n      return function(err) {\n        if (event !== 'error') {\n          self.emit(event, err);\n        }\n      };\n    };\n\n    // Clear out all the current handlers left over\n    var events = [\n      'timeout',\n      'error',\n      'close',\n      'serverOpening',\n      'serverDescriptionChanged',\n      'serverHeartbeatStarted',\n      'serverHeartbeatSucceeded',\n      'serverHeartbeatFailed',\n      'serverClosed',\n      'topologyOpening',\n      'topologyClosed',\n      'topologyDescriptionChanged',\n      'commandStarted',\n      'commandSucceeded',\n      'commandFailed',\n      'joined',\n      'left',\n      'ping',\n      'ha'\n    ];\n    events.forEach(function(e) {\n      self.s.coreTopology.removeAllListeners(e);\n    });\n\n    // relay the event\n    var relay = function(event) {\n      return function(t, server) {\n        self.emit(event, t, server);\n      };\n    };\n\n    // Replset events relay\n    var replsetRelay = function(event) {\n      return function(t, server) {\n        self.emit(event, t, server.lastIsMaster(), server);\n      };\n    };\n\n    // Relay ha\n    var relayHa = function(t, state) {\n      self.emit('ha', t, state);\n\n      if (t === 'start') {\n        self.emit('ha_connect', t, state);\n      } else if (t === 'end') {\n        self.emit('ha_ismaster', t, state);\n      }\n    };\n\n    // Set up serverConfig listeners\n    self.s.coreTopology.on('joined', replsetRelay('joined'));\n    self.s.coreTopology.on('left', relay('left'));\n    self.s.coreTopology.on('ping', relay('ping'));\n    self.s.coreTopology.on('ha', relayHa);\n\n    // Set up SDAM listeners\n    self.s.coreTopology.on('serverDescriptionChanged', relay('serverDescriptionChanged'));\n    self.s.coreTopology.on('serverHeartbeatStarted', relay('serverHeartbeatStarted'));\n    self.s.coreTopology.on('serverHeartbeatSucceeded', relay('serverHeartbeatSucceeded'));\n    self.s.coreTopology.on('serverHeartbeatFailed', relay('serverHeartbeatFailed'));\n    self.s.coreTopology.on('serverOpening', relay('serverOpening'));\n    self.s.coreTopology.on('serverClosed', relay('serverClosed'));\n    self.s.coreTopology.on('topologyOpening', relay('topologyOpening'));\n    self.s.coreTopology.on('topologyClosed', relay('topologyClosed'));\n    self.s.coreTopology.on('topologyDescriptionChanged', relay('topologyDescriptionChanged'));\n    self.s.coreTopology.on('commandStarted', relay('commandStarted'));\n    self.s.coreTopology.on('commandSucceeded', relay('commandSucceeded'));\n    self.s.coreTopology.on('commandFailed', relay('commandFailed'));\n\n    self.s.coreTopology.on('fullsetup', function() {\n      self.emit('fullsetup', self, self);\n    });\n\n    self.s.coreTopology.on('all', function() {\n      self.emit('all', null, self);\n    });\n\n    // Connect handler\n    var connectHandler = function() {\n      // Set up listeners\n      self.s.coreTopology.once('timeout', errorHandler('timeout'));\n      self.s.coreTopology.once('error', errorHandler('error'));\n      self.s.coreTopology.once('close', errorHandler('close'));\n\n      // Emit open event\n      self.emit('open', null, self);\n\n      // Return correctly\n      try {\n        callback(null, self);\n      } catch (err) {\n        process.nextTick(function() {\n          throw err;\n        });\n      }\n    };\n\n    // Error handler\n    var connectErrorHandler = function() {\n      return function(err) {\n        ['timeout', 'error', 'close'].forEach(function(e) {\n          self.s.coreTopology.removeListener(e, connectErrorHandler);\n        });\n\n        self.s.coreTopology.removeListener('connect', connectErrorHandler);\n        // Destroy the replset\n        self.s.coreTopology.destroy();\n\n        // Try to callback\n        try {\n          callback(err);\n        } catch (err) {\n          if (!self.s.coreTopology.isConnected())\n            process.nextTick(function() {\n              throw err;\n            });\n        }\n      };\n    };\n\n    // Set up listeners\n    self.s.coreTopology.once('timeout', connectErrorHandler('timeout'));\n    self.s.coreTopology.once('error', connectErrorHandler('error'));\n    self.s.coreTopology.once('close', connectErrorHandler('close'));\n    self.s.coreTopology.once('connect', connectHandler);\n\n    // Start connection\n    self.s.coreTopology.connect(_options);\n  }\n\n  close(forceClosed, callback) {\n    ['timeout', 'error', 'close', 'joined', 'left'].forEach(e => this.removeAllListeners(e));\n    super.close(forceClosed, callback);\n  }\n}\n\nObject.defineProperty(ReplSet.prototype, 'haInterval', {\n  enumerable: true,\n  get: function() {\n    return this.s.coreTopology.s.haInterval;\n  }\n});\n\n/**\n * A replset connect event, used to verify that the connection is up and running\n *\n * @event ReplSet#connect\n * @type {ReplSet}\n */\n\n/**\n * The replset high availability event\n *\n * @event ReplSet#ha\n * @type {function}\n * @param {string} type The stage in the high availability event (start|end)\n * @param {boolean} data.norepeat This is a repeating high availability process or a single execution only\n * @param {number} data.id The id for this high availability request\n * @param {object} data.state An object containing the information about the current replicaset\n */\n\n/**\n * A server member left the replicaset\n *\n * @event ReplSet#left\n * @type {function}\n * @param {string} type The type of member that left (primary|secondary|arbiter)\n * @param {Server} server The server object that left\n */\n\n/**\n * A server member joined the replicaset\n *\n * @event ReplSet#joined\n * @type {function}\n * @param {string} type The type of member that joined (primary|secondary|arbiter)\n * @param {Server} server The server object that joined\n */\n\n/**\n * ReplSet open event, emitted when replicaset can start processing commands.\n *\n * @event ReplSet#open\n * @type {Replset}\n */\n\n/**\n * ReplSet fullsetup event, emitted when all servers in the topology have been connected to.\n *\n * @event ReplSet#fullsetup\n * @type {Replset}\n */\n\n/**\n * ReplSet close event\n *\n * @event ReplSet#close\n * @type {object}\n */\n\n/**\n * ReplSet error event, emitted if there is an error listener.\n *\n * @event ReplSet#error\n * @type {MongoError}\n */\n\n/**\n * ReplSet timeout event\n *\n * @event ReplSet#timeout\n * @type {object}\n */\n\n/**\n * ReplSet parseError event\n *\n * @event ReplSet#parseError\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command was started, if command monitoring is enabled\n *\n * @event ReplSet#commandStarted\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command succeeded, if command monitoring is enabled\n *\n * @event ReplSet#commandSucceeded\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command failed, if command monitoring is enabled\n *\n * @event ReplSet#commandFailed\n * @type {object}\n */\n\nmodule.exports = ReplSet;\n"]},"metadata":{},"sourceType":"script"}