{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar CServer = require('../core').Server;\n\nvar Cursor = require('../cursor');\n\nvar TopologyBase = require('./topology_base').TopologyBase;\n\nvar Store = require('./topology_base').Store;\n\nvar MongoError = require('../core').MongoError;\n\nvar MAX_JS_INT = require('../utils').MAX_JS_INT;\n\nvar translateOptions = require('../utils').translateOptions;\n\nvar filterOptions = require('../utils').filterOptions;\n\nvar mergeOptions = require('../utils').mergeOptions;\n/**\n * @fileOverview The **Server** class is a class that represents a single server topology and is\n * used to construct connections.\n *\n * **Server Should not be used, use MongoClient.connect**\n */\n// Allowed parameters\n\n\nvar legalOptionNames = ['ha', 'haInterval', 'acceptableLatencyMS', 'poolSize', 'ssl', 'checkServerIdentity', 'sslValidate', 'sslCA', 'sslCRL', 'sslCert', 'ciphers', 'ecdhCurve', 'sslKey', 'sslPass', 'socketOptions', 'bufferMaxEntries', 'store', 'auto_reconnect', 'autoReconnect', 'emitError', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectTimeoutMS', 'socketTimeoutMS', 'family', 'loggerLevel', 'logger', 'reconnectTries', 'reconnectInterval', 'monitoring', 'appname', 'domainsEnabled', 'servername', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'compression', 'promiseLibrary', 'monitorCommands'];\n/**\n * Creates a new Server instance\n * @class\n * @deprecated\n * @param {string} host The host for the server, can be either an IP4, IP6 or domain socket style host.\n * @param {number} [port] The server port if IP4.\n * @param {object} [options] Optional settings.\n * @param {number} [options.poolSize=5] Number of connections in the connection pool for each server instance, set to 5 as default for legacy reasons.\n * @param {boolean} [options.ssl=false] Use ssl connection (needs to have a mongod server with ssl support)\n * @param {boolean} [options.sslValidate=false] Validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {array} [options.sslCA] Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {array} [options.sslCRL] Array of revocation certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {(Buffer|string)} [options.sslCert] String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {string} [options.ciphers] Passed directly through to tls.createSecureContext. See https://nodejs.org/dist/latest-v9.x/docs/api/tls.html#tls_tls_createsecurecontext_options for more info.\n * @param {string} [options.ecdhCurve] Passed directly through to tls.createSecureContext. See https://nodejs.org/dist/latest-v9.x/docs/api/tls.html#tls_tls_createsecurecontext_options for more info.\n * @param {(Buffer|string)} [options.sslKey] String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {(Buffer|string)} [options.sslPass] String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {string} [options.servername] String containing the server name requested via TLS SNI.\n * @param {object} [options.socketOptions] Socket options\n * @param {boolean} [options.socketOptions.autoReconnect=true] Reconnect on error.\n * @param {boolean} [options.socketOptions.noDelay=true] TCP Socket NoDelay option.\n * @param {boolean} [options.socketOptions.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.socketOptions.keepAliveInitialDelay=30000] The number of milliseconds to wait before initiating keepAlive on the TCP socket\n * @param {number} [options.socketOptions.connectTimeoutMS=10000] How long to wait for a connection to be established before timing out\n * @param {number} [options.socketOptions.socketTimeoutMS=360000] How long a send or receive on a socket can take before timing out\n * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times\n * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries\n * @param {boolean} [options.monitoring=true] Triggers the server instance to call ismaster\n * @param {number} [options.haInterval=10000] The interval of calling ismaster when monitoring is enabled.\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\n * @param {boolean} [options.monitorCommands=false] Enable command monitoring for this topology\n * @fires Server#connect\n * @fires Server#close\n * @fires Server#error\n * @fires Server#timeout\n * @fires Server#parseError\n * @fires Server#reconnect\n * @fires Server#commandStarted\n * @fires Server#commandSucceeded\n * @fires Server#commandFailed\n * @property {string} parserType the parser type used (c++ or js).\n * @return {Server} a Server instance.\n */\n\nvar Server = /*#__PURE__*/function (_TopologyBase) {\n  _inherits(Server, _TopologyBase);\n\n  var _super = _createSuper(Server);\n\n  function Server(host, port, options) {\n    var _this;\n\n    _classCallCheck(this, Server);\n\n    _this = _super.call(this);\n\n    var self = _assertThisInitialized(_this); // Filter the options\n\n\n    options = filterOptions(options, legalOptionNames); // Promise library\n\n    var promiseLibrary = options.promiseLibrary; // Stored options\n\n    var storeOptions = {\n      force: false,\n      bufferMaxEntries: typeof options.bufferMaxEntries === 'number' ? options.bufferMaxEntries : MAX_JS_INT\n    }; // Shared global store\n\n    var store = options.store || new Store(self, storeOptions); // Detect if we have a socket connection\n\n    if (host.indexOf('/') !== -1) {\n      if (port != null && typeof port === 'object') {\n        options = port;\n        port = null;\n      }\n    } else if (port == null) {\n      throw MongoError.create({\n        message: 'port must be specified',\n        driver: true\n      });\n    } // Get the reconnect option\n\n\n    var reconnect = typeof options.auto_reconnect === 'boolean' ? options.auto_reconnect : true;\n    reconnect = typeof options.autoReconnect === 'boolean' ? options.autoReconnect : reconnect; // Clone options\n\n    var clonedOptions = mergeOptions({}, {\n      host: host,\n      port: port,\n      disconnectHandler: store,\n      cursorFactory: Cursor,\n      reconnect: reconnect,\n      emitError: typeof options.emitError === 'boolean' ? options.emitError : true,\n      size: typeof options.poolSize === 'number' ? options.poolSize : 5,\n      monitorCommands: typeof options.monitorCommands === 'boolean' ? options.monitorCommands : false\n    }); // Translate any SSL options and other connectivity options\n\n    clonedOptions = translateOptions(clonedOptions, options); // Socket options\n\n    var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0 ? options.socketOptions : options; // Translate all the options to the core types\n\n    clonedOptions = translateOptions(clonedOptions, socketOptions); // Define the internal properties\n\n    _this.s = {\n      // Create an instance of a server instance from core module\n      coreTopology: new CServer(clonedOptions),\n      // Server capabilities\n      sCapabilities: null,\n      // Cloned options\n      clonedOptions: clonedOptions,\n      // Reconnect\n      reconnect: clonedOptions.reconnect,\n      // Emit error\n      emitError: clonedOptions.emitError,\n      // Pool size\n      poolSize: clonedOptions.size,\n      // Store Options\n      storeOptions: storeOptions,\n      // Store\n      store: store,\n      // Host\n      host: host,\n      // Port\n      port: port,\n      // Options\n      options: options,\n      // Server Session Pool\n      sessionPool: null,\n      // Active client sessions\n      sessions: new Set(),\n      // Promise library\n      promiseLibrary: promiseLibrary || Promise\n    };\n    return _this;\n  } // Connect\n\n\n  _createClass(Server, [{\n    key: \"connect\",\n    value: function connect(_options, callback) {\n      var self = this;\n      if ('function' === typeof _options) callback = _options, _options = {};\n      if (_options == null) _options = this.s.clonedOptions;\n      if (!('function' === typeof callback)) callback = null;\n      _options = Object.assign({}, this.s.clonedOptions, _options);\n      self.s.options = _options; // Update bufferMaxEntries\n\n      self.s.storeOptions.bufferMaxEntries = typeof _options.bufferMaxEntries === 'number' ? _options.bufferMaxEntries : -1; // Error handler\n\n      var connectErrorHandler = function connectErrorHandler() {\n        return function (err) {\n          // Remove all event handlers\n          var events = ['timeout', 'error', 'close'];\n          events.forEach(function (e) {\n            self.s.coreTopology.removeListener(e, connectHandlers[e]);\n          });\n          self.s.coreTopology.removeListener('connect', connectErrorHandler); // Try to callback\n\n          try {\n            callback(err);\n          } catch (err) {\n            process.nextTick(function () {\n              throw err;\n            });\n          }\n        };\n      }; // Actual handler\n\n\n      var errorHandler = function errorHandler(event) {\n        return function (err) {\n          if (event !== 'error') {\n            self.emit(event, err);\n          }\n        };\n      }; // Error handler\n\n\n      var reconnectHandler = function reconnectHandler() {\n        self.emit('reconnect', self);\n        self.s.store.execute();\n      }; // Reconnect failed\n\n\n      var reconnectFailedHandler = function reconnectFailedHandler(err) {\n        self.emit('reconnectFailed', err);\n        self.s.store.flush(err);\n      }; // Destroy called on topology, perform cleanup\n\n\n      var destroyHandler = function destroyHandler() {\n        self.s.store.flush();\n      }; // relay the event\n\n\n      var relay = function relay(event) {\n        return function (t, server) {\n          self.emit(event, t, server);\n        };\n      }; // Connect handler\n\n\n      var connectHandler = function connectHandler() {\n        // Clear out all the current handlers left over\n        ['timeout', 'error', 'close', 'destroy'].forEach(function (e) {\n          self.s.coreTopology.removeAllListeners(e);\n        }); // Set up listeners\n\n        self.s.coreTopology.on('timeout', errorHandler('timeout'));\n        self.s.coreTopology.once('error', errorHandler('error'));\n        self.s.coreTopology.on('close', errorHandler('close')); // Only called on destroy\n\n        self.s.coreTopology.on('destroy', destroyHandler); // Emit open event\n\n        self.emit('open', null, self); // Return correctly\n\n        try {\n          callback(null, self);\n        } catch (err) {\n          process.nextTick(function () {\n            throw err;\n          });\n        }\n      }; // Set up listeners\n\n\n      var connectHandlers = {\n        timeout: connectErrorHandler('timeout'),\n        error: connectErrorHandler('error'),\n        close: connectErrorHandler('close')\n      }; // Clear out all the current handlers left over\n\n      ['timeout', 'error', 'close', 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'serverClosed', 'topologyOpening', 'topologyClosed', 'topologyDescriptionChanged', 'commandStarted', 'commandSucceeded', 'commandFailed'].forEach(function (e) {\n        self.s.coreTopology.removeAllListeners(e);\n      }); // Add the event handlers\n\n      self.s.coreTopology.once('timeout', connectHandlers.timeout);\n      self.s.coreTopology.once('error', connectHandlers.error);\n      self.s.coreTopology.once('close', connectHandlers.close);\n      self.s.coreTopology.once('connect', connectHandler); // Reconnect server\n\n      self.s.coreTopology.on('reconnect', reconnectHandler);\n      self.s.coreTopology.on('reconnectFailed', reconnectFailedHandler); // Set up SDAM listeners\n\n      self.s.coreTopology.on('serverDescriptionChanged', relay('serverDescriptionChanged'));\n      self.s.coreTopology.on('serverHeartbeatStarted', relay('serverHeartbeatStarted'));\n      self.s.coreTopology.on('serverHeartbeatSucceeded', relay('serverHeartbeatSucceeded'));\n      self.s.coreTopology.on('serverHeartbeatFailed', relay('serverHeartbeatFailed'));\n      self.s.coreTopology.on('serverOpening', relay('serverOpening'));\n      self.s.coreTopology.on('serverClosed', relay('serverClosed'));\n      self.s.coreTopology.on('topologyOpening', relay('topologyOpening'));\n      self.s.coreTopology.on('topologyClosed', relay('topologyClosed'));\n      self.s.coreTopology.on('topologyDescriptionChanged', relay('topologyDescriptionChanged'));\n      self.s.coreTopology.on('commandStarted', relay('commandStarted'));\n      self.s.coreTopology.on('commandSucceeded', relay('commandSucceeded'));\n      self.s.coreTopology.on('commandFailed', relay('commandFailed'));\n      self.s.coreTopology.on('attemptReconnect', relay('attemptReconnect'));\n      self.s.coreTopology.on('monitoring', relay('monitoring')); // Start connection\n\n      self.s.coreTopology.connect(_options);\n    }\n  }]);\n\n  return Server;\n}(TopologyBase);\n\nObject.defineProperty(Server.prototype, 'poolSize', {\n  enumerable: true,\n  get: function get() {\n    return this.s.coreTopology.connections().length;\n  }\n});\nObject.defineProperty(Server.prototype, 'autoReconnect', {\n  enumerable: true,\n  get: function get() {\n    return this.s.reconnect;\n  }\n});\nObject.defineProperty(Server.prototype, 'host', {\n  enumerable: true,\n  get: function get() {\n    return this.s.host;\n  }\n});\nObject.defineProperty(Server.prototype, 'port', {\n  enumerable: true,\n  get: function get() {\n    return this.s.port;\n  }\n});\n/**\n * Server connect event\n *\n * @event Server#connect\n * @type {object}\n */\n\n/**\n * Server close event\n *\n * @event Server#close\n * @type {object}\n */\n\n/**\n * Server reconnect event\n *\n * @event Server#reconnect\n * @type {object}\n */\n\n/**\n * Server error event\n *\n * @event Server#error\n * @type {MongoError}\n */\n\n/**\n * Server timeout event\n *\n * @event Server#timeout\n * @type {object}\n */\n\n/**\n * Server parseError event\n *\n * @event Server#parseError\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command was started, if command monitoring is enabled\n *\n * @event Server#commandStarted\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command succeeded, if command monitoring is enabled\n *\n * @event Server#commandSucceeded\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command failed, if command monitoring is enabled\n *\n * @event Server#commandFailed\n * @type {object}\n */\n\nmodule.exports = Server;","map":{"version":3,"sources":["/Users/S/Desktop/nodeprotake2/node_modules/mongodb/lib/topologies/server.js"],"names":["CServer","require","Server","Cursor","TopologyBase","Store","MongoError","MAX_JS_INT","translateOptions","filterOptions","mergeOptions","legalOptionNames","host","port","options","self","promiseLibrary","storeOptions","force","bufferMaxEntries","store","indexOf","create","message","driver","reconnect","auto_reconnect","autoReconnect","clonedOptions","disconnectHandler","cursorFactory","emitError","size","poolSize","monitorCommands","socketOptions","Object","keys","length","s","coreTopology","sCapabilities","sessionPool","sessions","Set","Promise","_options","callback","assign","connectErrorHandler","err","events","forEach","e","removeListener","connectHandlers","process","nextTick","errorHandler","event","emit","reconnectHandler","execute","reconnectFailedHandler","flush","destroyHandler","relay","t","server","connectHandler","removeAllListeners","on","once","timeout","error","close","connect","defineProperty","prototype","enumerable","get","connections","module","exports"],"mappings":"AAAA;;;;;;;;;;;;AAEA,IAAMA,OAAO,GAAGC,OAAO,CAAC,SAAD,CAAP,CAAmBC,MAAnC;;AACA,IAAMC,MAAM,GAAGF,OAAO,CAAC,WAAD,CAAtB;;AACA,IAAMG,YAAY,GAAGH,OAAO,CAAC,iBAAD,CAAP,CAA2BG,YAAhD;;AACA,IAAMC,KAAK,GAAGJ,OAAO,CAAC,iBAAD,CAAP,CAA2BI,KAAzC;;AACA,IAAMC,UAAU,GAAGL,OAAO,CAAC,SAAD,CAAP,CAAmBK,UAAtC;;AACA,IAAMC,UAAU,GAAGN,OAAO,CAAC,UAAD,CAAP,CAAoBM,UAAvC;;AACA,IAAMC,gBAAgB,GAAGP,OAAO,CAAC,UAAD,CAAP,CAAoBO,gBAA7C;;AACA,IAAMC,aAAa,GAAGR,OAAO,CAAC,UAAD,CAAP,CAAoBQ,aAA1C;;AACA,IAAMC,YAAY,GAAGT,OAAO,CAAC,UAAD,CAAP,CAAoBS,YAAzC;AAEA;;;;;;AAOA;;;AACA,IAAIC,gBAAgB,GAAG,CACrB,IADqB,EAErB,YAFqB,EAGrB,qBAHqB,EAIrB,UAJqB,EAKrB,KALqB,EAMrB,qBANqB,EAOrB,aAPqB,EAQrB,OARqB,EASrB,QATqB,EAUrB,SAVqB,EAWrB,SAXqB,EAYrB,WAZqB,EAarB,QAbqB,EAcrB,SAdqB,EAerB,eAfqB,EAgBrB,kBAhBqB,EAiBrB,OAjBqB,EAkBrB,gBAlBqB,EAmBrB,eAnBqB,EAoBrB,WApBqB,EAqBrB,WArBqB,EAsBrB,uBAtBqB,EAuBrB,SAvBqB,EAwBrB,kBAxBqB,EAyBrB,iBAzBqB,EA0BrB,QA1BqB,EA2BrB,aA3BqB,EA4BrB,QA5BqB,EA6BrB,gBA7BqB,EA8BrB,mBA9BqB,EA+BrB,YA/BqB,EAgCrB,SAhCqB,EAiCrB,gBAjCqB,EAkCrB,YAlCqB,EAmCrB,cAnCqB,EAoCrB,eApCqB,EAqCrB,gBArCqB,EAsCrB,aAtCqB,EAuCrB,gBAvCqB,EAwCrB,iBAxCqB,CAAvB;AA2CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA4CMT,M;;;;;AACJ,kBAAYU,IAAZ,EAAkBC,IAAlB,EAAwBC,OAAxB,EAAiC;AAAA;;AAAA;;AAC/B;;AACA,QAAIC,IAAI,gCAAR,CAF+B,CAI/B;;;AACAD,IAAAA,OAAO,GAAGL,aAAa,CAACK,OAAD,EAAUH,gBAAV,CAAvB,CAL+B,CAO/B;;AACA,QAAMK,cAAc,GAAGF,OAAO,CAACE,cAA/B,CAR+B,CAU/B;;AACA,QAAIC,YAAY,GAAG;AACjBC,MAAAA,KAAK,EAAE,KADU;AAEjBC,MAAAA,gBAAgB,EACd,OAAOL,OAAO,CAACK,gBAAf,KAAoC,QAApC,GAA+CL,OAAO,CAACK,gBAAvD,GAA0EZ;AAH3D,KAAnB,CAX+B,CAiB/B;;AACA,QAAIa,KAAK,GAAGN,OAAO,CAACM,KAAR,IAAiB,IAAIf,KAAJ,CAAUU,IAAV,EAAgBE,YAAhB,CAA7B,CAlB+B,CAoB/B;;AACA,QAAIL,IAAI,CAACS,OAAL,CAAa,GAAb,MAAsB,CAAC,CAA3B,EAA8B;AAC5B,UAAIR,IAAI,IAAI,IAAR,IAAgB,OAAOA,IAAP,KAAgB,QAApC,EAA8C;AAC5CC,QAAAA,OAAO,GAAGD,IAAV;AACAA,QAAAA,IAAI,GAAG,IAAP;AACD;AACF,KALD,MAKO,IAAIA,IAAI,IAAI,IAAZ,EAAkB;AACvB,YAAMP,UAAU,CAACgB,MAAX,CAAkB;AAAEC,QAAAA,OAAO,EAAE,wBAAX;AAAqCC,QAAAA,MAAM,EAAE;AAA7C,OAAlB,CAAN;AACD,KA5B8B,CA8B/B;;;AACA,QAAIC,SAAS,GAAG,OAAOX,OAAO,CAACY,cAAf,KAAkC,SAAlC,GAA8CZ,OAAO,CAACY,cAAtD,GAAuE,IAAvF;AACAD,IAAAA,SAAS,GAAG,OAAOX,OAAO,CAACa,aAAf,KAAiC,SAAjC,GAA6Cb,OAAO,CAACa,aAArD,GAAqEF,SAAjF,CAhC+B,CAkC/B;;AACA,QAAIG,aAAa,GAAGlB,YAAY,CAC9B,EAD8B,EAE9B;AACEE,MAAAA,IAAI,EAAEA,IADR;AAEEC,MAAAA,IAAI,EAAEA,IAFR;AAGEgB,MAAAA,iBAAiB,EAAET,KAHrB;AAIEU,MAAAA,aAAa,EAAE3B,MAJjB;AAKEsB,MAAAA,SAAS,EAAEA,SALb;AAMEM,MAAAA,SAAS,EAAE,OAAOjB,OAAO,CAACiB,SAAf,KAA6B,SAA7B,GAAyCjB,OAAO,CAACiB,SAAjD,GAA6D,IAN1E;AAOEC,MAAAA,IAAI,EAAE,OAAOlB,OAAO,CAACmB,QAAf,KAA4B,QAA5B,GAAuCnB,OAAO,CAACmB,QAA/C,GAA0D,CAPlE;AAQEC,MAAAA,eAAe,EACb,OAAOpB,OAAO,CAACoB,eAAf,KAAmC,SAAnC,GAA+CpB,OAAO,CAACoB,eAAvD,GAAyE;AAT7E,KAF8B,CAAhC,CAnC+B,CAkD/B;;AACAN,IAAAA,aAAa,GAAGpB,gBAAgB,CAACoB,aAAD,EAAgBd,OAAhB,CAAhC,CAnD+B,CAqD/B;;AACA,QAAIqB,aAAa,GACfrB,OAAO,CAACqB,aAAR,IAAyBC,MAAM,CAACC,IAAP,CAAYvB,OAAO,CAACqB,aAApB,EAAmCG,MAAnC,GAA4C,CAArE,GACIxB,OAAO,CAACqB,aADZ,GAEIrB,OAHN,CAtD+B,CA2D/B;;AACAc,IAAAA,aAAa,GAAGpB,gBAAgB,CAACoB,aAAD,EAAgBO,aAAhB,CAAhC,CA5D+B,CA8D/B;;AACA,UAAKI,CAAL,GAAS;AACP;AACAC,MAAAA,YAAY,EAAE,IAAIxC,OAAJ,CAAY4B,aAAZ,CAFP;AAGP;AACAa,MAAAA,aAAa,EAAE,IAJR;AAKP;AACAb,MAAAA,aAAa,EAAEA,aANR;AAOP;AACAH,MAAAA,SAAS,EAAEG,aAAa,CAACH,SARlB;AASP;AACAM,MAAAA,SAAS,EAAEH,aAAa,CAACG,SAVlB;AAWP;AACAE,MAAAA,QAAQ,EAAEL,aAAa,CAACI,IAZjB;AAaP;AACAf,MAAAA,YAAY,EAAEA,YAdP;AAeP;AACAG,MAAAA,KAAK,EAAEA,KAhBA;AAiBP;AACAR,MAAAA,IAAI,EAAEA,IAlBC;AAmBP;AACAC,MAAAA,IAAI,EAAEA,IApBC;AAqBP;AACAC,MAAAA,OAAO,EAAEA,OAtBF;AAuBP;AACA4B,MAAAA,WAAW,EAAE,IAxBN;AAyBP;AACAC,MAAAA,QAAQ,EAAE,IAAIC,GAAJ,EA1BH;AA2BP;AACA5B,MAAAA,cAAc,EAAEA,cAAc,IAAI6B;AA5B3B,KAAT;AA/D+B;AA6FhC,G,CAED;;;;;4BACQC,Q,EAAUC,Q,EAAU;AAC1B,UAAIhC,IAAI,GAAG,IAAX;AACA,UAAI,eAAe,OAAO+B,QAA1B,EAAqCC,QAAQ,GAAGD,QAAZ,EAAwBA,QAAQ,GAAG,EAAnC;AACpC,UAAIA,QAAQ,IAAI,IAAhB,EAAsBA,QAAQ,GAAG,KAAKP,CAAL,CAAOX,aAAlB;AACtB,UAAI,EAAE,eAAe,OAAOmB,QAAxB,CAAJ,EAAuCA,QAAQ,GAAG,IAAX;AACvCD,MAAAA,QAAQ,GAAGV,MAAM,CAACY,MAAP,CAAc,EAAd,EAAkB,KAAKT,CAAL,CAAOX,aAAzB,EAAwCkB,QAAxC,CAAX;AACA/B,MAAAA,IAAI,CAACwB,CAAL,CAAOzB,OAAP,GAAiBgC,QAAjB,CAN0B,CAQ1B;;AACA/B,MAAAA,IAAI,CAACwB,CAAL,CAAOtB,YAAP,CAAoBE,gBAApB,GACE,OAAO2B,QAAQ,CAAC3B,gBAAhB,KAAqC,QAArC,GAAgD2B,QAAQ,CAAC3B,gBAAzD,GAA4E,CAAC,CAD/E,CAT0B,CAY1B;;AACA,UAAI8B,mBAAmB,GAAG,SAAtBA,mBAAsB,GAAW;AACnC,eAAO,UAASC,GAAT,EAAc;AACnB;AACA,cAAIC,MAAM,GAAG,CAAC,SAAD,EAAY,OAAZ,EAAqB,OAArB,CAAb;AACAA,UAAAA,MAAM,CAACC,OAAP,CAAe,UAASC,CAAT,EAAY;AACzBtC,YAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoBc,cAApB,CAAmCD,CAAnC,EAAsCE,eAAe,CAACF,CAAD,CAArD;AACD,WAFD;AAIAtC,UAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoBc,cAApB,CAAmC,SAAnC,EAA8CL,mBAA9C,EAPmB,CASnB;;AACA,cAAI;AACFF,YAAAA,QAAQ,CAACG,GAAD,CAAR;AACD,WAFD,CAEE,OAAOA,GAAP,EAAY;AACZM,YAAAA,OAAO,CAACC,QAAR,CAAiB,YAAW;AAC1B,oBAAMP,GAAN;AACD,aAFD;AAGD;AACF,SAjBD;AAkBD,OAnBD,CAb0B,CAkC1B;;;AACA,UAAIQ,YAAY,GAAG,SAAfA,YAAe,CAASC,KAAT,EAAgB;AACjC,eAAO,UAAST,GAAT,EAAc;AACnB,cAAIS,KAAK,KAAK,OAAd,EAAuB;AACrB5C,YAAAA,IAAI,CAAC6C,IAAL,CAAUD,KAAV,EAAiBT,GAAjB;AACD;AACF,SAJD;AAKD,OAND,CAnC0B,CA2C1B;;;AACA,UAAIW,gBAAgB,GAAG,SAAnBA,gBAAmB,GAAW;AAChC9C,QAAAA,IAAI,CAAC6C,IAAL,CAAU,WAAV,EAAuB7C,IAAvB;AACAA,QAAAA,IAAI,CAACwB,CAAL,CAAOnB,KAAP,CAAa0C,OAAb;AACD,OAHD,CA5C0B,CAiD1B;;;AACA,UAAIC,sBAAsB,GAAG,SAAzBA,sBAAyB,CAASb,GAAT,EAAc;AACzCnC,QAAAA,IAAI,CAAC6C,IAAL,CAAU,iBAAV,EAA6BV,GAA7B;AACAnC,QAAAA,IAAI,CAACwB,CAAL,CAAOnB,KAAP,CAAa4C,KAAb,CAAmBd,GAAnB;AACD,OAHD,CAlD0B,CAuD1B;;;AACA,UAAIe,cAAc,GAAG,SAAjBA,cAAiB,GAAW;AAC9BlD,QAAAA,IAAI,CAACwB,CAAL,CAAOnB,KAAP,CAAa4C,KAAb;AACD,OAFD,CAxD0B,CA4D1B;;;AACA,UAAIE,KAAK,GAAG,SAARA,KAAQ,CAASP,KAAT,EAAgB;AAC1B,eAAO,UAASQ,CAAT,EAAYC,MAAZ,EAAoB;AACzBrD,UAAAA,IAAI,CAAC6C,IAAL,CAAUD,KAAV,EAAiBQ,CAAjB,EAAoBC,MAApB;AACD,SAFD;AAGD,OAJD,CA7D0B,CAmE1B;;;AACA,UAAIC,cAAc,GAAG,SAAjBA,cAAiB,GAAW;AAC9B;AACA,SAAC,SAAD,EAAY,OAAZ,EAAqB,OAArB,EAA8B,SAA9B,EAAyCjB,OAAzC,CAAiD,UAASC,CAAT,EAAY;AAC3DtC,UAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoB8B,kBAApB,CAAuCjB,CAAvC;AACD,SAFD,EAF8B,CAM9B;;AACAtC,QAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoB+B,EAApB,CAAuB,SAAvB,EAAkCb,YAAY,CAAC,SAAD,CAA9C;AACA3C,QAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoBgC,IAApB,CAAyB,OAAzB,EAAkCd,YAAY,CAAC,OAAD,CAA9C;AACA3C,QAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoB+B,EAApB,CAAuB,OAAvB,EAAgCb,YAAY,CAAC,OAAD,CAA5C,EAT8B,CAU9B;;AACA3C,QAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoB+B,EAApB,CAAuB,SAAvB,EAAkCN,cAAlC,EAX8B,CAa9B;;AACAlD,QAAAA,IAAI,CAAC6C,IAAL,CAAU,MAAV,EAAkB,IAAlB,EAAwB7C,IAAxB,EAd8B,CAgB9B;;AACA,YAAI;AACFgC,UAAAA,QAAQ,CAAC,IAAD,EAAOhC,IAAP,CAAR;AACD,SAFD,CAEE,OAAOmC,GAAP,EAAY;AACZM,UAAAA,OAAO,CAACC,QAAR,CAAiB,YAAW;AAC1B,kBAAMP,GAAN;AACD,WAFD;AAGD;AACF,OAxBD,CApE0B,CA8F1B;;;AACA,UAAIK,eAAe,GAAG;AACpBkB,QAAAA,OAAO,EAAExB,mBAAmB,CAAC,SAAD,CADR;AAEpByB,QAAAA,KAAK,EAAEzB,mBAAmB,CAAC,OAAD,CAFN;AAGpB0B,QAAAA,KAAK,EAAE1B,mBAAmB,CAAC,OAAD;AAHN,OAAtB,CA/F0B,CAqG1B;;AACA,OACE,SADF,EAEE,OAFF,EAGE,OAHF,EAIE,eAJF,EAKE,0BALF,EAME,wBANF,EAOE,0BAPF,EAQE,uBARF,EASE,cATF,EAUE,iBAVF,EAWE,gBAXF,EAYE,4BAZF,EAaE,gBAbF,EAcE,kBAdF,EAeE,eAfF,EAgBEG,OAhBF,CAgBU,UAASC,CAAT,EAAY;AACpBtC,QAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoB8B,kBAApB,CAAuCjB,CAAvC;AACD,OAlBD,EAtG0B,CA0H1B;;AACAtC,MAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoBgC,IAApB,CAAyB,SAAzB,EAAoCjB,eAAe,CAACkB,OAApD;AACA1D,MAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoBgC,IAApB,CAAyB,OAAzB,EAAkCjB,eAAe,CAACmB,KAAlD;AACA3D,MAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoBgC,IAApB,CAAyB,OAAzB,EAAkCjB,eAAe,CAACoB,KAAlD;AACA5D,MAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoBgC,IAApB,CAAyB,SAAzB,EAAoCH,cAApC,EA9H0B,CA+H1B;;AACAtD,MAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoB+B,EAApB,CAAuB,WAAvB,EAAoCV,gBAApC;AACA9C,MAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoB+B,EAApB,CAAuB,iBAAvB,EAA0CR,sBAA1C,EAjI0B,CAmI1B;;AACAhD,MAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoB+B,EAApB,CAAuB,0BAAvB,EAAmDL,KAAK,CAAC,0BAAD,CAAxD;AACAnD,MAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoB+B,EAApB,CAAuB,wBAAvB,EAAiDL,KAAK,CAAC,wBAAD,CAAtD;AACAnD,MAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoB+B,EAApB,CAAuB,0BAAvB,EAAmDL,KAAK,CAAC,0BAAD,CAAxD;AACAnD,MAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoB+B,EAApB,CAAuB,uBAAvB,EAAgDL,KAAK,CAAC,uBAAD,CAArD;AACAnD,MAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoB+B,EAApB,CAAuB,eAAvB,EAAwCL,KAAK,CAAC,eAAD,CAA7C;AACAnD,MAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoB+B,EAApB,CAAuB,cAAvB,EAAuCL,KAAK,CAAC,cAAD,CAA5C;AACAnD,MAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoB+B,EAApB,CAAuB,iBAAvB,EAA0CL,KAAK,CAAC,iBAAD,CAA/C;AACAnD,MAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoB+B,EAApB,CAAuB,gBAAvB,EAAyCL,KAAK,CAAC,gBAAD,CAA9C;AACAnD,MAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoB+B,EAApB,CAAuB,4BAAvB,EAAqDL,KAAK,CAAC,4BAAD,CAA1D;AACAnD,MAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoB+B,EAApB,CAAuB,gBAAvB,EAAyCL,KAAK,CAAC,gBAAD,CAA9C;AACAnD,MAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoB+B,EAApB,CAAuB,kBAAvB,EAA2CL,KAAK,CAAC,kBAAD,CAAhD;AACAnD,MAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoB+B,EAApB,CAAuB,eAAvB,EAAwCL,KAAK,CAAC,eAAD,CAA7C;AACAnD,MAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoB+B,EAApB,CAAuB,kBAAvB,EAA2CL,KAAK,CAAC,kBAAD,CAAhD;AACAnD,MAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoB+B,EAApB,CAAuB,YAAvB,EAAqCL,KAAK,CAAC,YAAD,CAA1C,EAjJ0B,CAmJ1B;;AACAnD,MAAAA,IAAI,CAACwB,CAAL,CAAOC,YAAP,CAAoBoC,OAApB,CAA4B9B,QAA5B;AACD;;;;EAtPkB1C,Y;;AAyPrBgC,MAAM,CAACyC,cAAP,CAAsB3E,MAAM,CAAC4E,SAA7B,EAAwC,UAAxC,EAAoD;AAClDC,EAAAA,UAAU,EAAE,IADsC;AAElDC,EAAAA,GAAG,EAAE,eAAW;AACd,WAAO,KAAKzC,CAAL,CAAOC,YAAP,CAAoByC,WAApB,GAAkC3C,MAAzC;AACD;AAJiD,CAApD;AAOAF,MAAM,CAACyC,cAAP,CAAsB3E,MAAM,CAAC4E,SAA7B,EAAwC,eAAxC,EAAyD;AACvDC,EAAAA,UAAU,EAAE,IAD2C;AAEvDC,EAAAA,GAAG,EAAE,eAAW;AACd,WAAO,KAAKzC,CAAL,CAAOd,SAAd;AACD;AAJsD,CAAzD;AAOAW,MAAM,CAACyC,cAAP,CAAsB3E,MAAM,CAAC4E,SAA7B,EAAwC,MAAxC,EAAgD;AAC9CC,EAAAA,UAAU,EAAE,IADkC;AAE9CC,EAAAA,GAAG,EAAE,eAAW;AACd,WAAO,KAAKzC,CAAL,CAAO3B,IAAd;AACD;AAJ6C,CAAhD;AAOAwB,MAAM,CAACyC,cAAP,CAAsB3E,MAAM,CAAC4E,SAA7B,EAAwC,MAAxC,EAAgD;AAC9CC,EAAAA,UAAU,EAAE,IADkC;AAE9CC,EAAAA,GAAG,EAAE,eAAW;AACd,WAAO,KAAKzC,CAAL,CAAO1B,IAAd;AACD;AAJ6C,CAAhD;AAOA;;;;;;;AAOA;;;;;;;AAOA;;;;;;;AAOA;;;;;;;AAOA;;;;;;;AAOA;;;;;;;AAOA;;;;;;;AAOA;;;;;;;AAOA;;;;;;;AAOAqE,MAAM,CAACC,OAAP,GAAiBjF,MAAjB","sourcesContent":["'use strict';\n\nconst CServer = require('../core').Server;\nconst Cursor = require('../cursor');\nconst TopologyBase = require('./topology_base').TopologyBase;\nconst Store = require('./topology_base').Store;\nconst MongoError = require('../core').MongoError;\nconst MAX_JS_INT = require('../utils').MAX_JS_INT;\nconst translateOptions = require('../utils').translateOptions;\nconst filterOptions = require('../utils').filterOptions;\nconst mergeOptions = require('../utils').mergeOptions;\n\n/**\n * @fileOverview The **Server** class is a class that represents a single server topology and is\n * used to construct connections.\n *\n * **Server Should not be used, use MongoClient.connect**\n */\n\n// Allowed parameters\nvar legalOptionNames = [\n  'ha',\n  'haInterval',\n  'acceptableLatencyMS',\n  'poolSize',\n  'ssl',\n  'checkServerIdentity',\n  'sslValidate',\n  'sslCA',\n  'sslCRL',\n  'sslCert',\n  'ciphers',\n  'ecdhCurve',\n  'sslKey',\n  'sslPass',\n  'socketOptions',\n  'bufferMaxEntries',\n  'store',\n  'auto_reconnect',\n  'autoReconnect',\n  'emitError',\n  'keepAlive',\n  'keepAliveInitialDelay',\n  'noDelay',\n  'connectTimeoutMS',\n  'socketTimeoutMS',\n  'family',\n  'loggerLevel',\n  'logger',\n  'reconnectTries',\n  'reconnectInterval',\n  'monitoring',\n  'appname',\n  'domainsEnabled',\n  'servername',\n  'promoteLongs',\n  'promoteValues',\n  'promoteBuffers',\n  'compression',\n  'promiseLibrary',\n  'monitorCommands'\n];\n\n/**\n * Creates a new Server instance\n * @class\n * @deprecated\n * @param {string} host The host for the server, can be either an IP4, IP6 or domain socket style host.\n * @param {number} [port] The server port if IP4.\n * @param {object} [options] Optional settings.\n * @param {number} [options.poolSize=5] Number of connections in the connection pool for each server instance, set to 5 as default for legacy reasons.\n * @param {boolean} [options.ssl=false] Use ssl connection (needs to have a mongod server with ssl support)\n * @param {boolean} [options.sslValidate=false] Validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {array} [options.sslCA] Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {array} [options.sslCRL] Array of revocation certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {(Buffer|string)} [options.sslCert] String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {string} [options.ciphers] Passed directly through to tls.createSecureContext. See https://nodejs.org/dist/latest-v9.x/docs/api/tls.html#tls_tls_createsecurecontext_options for more info.\n * @param {string} [options.ecdhCurve] Passed directly through to tls.createSecureContext. See https://nodejs.org/dist/latest-v9.x/docs/api/tls.html#tls_tls_createsecurecontext_options for more info.\n * @param {(Buffer|string)} [options.sslKey] String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {(Buffer|string)} [options.sslPass] String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {string} [options.servername] String containing the server name requested via TLS SNI.\n * @param {object} [options.socketOptions] Socket options\n * @param {boolean} [options.socketOptions.autoReconnect=true] Reconnect on error.\n * @param {boolean} [options.socketOptions.noDelay=true] TCP Socket NoDelay option.\n * @param {boolean} [options.socketOptions.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.socketOptions.keepAliveInitialDelay=30000] The number of milliseconds to wait before initiating keepAlive on the TCP socket\n * @param {number} [options.socketOptions.connectTimeoutMS=10000] How long to wait for a connection to be established before timing out\n * @param {number} [options.socketOptions.socketTimeoutMS=360000] How long a send or receive on a socket can take before timing out\n * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times\n * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries\n * @param {boolean} [options.monitoring=true] Triggers the server instance to call ismaster\n * @param {number} [options.haInterval=10000] The interval of calling ismaster when monitoring is enabled.\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\n * @param {boolean} [options.monitorCommands=false] Enable command monitoring for this topology\n * @fires Server#connect\n * @fires Server#close\n * @fires Server#error\n * @fires Server#timeout\n * @fires Server#parseError\n * @fires Server#reconnect\n * @fires Server#commandStarted\n * @fires Server#commandSucceeded\n * @fires Server#commandFailed\n * @property {string} parserType the parser type used (c++ or js).\n * @return {Server} a Server instance.\n */\nclass Server extends TopologyBase {\n  constructor(host, port, options) {\n    super();\n    var self = this;\n\n    // Filter the options\n    options = filterOptions(options, legalOptionNames);\n\n    // Promise library\n    const promiseLibrary = options.promiseLibrary;\n\n    // Stored options\n    var storeOptions = {\n      force: false,\n      bufferMaxEntries:\n        typeof options.bufferMaxEntries === 'number' ? options.bufferMaxEntries : MAX_JS_INT\n    };\n\n    // Shared global store\n    var store = options.store || new Store(self, storeOptions);\n\n    // Detect if we have a socket connection\n    if (host.indexOf('/') !== -1) {\n      if (port != null && typeof port === 'object') {\n        options = port;\n        port = null;\n      }\n    } else if (port == null) {\n      throw MongoError.create({ message: 'port must be specified', driver: true });\n    }\n\n    // Get the reconnect option\n    var reconnect = typeof options.auto_reconnect === 'boolean' ? options.auto_reconnect : true;\n    reconnect = typeof options.autoReconnect === 'boolean' ? options.autoReconnect : reconnect;\n\n    // Clone options\n    var clonedOptions = mergeOptions(\n      {},\n      {\n        host: host,\n        port: port,\n        disconnectHandler: store,\n        cursorFactory: Cursor,\n        reconnect: reconnect,\n        emitError: typeof options.emitError === 'boolean' ? options.emitError : true,\n        size: typeof options.poolSize === 'number' ? options.poolSize : 5,\n        monitorCommands:\n          typeof options.monitorCommands === 'boolean' ? options.monitorCommands : false\n      }\n    );\n\n    // Translate any SSL options and other connectivity options\n    clonedOptions = translateOptions(clonedOptions, options);\n\n    // Socket options\n    var socketOptions =\n      options.socketOptions && Object.keys(options.socketOptions).length > 0\n        ? options.socketOptions\n        : options;\n\n    // Translate all the options to the core types\n    clonedOptions = translateOptions(clonedOptions, socketOptions);\n\n    // Define the internal properties\n    this.s = {\n      // Create an instance of a server instance from core module\n      coreTopology: new CServer(clonedOptions),\n      // Server capabilities\n      sCapabilities: null,\n      // Cloned options\n      clonedOptions: clonedOptions,\n      // Reconnect\n      reconnect: clonedOptions.reconnect,\n      // Emit error\n      emitError: clonedOptions.emitError,\n      // Pool size\n      poolSize: clonedOptions.size,\n      // Store Options\n      storeOptions: storeOptions,\n      // Store\n      store: store,\n      // Host\n      host: host,\n      // Port\n      port: port,\n      // Options\n      options: options,\n      // Server Session Pool\n      sessionPool: null,\n      // Active client sessions\n      sessions: new Set(),\n      // Promise library\n      promiseLibrary: promiseLibrary || Promise\n    };\n  }\n\n  // Connect\n  connect(_options, callback) {\n    var self = this;\n    if ('function' === typeof _options) (callback = _options), (_options = {});\n    if (_options == null) _options = this.s.clonedOptions;\n    if (!('function' === typeof callback)) callback = null;\n    _options = Object.assign({}, this.s.clonedOptions, _options);\n    self.s.options = _options;\n\n    // Update bufferMaxEntries\n    self.s.storeOptions.bufferMaxEntries =\n      typeof _options.bufferMaxEntries === 'number' ? _options.bufferMaxEntries : -1;\n\n    // Error handler\n    var connectErrorHandler = function() {\n      return function(err) {\n        // Remove all event handlers\n        var events = ['timeout', 'error', 'close'];\n        events.forEach(function(e) {\n          self.s.coreTopology.removeListener(e, connectHandlers[e]);\n        });\n\n        self.s.coreTopology.removeListener('connect', connectErrorHandler);\n\n        // Try to callback\n        try {\n          callback(err);\n        } catch (err) {\n          process.nextTick(function() {\n            throw err;\n          });\n        }\n      };\n    };\n\n    // Actual handler\n    var errorHandler = function(event) {\n      return function(err) {\n        if (event !== 'error') {\n          self.emit(event, err);\n        }\n      };\n    };\n\n    // Error handler\n    var reconnectHandler = function() {\n      self.emit('reconnect', self);\n      self.s.store.execute();\n    };\n\n    // Reconnect failed\n    var reconnectFailedHandler = function(err) {\n      self.emit('reconnectFailed', err);\n      self.s.store.flush(err);\n    };\n\n    // Destroy called on topology, perform cleanup\n    var destroyHandler = function() {\n      self.s.store.flush();\n    };\n\n    // relay the event\n    var relay = function(event) {\n      return function(t, server) {\n        self.emit(event, t, server);\n      };\n    };\n\n    // Connect handler\n    var connectHandler = function() {\n      // Clear out all the current handlers left over\n      ['timeout', 'error', 'close', 'destroy'].forEach(function(e) {\n        self.s.coreTopology.removeAllListeners(e);\n      });\n\n      // Set up listeners\n      self.s.coreTopology.on('timeout', errorHandler('timeout'));\n      self.s.coreTopology.once('error', errorHandler('error'));\n      self.s.coreTopology.on('close', errorHandler('close'));\n      // Only called on destroy\n      self.s.coreTopology.on('destroy', destroyHandler);\n\n      // Emit open event\n      self.emit('open', null, self);\n\n      // Return correctly\n      try {\n        callback(null, self);\n      } catch (err) {\n        process.nextTick(function() {\n          throw err;\n        });\n      }\n    };\n\n    // Set up listeners\n    var connectHandlers = {\n      timeout: connectErrorHandler('timeout'),\n      error: connectErrorHandler('error'),\n      close: connectErrorHandler('close')\n    };\n\n    // Clear out all the current handlers left over\n    [\n      'timeout',\n      'error',\n      'close',\n      'serverOpening',\n      'serverDescriptionChanged',\n      'serverHeartbeatStarted',\n      'serverHeartbeatSucceeded',\n      'serverHeartbeatFailed',\n      'serverClosed',\n      'topologyOpening',\n      'topologyClosed',\n      'topologyDescriptionChanged',\n      'commandStarted',\n      'commandSucceeded',\n      'commandFailed'\n    ].forEach(function(e) {\n      self.s.coreTopology.removeAllListeners(e);\n    });\n\n    // Add the event handlers\n    self.s.coreTopology.once('timeout', connectHandlers.timeout);\n    self.s.coreTopology.once('error', connectHandlers.error);\n    self.s.coreTopology.once('close', connectHandlers.close);\n    self.s.coreTopology.once('connect', connectHandler);\n    // Reconnect server\n    self.s.coreTopology.on('reconnect', reconnectHandler);\n    self.s.coreTopology.on('reconnectFailed', reconnectFailedHandler);\n\n    // Set up SDAM listeners\n    self.s.coreTopology.on('serverDescriptionChanged', relay('serverDescriptionChanged'));\n    self.s.coreTopology.on('serverHeartbeatStarted', relay('serverHeartbeatStarted'));\n    self.s.coreTopology.on('serverHeartbeatSucceeded', relay('serverHeartbeatSucceeded'));\n    self.s.coreTopology.on('serverHeartbeatFailed', relay('serverHeartbeatFailed'));\n    self.s.coreTopology.on('serverOpening', relay('serverOpening'));\n    self.s.coreTopology.on('serverClosed', relay('serverClosed'));\n    self.s.coreTopology.on('topologyOpening', relay('topologyOpening'));\n    self.s.coreTopology.on('topologyClosed', relay('topologyClosed'));\n    self.s.coreTopology.on('topologyDescriptionChanged', relay('topologyDescriptionChanged'));\n    self.s.coreTopology.on('commandStarted', relay('commandStarted'));\n    self.s.coreTopology.on('commandSucceeded', relay('commandSucceeded'));\n    self.s.coreTopology.on('commandFailed', relay('commandFailed'));\n    self.s.coreTopology.on('attemptReconnect', relay('attemptReconnect'));\n    self.s.coreTopology.on('monitoring', relay('monitoring'));\n\n    // Start connection\n    self.s.coreTopology.connect(_options);\n  }\n}\n\nObject.defineProperty(Server.prototype, 'poolSize', {\n  enumerable: true,\n  get: function() {\n    return this.s.coreTopology.connections().length;\n  }\n});\n\nObject.defineProperty(Server.prototype, 'autoReconnect', {\n  enumerable: true,\n  get: function() {\n    return this.s.reconnect;\n  }\n});\n\nObject.defineProperty(Server.prototype, 'host', {\n  enumerable: true,\n  get: function() {\n    return this.s.host;\n  }\n});\n\nObject.defineProperty(Server.prototype, 'port', {\n  enumerable: true,\n  get: function() {\n    return this.s.port;\n  }\n});\n\n/**\n * Server connect event\n *\n * @event Server#connect\n * @type {object}\n */\n\n/**\n * Server close event\n *\n * @event Server#close\n * @type {object}\n */\n\n/**\n * Server reconnect event\n *\n * @event Server#reconnect\n * @type {object}\n */\n\n/**\n * Server error event\n *\n * @event Server#error\n * @type {MongoError}\n */\n\n/**\n * Server timeout event\n *\n * @event Server#timeout\n * @type {object}\n */\n\n/**\n * Server parseError event\n *\n * @event Server#parseError\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command was started, if command monitoring is enabled\n *\n * @event Server#commandStarted\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command succeeded, if command monitoring is enabled\n *\n * @event Server#commandSucceeded\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command failed, if command monitoring is enabled\n *\n * @event Server#commandFailed\n * @type {object}\n */\n\nmodule.exports = Server;\n"]},"metadata":{},"sourceType":"script"}