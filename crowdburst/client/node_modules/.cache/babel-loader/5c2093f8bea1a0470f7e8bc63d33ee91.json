{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar parseServerType = require('../core/sdam/server_description').parseServerType;\n\nvar RESPONSE_FIELDS = ['minWireVersion', 'maxWireVersion', 'maxBsonObjectSize', 'maxMessageSizeBytes', 'maxWriteBatchSize', '__nodejs_mock_server__'];\n\nvar StreamDescription = /*#__PURE__*/function () {\n  function StreamDescription(address, options) {\n    _classCallCheck(this, StreamDescription);\n\n    this.address = address;\n    this.type = parseServerType(null);\n    this.minWireVersion = undefined;\n    this.maxWireVersion = undefined;\n    this.maxBsonObjectSize = 16777216;\n    this.maxMessageSizeBytes = 48000000;\n    this.maxWriteBatchSize = 100000;\n    this.compressors = options && options.compression && Array.isArray(options.compression.compressors) ? options.compression.compressors : [];\n  }\n\n  _createClass(StreamDescription, [{\n    key: \"receiveResponse\",\n    value: function receiveResponse(response) {\n      var _this = this;\n\n      this.type = parseServerType(response);\n      RESPONSE_FIELDS.forEach(function (field) {\n        if (typeof response[field] !== 'undefined') {\n          _this[field] = response[field];\n        }\n      });\n\n      if (response.compression) {\n        this.compressor = this.compressors.filter(function (c) {\n          return response.compression.indexOf(c) !== -1;\n        })[0];\n      }\n    }\n  }]);\n\n  return StreamDescription;\n}();\n\nmodule.exports = {\n  StreamDescription: StreamDescription\n};","map":{"version":3,"sources":["/Users/S/Desktop/nodeprotake2/node_modules/mongodb/lib/cmap/stream_description.js"],"names":["parseServerType","require","RESPONSE_FIELDS","StreamDescription","address","options","type","minWireVersion","undefined","maxWireVersion","maxBsonObjectSize","maxMessageSizeBytes","maxWriteBatchSize","compressors","compression","Array","isArray","response","forEach","field","compressor","filter","c","indexOf","module","exports"],"mappings":"AAAA;;;;;;AACA,IAAMA,eAAe,GAAGC,OAAO,CAAC,iCAAD,CAAP,CAA2CD,eAAnE;;AAEA,IAAME,eAAe,GAAG,CACtB,gBADsB,EAEtB,gBAFsB,EAGtB,mBAHsB,EAItB,qBAJsB,EAKtB,mBALsB,EAMtB,wBANsB,CAAxB;;IASMC,iB;AACJ,6BAAYC,OAAZ,EAAqBC,OAArB,EAA8B;AAAA;;AAC5B,SAAKD,OAAL,GAAeA,OAAf;AACA,SAAKE,IAAL,GAAYN,eAAe,CAAC,IAAD,CAA3B;AACA,SAAKO,cAAL,GAAsBC,SAAtB;AACA,SAAKC,cAAL,GAAsBD,SAAtB;AACA,SAAKE,iBAAL,GAAyB,QAAzB;AACA,SAAKC,mBAAL,GAA2B,QAA3B;AACA,SAAKC,iBAAL,GAAyB,MAAzB;AACA,SAAKC,WAAL,GACER,OAAO,IAAIA,OAAO,CAACS,WAAnB,IAAkCC,KAAK,CAACC,OAAN,CAAcX,OAAO,CAACS,WAAR,CAAoBD,WAAlC,CAAlC,GACIR,OAAO,CAACS,WAAR,CAAoBD,WADxB,GAEI,EAHN;AAID;;;;oCAEeI,Q,EAAU;AAAA;;AACxB,WAAKX,IAAL,GAAYN,eAAe,CAACiB,QAAD,CAA3B;AAEAf,MAAAA,eAAe,CAACgB,OAAhB,CAAwB,UAAAC,KAAK,EAAI;AAC/B,YAAI,OAAOF,QAAQ,CAACE,KAAD,CAAf,KAA2B,WAA/B,EAA4C;AAC1C,UAAA,KAAI,CAACA,KAAD,CAAJ,GAAcF,QAAQ,CAACE,KAAD,CAAtB;AACD;AACF,OAJD;;AAMA,UAAIF,QAAQ,CAACH,WAAb,EAA0B;AACxB,aAAKM,UAAL,GAAkB,KAAKP,WAAL,CAAiBQ,MAAjB,CAAwB,UAAAC,CAAC;AAAA,iBAAIL,QAAQ,CAACH,WAAT,CAAqBS,OAArB,CAA6BD,CAA7B,MAAoC,CAAC,CAAzC;AAAA,SAAzB,EAAqE,CAArE,CAAlB;AACD;AACF;;;;;;AAGHE,MAAM,CAACC,OAAP,GAAiB;AACftB,EAAAA,iBAAiB,EAAjBA;AADe,CAAjB","sourcesContent":["'use strict';\nconst parseServerType = require('../core/sdam/server_description').parseServerType;\n\nconst RESPONSE_FIELDS = [\n  'minWireVersion',\n  'maxWireVersion',\n  'maxBsonObjectSize',\n  'maxMessageSizeBytes',\n  'maxWriteBatchSize',\n  '__nodejs_mock_server__'\n];\n\nclass StreamDescription {\n  constructor(address, options) {\n    this.address = address;\n    this.type = parseServerType(null);\n    this.minWireVersion = undefined;\n    this.maxWireVersion = undefined;\n    this.maxBsonObjectSize = 16777216;\n    this.maxMessageSizeBytes = 48000000;\n    this.maxWriteBatchSize = 100000;\n    this.compressors =\n      options && options.compression && Array.isArray(options.compression.compressors)\n        ? options.compression.compressors\n        : [];\n  }\n\n  receiveResponse(response) {\n    this.type = parseServerType(response);\n\n    RESPONSE_FIELDS.forEach(field => {\n      if (typeof response[field] !== 'undefined') {\n        this[field] = response[field];\n      }\n    });\n\n    if (response.compression) {\n      this.compressor = this.compressors.filter(c => response.compression.indexOf(c) !== -1)[0];\n    }\n  }\n}\n\nmodule.exports = {\n  StreamDescription\n};\n"]},"metadata":{},"sourceType":"script"}