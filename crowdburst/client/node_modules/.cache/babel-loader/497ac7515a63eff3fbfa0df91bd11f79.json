{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Logger = require('./connection/logger');\n\nvar retrieveBSON = require('./connection/utils').retrieveBSON;\n\nvar MongoError = require('./error').MongoError;\n\nvar MongoNetworkError = require('./error').MongoNetworkError;\n\nvar collationNotSupported = require('./utils').collationNotSupported;\n\nvar ReadPreference = require('./topologies/read_preference');\n\nvar isUnifiedTopology = require('./utils').isUnifiedTopology;\n\nvar executeOperation = require('../operations/execute_operation');\n\nvar Readable = require('stream').Readable;\n\nvar SUPPORTS = require('../utils').SUPPORTS;\n\nvar MongoDBNamespace = require('../utils').MongoDBNamespace;\n\nvar OperationBase = require('../operations/operation').OperationBase;\n\nvar BSON = retrieveBSON();\nvar Long = BSON.Long; // Possible states for a cursor\n\nvar CursorState = {\n  INIT: 0,\n  OPEN: 1,\n  CLOSED: 2,\n  GET_MORE: 3\n}; //\n// Handle callback (including any exceptions thrown)\n\nfunction handleCallback(callback, err, result) {\n  try {\n    callback(err, result);\n  } catch (err) {\n    process.nextTick(function () {\n      throw err;\n    });\n  }\n}\n/**\n * This is a cursor results callback\n *\n * @callback resultCallback\n * @param {error} error An error object. Set to null if no error present\n * @param {object} document\n */\n\n/**\n * @fileOverview The **Cursor** class is an internal class that embodies a cursor on MongoDB\n * allowing for iteration over the results returned from the underlying query.\n *\n * **CURSORS Cannot directly be instantiated**\n */\n\n/**\n * The core cursor class. All cursors in the driver build off of this one.\n *\n * @property {number} cursorBatchSize The current cursorBatchSize for the cursor\n * @property {number} cursorLimit The current cursorLimit for the cursor\n * @property {number} cursorSkip The current cursorSkip for the cursor\n */\n\n\nvar CoreCursor = /*#__PURE__*/function (_Readable) {\n  _inherits(CoreCursor, _Readable);\n\n  var _super = _createSuper(CoreCursor);\n\n  /**\n   * Create a new core `Cursor` instance.\n   * **NOTE** Not to be instantiated directly\n   *\n   * @param {object} topology The server topology instance.\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {{object}|Long} cmd The selector (can be a command or a cursorId)\n   * @param {object} [options=null] Optional settings.\n   * @param {object} [options.batchSize=1000] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find/| find command documentation} and {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n   * @param {array} [options.documents=[]] Initial documents list for cursor\n   * @param {object} [options.transforms=null] Transform methods for the cursor results\n   * @param {function} [options.transforms.query] Transform the value returned from the initial query\n   * @param {function} [options.transforms.doc] Transform each document returned from Cursor.prototype._next\n   */\n  function CoreCursor(topology, ns, cmd, options) {\n    var _this;\n\n    _classCallCheck(this, CoreCursor);\n\n    _this = _super.call(this, {\n      objectMode: true\n    });\n    options = options || {};\n\n    if (ns instanceof OperationBase) {\n      _this.operation = ns;\n      ns = _this.operation.ns.toString();\n      options = _this.operation.options;\n      cmd = _this.operation.cmd ? _this.operation.cmd : {};\n    } // Cursor pool\n\n\n    _this.pool = null; // Cursor server\n\n    _this.server = null; // Do we have a not connected handler\n\n    _this.disconnectHandler = options.disconnectHandler; // Set local values\n\n    _this.bson = topology.s.bson;\n    _this.ns = ns;\n    _this.namespace = MongoDBNamespace.fromString(ns);\n    _this.cmd = cmd;\n    _this.options = options;\n    _this.topology = topology; // All internal state\n\n    _this.cursorState = {\n      cursorId: null,\n      cmd: cmd,\n      documents: options.documents || [],\n      cursorIndex: 0,\n      dead: false,\n      killed: false,\n      init: false,\n      notified: false,\n      limit: options.limit || cmd.limit || 0,\n      skip: options.skip || cmd.skip || 0,\n      batchSize: options.batchSize || cmd.batchSize || 1000,\n      currentLimit: 0,\n      // Result field name if not a cursor (contains the array of results)\n      transforms: options.transforms,\n      raw: options.raw || cmd && cmd.raw\n    };\n\n    if (typeof options.session === 'object') {\n      _this.cursorState.session = options.session;\n    } // Add promoteLong to cursor state\n\n\n    var topologyOptions = topology.s.options;\n\n    if (typeof topologyOptions.promoteLongs === 'boolean') {\n      _this.cursorState.promoteLongs = topologyOptions.promoteLongs;\n    } else if (typeof options.promoteLongs === 'boolean') {\n      _this.cursorState.promoteLongs = options.promoteLongs;\n    } // Add promoteValues to cursor state\n\n\n    if (typeof topologyOptions.promoteValues === 'boolean') {\n      _this.cursorState.promoteValues = topologyOptions.promoteValues;\n    } else if (typeof options.promoteValues === 'boolean') {\n      _this.cursorState.promoteValues = options.promoteValues;\n    } // Add promoteBuffers to cursor state\n\n\n    if (typeof topologyOptions.promoteBuffers === 'boolean') {\n      _this.cursorState.promoteBuffers = topologyOptions.promoteBuffers;\n    } else if (typeof options.promoteBuffers === 'boolean') {\n      _this.cursorState.promoteBuffers = options.promoteBuffers;\n    }\n\n    if (topologyOptions.reconnect) {\n      _this.cursorState.reconnect = topologyOptions.reconnect;\n    } // Logger\n\n\n    _this.logger = Logger('Cursor', topologyOptions); //\n    // Did we pass in a cursor id\n\n    if (typeof cmd === 'number') {\n      _this.cursorState.cursorId = Long.fromNumber(cmd);\n      _this.cursorState.lastCursorId = _this.cursorState.cursorId;\n    } else if (cmd instanceof Long) {\n      _this.cursorState.cursorId = cmd;\n      _this.cursorState.lastCursorId = cmd;\n    } // TODO: remove as part of NODE-2104\n\n\n    if (_this.operation) {\n      _this.operation.cursorState = _this.cursorState;\n    }\n\n    return _this;\n  }\n\n  _createClass(CoreCursor, [{\n    key: \"setCursorBatchSize\",\n    value: function setCursorBatchSize(value) {\n      this.cursorState.batchSize = value;\n    }\n  }, {\n    key: \"cursorBatchSize\",\n    value: function cursorBatchSize() {\n      return this.cursorState.batchSize;\n    }\n  }, {\n    key: \"setCursorLimit\",\n    value: function setCursorLimit(value) {\n      this.cursorState.limit = value;\n    }\n  }, {\n    key: \"cursorLimit\",\n    value: function cursorLimit() {\n      return this.cursorState.limit;\n    }\n  }, {\n    key: \"setCursorSkip\",\n    value: function setCursorSkip(value) {\n      this.cursorState.skip = value;\n    }\n  }, {\n    key: \"cursorSkip\",\n    value: function cursorSkip() {\n      return this.cursorState.skip;\n    }\n    /**\n     * Retrieve the next document from the cursor\n     * @method\n     * @param {resultCallback} callback A callback function\n     */\n\n  }, {\n    key: \"_next\",\n    value: function _next(callback) {\n      nextFunction(this, callback);\n    }\n    /**\n     * Clone the cursor\n     * @method\n     * @return {Cursor}\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return this.topology.cursor(this.ns, this.cmd, this.options);\n    }\n    /**\n     * Checks if the cursor is dead\n     * @method\n     * @return {boolean} A boolean signifying if the cursor is dead or not\n     */\n\n  }, {\n    key: \"isDead\",\n    value: function isDead() {\n      return this.cursorState.dead === true;\n    }\n    /**\n     * Checks if the cursor was killed by the application\n     * @method\n     * @return {boolean} A boolean signifying if the cursor was killed by the application\n     */\n\n  }, {\n    key: \"isKilled\",\n    value: function isKilled() {\n      return this.cursorState.killed === true;\n    }\n    /**\n     * Checks if the cursor notified it's caller about it's death\n     * @method\n     * @return {boolean} A boolean signifying if the cursor notified the callback\n     */\n\n  }, {\n    key: \"isNotified\",\n    value: function isNotified() {\n      return this.cursorState.notified === true;\n    }\n    /**\n     * Returns current buffered documents length\n     * @method\n     * @return {number} The number of items in the buffered documents\n     */\n\n  }, {\n    key: \"bufferedCount\",\n    value: function bufferedCount() {\n      return this.cursorState.documents.length - this.cursorState.cursorIndex;\n    }\n    /**\n     * Returns current buffered documents\n     * @method\n     * @return {Array} An array of buffered documents\n     */\n\n  }, {\n    key: \"readBufferedDocuments\",\n    value: function readBufferedDocuments(number) {\n      var unreadDocumentsLength = this.cursorState.documents.length - this.cursorState.cursorIndex;\n      var length = number < unreadDocumentsLength ? number : unreadDocumentsLength;\n      var elements = this.cursorState.documents.slice(this.cursorState.cursorIndex, this.cursorState.cursorIndex + length); // Transform the doc with passed in transformation method if provided\n\n      if (this.cursorState.transforms && typeof this.cursorState.transforms.doc === 'function') {\n        // Transform all the elements\n        for (var i = 0; i < elements.length; i++) {\n          elements[i] = this.cursorState.transforms.doc(elements[i]);\n        }\n      } // Ensure we do not return any more documents than the limit imposed\n      // Just return the number of elements up to the limit\n\n\n      if (this.cursorState.limit > 0 && this.cursorState.currentLimit + elements.length > this.cursorState.limit) {\n        elements = elements.slice(0, this.cursorState.limit - this.cursorState.currentLimit);\n        this.kill();\n      } // Adjust current limit\n\n\n      this.cursorState.currentLimit = this.cursorState.currentLimit + elements.length;\n      this.cursorState.cursorIndex = this.cursorState.cursorIndex + elements.length; // Return elements\n\n      return elements;\n    }\n    /**\n     * Resets local state for this cursor instance, and issues a `killCursors` command to the server\n     *\n     * @param {resultCallback} callback A callback function\n     */\n\n  }, {\n    key: \"kill\",\n    value: function kill(callback) {\n      // Set cursor to dead\n      this.cursorState.dead = true;\n      this.cursorState.killed = true; // Remove documents\n\n      this.cursorState.documents = []; // If no cursor id just return\n\n      if (this.cursorState.cursorId == null || this.cursorState.cursorId.isZero() || this.cursorState.init === false) {\n        if (callback) callback(null, null);\n        return;\n      }\n\n      this.server.killCursors(this.ns, this.cursorState, callback);\n    }\n    /**\n     * Resets the cursor\n     */\n\n  }, {\n    key: \"rewind\",\n    value: function rewind() {\n      if (this.cursorState.init) {\n        if (!this.cursorState.dead) {\n          this.kill();\n        }\n\n        this.cursorState.currentLimit = 0;\n        this.cursorState.init = false;\n        this.cursorState.dead = false;\n        this.cursorState.killed = false;\n        this.cursorState.notified = false;\n        this.cursorState.documents = [];\n        this.cursorState.cursorId = null;\n        this.cursorState.cursorIndex = 0;\n      }\n    } // Internal methods\n\n  }, {\n    key: \"_read\",\n    value: function _read() {\n      var _this2 = this;\n\n      if (this.s && this.s.state === CursorState.CLOSED || this.isDead()) {\n        return this.push(null);\n      } // Get the next item\n\n\n      this._next(function (err, result) {\n        if (err) {\n          if (_this2.listeners('error') && _this2.listeners('error').length > 0) {\n            _this2.emit('error', err);\n          }\n\n          if (!_this2.isDead()) _this2.close(); // Emit end event\n\n          _this2.emit('end');\n\n          return _this2.emit('finish');\n        } // If we provided a transformation method\n\n\n        if (_this2.cursorState.streamOptions && typeof _this2.cursorState.streamOptions.transform === 'function' && result != null) {\n          return _this2.push(_this2.cursorState.streamOptions.transform(result));\n        } // Return the result\n\n\n        _this2.push(result);\n\n        if (result === null && _this2.isDead()) {\n          _this2.once('end', function () {\n            _this2.close();\n\n            _this2.emit('finish');\n          });\n        }\n      });\n    }\n  }, {\n    key: \"_endSession\",\n    value: function _endSession(options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      var session = this.cursorState.session;\n\n      if (session && (options.force || session.owner === this)) {\n        this.cursorState.session = undefined;\n\n        if (this.operation) {\n          this.operation.clearSession();\n        }\n\n        session.endSession(callback);\n        return true;\n      }\n\n      if (callback) {\n        callback();\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_getMore\",\n    value: function _getMore(callback) {\n      var _this3 = this;\n\n      if (this.logger.isDebug()) {\n        this.logger.debug(\"schedule getMore call for query [\".concat(JSON.stringify(this.query), \"]\"));\n      } // Set the current batchSize\n\n\n      var batchSize = this.cursorState.batchSize;\n\n      if (this.cursorState.limit > 0 && this.cursorState.currentLimit + batchSize > this.cursorState.limit) {\n        batchSize = this.cursorState.limit - this.cursorState.currentLimit;\n      }\n\n      var cursorState = this.cursorState;\n      this.server.getMore(this.ns, cursorState, batchSize, this.options, function (err, result, conn) {\n        // NOTE: `getMore` modifies `cursorState`, would be very ideal not to do so in the future\n        if (err || cursorState.cursorId && cursorState.cursorId.isZero()) {\n          _this3._endSession();\n        }\n\n        callback(err, result, conn);\n      });\n    }\n  }, {\n    key: \"_initializeCursor\",\n    value: function _initializeCursor(callback) {\n      var _this4 = this;\n\n      var cursor = this; // NOTE: this goes away once cursors use `executeOperation`\n\n      if (isUnifiedTopology(cursor.topology) && cursor.topology.shouldCheckForSessionSupport()) {\n        cursor.topology.selectServer(ReadPreference.primaryPreferred, function (err) {\n          if (err) {\n            callback(err);\n            return;\n          }\n\n          _this4._initializeCursor(callback);\n        });\n        return;\n      }\n\n      function done(err, result) {\n        var cursorState = cursor.cursorState;\n\n        if (err || cursorState.cursorId && cursorState.cursorId.isZero()) {\n          cursor._endSession();\n        }\n\n        if (cursorState.documents.length === 0 && cursorState.cursorId && cursorState.cursorId.isZero() && !cursor.cmd.tailable && !cursor.cmd.awaitData) {\n          return setCursorNotified(cursor, callback);\n        }\n\n        callback(err, result);\n      }\n\n      var queryCallback = function queryCallback(err, r) {\n        if (err) {\n          return done(err);\n        }\n\n        var result = r.message;\n\n        if (result.queryFailure) {\n          return done(new MongoError(result.documents[0]), null);\n        } // Check if we have a command cursor\n\n\n        if (Array.isArray(result.documents) && result.documents.length === 1 && (!cursor.cmd.find || cursor.cmd.find && cursor.cmd.virtual === false) && (typeof result.documents[0].cursor !== 'string' || result.documents[0]['$err'] || result.documents[0]['errmsg'] || Array.isArray(result.documents[0].result))) {\n          // We have an error document, return the error\n          if (result.documents[0]['$err'] || result.documents[0]['errmsg']) {\n            return done(new MongoError(result.documents[0]), null);\n          } // We have a cursor document\n\n\n          if (result.documents[0].cursor != null && typeof result.documents[0].cursor !== 'string') {\n            var id = result.documents[0].cursor.id; // If we have a namespace change set the new namespace for getmores\n\n            if (result.documents[0].cursor.ns) {\n              cursor.ns = result.documents[0].cursor.ns;\n            } // Promote id to long if needed\n\n\n            cursor.cursorState.cursorId = typeof id === 'number' ? Long.fromNumber(id) : id;\n            cursor.cursorState.lastCursorId = cursor.cursorState.cursorId;\n            cursor.cursorState.operationTime = result.documents[0].operationTime; // If we have a firstBatch set it\n\n            if (Array.isArray(result.documents[0].cursor.firstBatch)) {\n              cursor.cursorState.documents = result.documents[0].cursor.firstBatch; //.reverse();\n            } // Return after processing command cursor\n\n\n            return done(null, result);\n          }\n\n          if (Array.isArray(result.documents[0].result)) {\n            cursor.cursorState.documents = result.documents[0].result;\n            cursor.cursorState.cursorId = Long.ZERO;\n            return done(null, result);\n          }\n        } // Otherwise fall back to regular find path\n\n\n        var cursorId = result.cursorId || 0;\n        cursor.cursorState.cursorId = cursorId instanceof Long ? cursorId : Long.fromNumber(cursorId);\n        cursor.cursorState.documents = result.documents;\n        cursor.cursorState.lastCursorId = result.cursorId; // Transform the results with passed in transformation method if provided\n\n        if (cursor.cursorState.transforms && typeof cursor.cursorState.transforms.query === 'function') {\n          cursor.cursorState.documents = cursor.cursorState.transforms.query(result);\n        }\n\n        done(null, result);\n      };\n\n      if (cursor.operation) {\n        if (cursor.logger.isDebug()) {\n          cursor.logger.debug(\"issue initial query [\".concat(JSON.stringify(cursor.cmd), \"] with flags [\").concat(JSON.stringify(cursor.query), \"]\"));\n        }\n\n        executeOperation(cursor.topology, cursor.operation, function (err, result) {\n          if (err) {\n            done(err);\n            return;\n          }\n\n          cursor.server = cursor.operation.server;\n          cursor.cursorState.init = true; // NOTE: this is a special internal method for cloning a cursor, consider removing\n\n          if (cursor.cursorState.cursorId != null) {\n            return done();\n          }\n\n          queryCallback(err, result);\n        });\n        return;\n      } // Very explicitly choose what is passed to selectServer\n\n\n      var serverSelectOptions = {};\n\n      if (cursor.cursorState.session) {\n        serverSelectOptions.session = cursor.cursorState.session;\n      }\n\n      if (cursor.operation) {\n        serverSelectOptions.readPreference = cursor.operation.readPreference;\n      } else if (cursor.options.readPreference) {\n        serverSelectOptions.readPreference = cursor.options.readPreference;\n      }\n\n      return cursor.topology.selectServer(serverSelectOptions, function (err, server) {\n        if (err) {\n          var disconnectHandler = cursor.disconnectHandler;\n\n          if (disconnectHandler != null) {\n            return disconnectHandler.addObjectAndMethod('cursor', cursor, 'next', [callback], callback);\n          }\n\n          return callback(err);\n        }\n\n        cursor.server = server;\n        cursor.cursorState.init = true;\n\n        if (collationNotSupported(cursor.server, cursor.cmd)) {\n          return callback(new MongoError(\"server \".concat(cursor.server.name, \" does not support collation\")));\n        } // NOTE: this is a special internal method for cloning a cursor, consider removing\n\n\n        if (cursor.cursorState.cursorId != null) {\n          return done();\n        }\n\n        if (cursor.logger.isDebug()) {\n          cursor.logger.debug(\"issue initial query [\".concat(JSON.stringify(cursor.cmd), \"] with flags [\").concat(JSON.stringify(cursor.query), \"]\"));\n        }\n\n        if (cursor.cmd.find != null) {\n          server.query(cursor.ns, cursor.cmd, cursor.cursorState, cursor.options, queryCallback);\n          return;\n        }\n\n        var commandOptions = Object.assign({\n          session: cursor.cursorState.session\n        }, cursor.options);\n        server.command(cursor.ns, cursor.cmd, commandOptions, queryCallback);\n      });\n    }\n  }]);\n\n  return CoreCursor;\n}(Readable);\n\nif (SUPPORTS.ASYNC_ITERATOR) {\n  CoreCursor.prototype[Symbol.asyncIterator] = require('../async/async_iterator').asyncIterator;\n}\n/**\n * Validate if the pool is dead and return error\n */\n\n\nfunction isConnectionDead(self, callback) {\n  if (self.pool && self.pool.isDestroyed()) {\n    self.cursorState.killed = true;\n    var err = new MongoNetworkError(\"connection to host \".concat(self.pool.host, \":\").concat(self.pool.port, \" was destroyed\"));\n\n    _setCursorNotifiedImpl(self, function () {\n      return callback(err);\n    });\n\n    return true;\n  }\n\n  return false;\n}\n/**\n * Validate if the cursor is dead but was not explicitly killed by user\n */\n\n\nfunction isCursorDeadButNotkilled(self, callback) {\n  // Cursor is dead but not marked killed, return null\n  if (self.cursorState.dead && !self.cursorState.killed) {\n    self.cursorState.killed = true;\n    setCursorNotified(self, callback);\n    return true;\n  }\n\n  return false;\n}\n/**\n * Validate if the cursor is dead and was killed by user\n */\n\n\nfunction isCursorDeadAndKilled(self, callback) {\n  if (self.cursorState.dead && self.cursorState.killed) {\n    handleCallback(callback, new MongoError('cursor is dead'));\n    return true;\n  }\n\n  return false;\n}\n/**\n * Validate if the cursor was killed by the user\n */\n\n\nfunction isCursorKilled(self, callback) {\n  if (self.cursorState.killed) {\n    setCursorNotified(self, callback);\n    return true;\n  }\n\n  return false;\n}\n/**\n * Mark cursor as being dead and notified\n */\n\n\nfunction setCursorDeadAndNotified(self, callback) {\n  self.cursorState.dead = true;\n  setCursorNotified(self, callback);\n}\n/**\n * Mark cursor as being notified\n */\n\n\nfunction setCursorNotified(self, callback) {\n  _setCursorNotifiedImpl(self, function () {\n    return handleCallback(callback, null, null);\n  });\n}\n\nfunction _setCursorNotifiedImpl(self, callback) {\n  self.cursorState.notified = true;\n  self.cursorState.documents = [];\n  self.cursorState.cursorIndex = 0;\n\n  if (self.cursorState.session) {\n    self._endSession(callback);\n\n    return;\n  }\n\n  return callback();\n}\n\nfunction nextFunction(self, callback) {\n  // We have notified about it\n  if (self.cursorState.notified) {\n    return callback(new Error('cursor is exhausted'));\n  } // Cursor is killed return null\n\n\n  if (isCursorKilled(self, callback)) return; // Cursor is dead but not marked killed, return null\n\n  if (isCursorDeadButNotkilled(self, callback)) return; // We have a dead and killed cursor, attempting to call next should error\n\n  if (isCursorDeadAndKilled(self, callback)) return; // We have just started the cursor\n\n  if (!self.cursorState.init) {\n    // Topology is not connected, save the call in the provided store to be\n    // Executed at some point when the handler deems it's reconnected\n    if (!self.topology.isConnected(self.options)) {\n      // Only need this for single server, because repl sets and mongos\n      // will always continue trying to reconnect\n      if (self.topology._type === 'server' && !self.topology.s.options.reconnect) {\n        // Reconnect is disabled, so we'll never reconnect\n        return callback(new MongoError('no connection available'));\n      }\n\n      if (self.disconnectHandler != null) {\n        if (self.topology.isDestroyed()) {\n          // Topology was destroyed, so don't try to wait for it to reconnect\n          return callback(new MongoError('Topology was destroyed'));\n        }\n\n        self.disconnectHandler.addObjectAndMethod('cursor', self, 'next', [callback], callback);\n        return;\n      }\n    }\n\n    self._initializeCursor(function (err, result) {\n      if (err || result === null) {\n        callback(err, result);\n        return;\n      }\n\n      nextFunction(self, callback);\n    });\n\n    return;\n  }\n\n  if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {\n    // Ensure we kill the cursor on the server\n    self.kill(); // Set cursor in dead and notified state\n\n    return setCursorDeadAndNotified(self, callback);\n  } else if (self.cursorState.cursorIndex === self.cursorState.documents.length && !Long.ZERO.equals(self.cursorState.cursorId)) {\n    // Ensure an empty cursor state\n    self.cursorState.documents = [];\n    self.cursorState.cursorIndex = 0; // Check if topology is destroyed\n\n    if (self.topology.isDestroyed()) return callback(new MongoNetworkError('connection destroyed, not possible to instantiate cursor')); // Check if connection is dead and return if not possible to\n    // execute a getMore on this connection\n\n    if (isConnectionDead(self, callback)) return; // Execute the next get more\n\n    self._getMore(function (err, doc, connection) {\n      if (err) {\n        return handleCallback(callback, err);\n      } // Save the returned connection to ensure all getMore's fire over the same connection\n\n\n      self.connection = connection; // Tailable cursor getMore result, notify owner about it\n      // No attempt is made here to retry, this is left to the user of the\n      // core module to handle to keep core simple\n\n      if (self.cursorState.documents.length === 0 && self.cmd.tailable && Long.ZERO.equals(self.cursorState.cursorId)) {\n        // No more documents in the tailed cursor\n        return handleCallback(callback, new MongoError({\n          message: 'No more documents in tailed cursor',\n          tailable: self.cmd.tailable,\n          awaitData: self.cmd.awaitData\n        }));\n      } else if (self.cursorState.documents.length === 0 && self.cmd.tailable && !Long.ZERO.equals(self.cursorState.cursorId)) {\n        return nextFunction(self, callback);\n      }\n\n      if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {\n        return setCursorDeadAndNotified(self, callback);\n      }\n\n      nextFunction(self, callback);\n    });\n  } else if (self.cursorState.documents.length === self.cursorState.cursorIndex && self.cmd.tailable && Long.ZERO.equals(self.cursorState.cursorId)) {\n    return handleCallback(callback, new MongoError({\n      message: 'No more documents in tailed cursor',\n      tailable: self.cmd.tailable,\n      awaitData: self.cmd.awaitData\n    }));\n  } else if (self.cursorState.documents.length === self.cursorState.cursorIndex && Long.ZERO.equals(self.cursorState.cursorId)) {\n    setCursorDeadAndNotified(self, callback);\n  } else {\n    if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {\n      // Ensure we kill the cursor on the server\n      self.kill(); // Set cursor in dead and notified state\n\n      return setCursorDeadAndNotified(self, callback);\n    } // Increment the current cursor limit\n\n\n    self.cursorState.currentLimit += 1; // Get the document\n\n    var doc = self.cursorState.documents[self.cursorState.cursorIndex++]; // Doc overflow\n\n    if (!doc || doc.$err) {\n      // Ensure we kill the cursor on the server\n      self.kill(); // Set cursor in dead and notified state\n\n      return setCursorDeadAndNotified(self, function () {\n        handleCallback(callback, new MongoError(doc ? doc.$err : undefined));\n      });\n    } // Transform the doc with passed in transformation method if provided\n\n\n    if (self.cursorState.transforms && typeof self.cursorState.transforms.doc === 'function') {\n      doc = self.cursorState.transforms.doc(doc);\n    } // Return the document\n\n\n    handleCallback(callback, null, doc);\n  }\n}\n\nmodule.exports = {\n  CursorState: CursorState,\n  CoreCursor: CoreCursor\n};","map":{"version":3,"sources":["/Users/S/Desktop/nodeprotake2/node_modules/mongodb/lib/core/cursor.js"],"names":["Logger","require","retrieveBSON","MongoError","MongoNetworkError","collationNotSupported","ReadPreference","isUnifiedTopology","executeOperation","Readable","SUPPORTS","MongoDBNamespace","OperationBase","BSON","Long","CursorState","INIT","OPEN","CLOSED","GET_MORE","handleCallback","callback","err","result","process","nextTick","CoreCursor","topology","ns","cmd","options","objectMode","operation","toString","pool","server","disconnectHandler","bson","s","namespace","fromString","cursorState","cursorId","documents","cursorIndex","dead","killed","init","notified","limit","skip","batchSize","currentLimit","transforms","raw","session","topologyOptions","promoteLongs","promoteValues","promoteBuffers","reconnect","logger","fromNumber","lastCursorId","value","nextFunction","cursor","length","number","unreadDocumentsLength","elements","slice","doc","i","kill","isZero","killCursors","state","isDead","push","_next","listeners","emit","close","streamOptions","transform","once","force","owner","undefined","clearSession","endSession","isDebug","debug","JSON","stringify","query","getMore","conn","_endSession","shouldCheckForSessionSupport","selectServer","primaryPreferred","_initializeCursor","done","tailable","awaitData","setCursorNotified","queryCallback","r","message","queryFailure","Array","isArray","find","virtual","id","operationTime","firstBatch","ZERO","serverSelectOptions","readPreference","addObjectAndMethod","name","commandOptions","Object","assign","command","ASYNC_ITERATOR","prototype","Symbol","asyncIterator","isConnectionDead","self","isDestroyed","host","port","_setCursorNotifiedImpl","isCursorDeadButNotkilled","isCursorDeadAndKilled","isCursorKilled","setCursorDeadAndNotified","Error","isConnected","_type","equals","_getMore","connection","$err","module","exports"],"mappings":"AAAA;;;;;;;;;;AAEA,IAAMA,MAAM,GAAGC,OAAO,CAAC,qBAAD,CAAtB;;AACA,IAAMC,YAAY,GAAGD,OAAO,CAAC,oBAAD,CAAP,CAA8BC,YAAnD;;AACA,IAAMC,UAAU,GAAGF,OAAO,CAAC,SAAD,CAAP,CAAmBE,UAAtC;;AACA,IAAMC,iBAAiB,GAAGH,OAAO,CAAC,SAAD,CAAP,CAAmBG,iBAA7C;;AACA,IAAMC,qBAAqB,GAAGJ,OAAO,CAAC,SAAD,CAAP,CAAmBI,qBAAjD;;AACA,IAAMC,cAAc,GAAGL,OAAO,CAAC,8BAAD,CAA9B;;AACA,IAAMM,iBAAiB,GAAGN,OAAO,CAAC,SAAD,CAAP,CAAmBM,iBAA7C;;AACA,IAAMC,gBAAgB,GAAGP,OAAO,CAAC,iCAAD,CAAhC;;AACA,IAAMQ,QAAQ,GAAGR,OAAO,CAAC,QAAD,CAAP,CAAkBQ,QAAnC;;AACA,IAAMC,QAAQ,GAAGT,OAAO,CAAC,UAAD,CAAP,CAAoBS,QAArC;;AACA,IAAMC,gBAAgB,GAAGV,OAAO,CAAC,UAAD,CAAP,CAAoBU,gBAA7C;;AACA,IAAMC,aAAa,GAAGX,OAAO,CAAC,yBAAD,CAAP,CAAmCW,aAAzD;;AAEA,IAAMC,IAAI,GAAGX,YAAY,EAAzB;AACA,IAAMY,IAAI,GAAGD,IAAI,CAACC,IAAlB,C,CAEA;;AACA,IAAMC,WAAW,GAAG;AAClBC,EAAAA,IAAI,EAAE,CADY;AAElBC,EAAAA,IAAI,EAAE,CAFY;AAGlBC,EAAAA,MAAM,EAAE,CAHU;AAIlBC,EAAAA,QAAQ,EAAE;AAJQ,CAApB,C,CAOA;AACA;;AACA,SAASC,cAAT,CAAwBC,QAAxB,EAAkCC,GAAlC,EAAuCC,MAAvC,EAA+C;AAC7C,MAAI;AACFF,IAAAA,QAAQ,CAACC,GAAD,EAAMC,MAAN,CAAR;AACD,GAFD,CAEE,OAAOD,GAAP,EAAY;AACZE,IAAAA,OAAO,CAACC,QAAR,CAAiB,YAAW;AAC1B,YAAMH,GAAN;AACD,KAFD;AAGD;AACF;AAED;;;;;;;;AAQA;;;;;;;AAOA;;;;;;;;;IAOMI,U;;;;;AACJ;;;;;;;;;;;;;;AAcA,sBAAYC,QAAZ,EAAsBC,EAAtB,EAA0BC,GAA1B,EAA+BC,OAA/B,EAAwC;AAAA;;AAAA;;AACtC,8BAAM;AAAEC,MAAAA,UAAU,EAAE;AAAd,KAAN;AACAD,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;;AAEA,QAAIF,EAAE,YAAYhB,aAAlB,EAAiC;AAC/B,YAAKoB,SAAL,GAAiBJ,EAAjB;AACAA,MAAAA,EAAE,GAAG,MAAKI,SAAL,CAAeJ,EAAf,CAAkBK,QAAlB,EAAL;AACAH,MAAAA,OAAO,GAAG,MAAKE,SAAL,CAAeF,OAAzB;AACAD,MAAAA,GAAG,GAAG,MAAKG,SAAL,CAAeH,GAAf,GAAqB,MAAKG,SAAL,CAAeH,GAApC,GAA0C,EAAhD;AACD,KATqC,CAWtC;;;AACA,UAAKK,IAAL,GAAY,IAAZ,CAZsC,CAatC;;AACA,UAAKC,MAAL,GAAc,IAAd,CAdsC,CAgBtC;;AACA,UAAKC,iBAAL,GAAyBN,OAAO,CAACM,iBAAjC,CAjBsC,CAmBtC;;AACA,UAAKC,IAAL,GAAYV,QAAQ,CAACW,CAAT,CAAWD,IAAvB;AACA,UAAKT,EAAL,GAAUA,EAAV;AACA,UAAKW,SAAL,GAAiB5B,gBAAgB,CAAC6B,UAAjB,CAA4BZ,EAA5B,CAAjB;AACA,UAAKC,GAAL,GAAWA,GAAX;AACA,UAAKC,OAAL,GAAeA,OAAf;AACA,UAAKH,QAAL,GAAgBA,QAAhB,CAzBsC,CA2BtC;;AACA,UAAKc,WAAL,GAAmB;AACjBC,MAAAA,QAAQ,EAAE,IADO;AAEjBb,MAAAA,GAAG,EAAHA,GAFiB;AAGjBc,MAAAA,SAAS,EAAEb,OAAO,CAACa,SAAR,IAAqB,EAHf;AAIjBC,MAAAA,WAAW,EAAE,CAJI;AAKjBC,MAAAA,IAAI,EAAE,KALW;AAMjBC,MAAAA,MAAM,EAAE,KANS;AAOjBC,MAAAA,IAAI,EAAE,KAPW;AAQjBC,MAAAA,QAAQ,EAAE,KARO;AASjBC,MAAAA,KAAK,EAAEnB,OAAO,CAACmB,KAAR,IAAiBpB,GAAG,CAACoB,KAArB,IAA8B,CATpB;AAUjBC,MAAAA,IAAI,EAAEpB,OAAO,CAACoB,IAAR,IAAgBrB,GAAG,CAACqB,IAApB,IAA4B,CAVjB;AAWjBC,MAAAA,SAAS,EAAErB,OAAO,CAACqB,SAAR,IAAqBtB,GAAG,CAACsB,SAAzB,IAAsC,IAXhC;AAYjBC,MAAAA,YAAY,EAAE,CAZG;AAajB;AACAC,MAAAA,UAAU,EAAEvB,OAAO,CAACuB,UAdH;AAejBC,MAAAA,GAAG,EAAExB,OAAO,CAACwB,GAAR,IAAgBzB,GAAG,IAAIA,GAAG,CAACyB;AAff,KAAnB;;AAkBA,QAAI,OAAOxB,OAAO,CAACyB,OAAf,KAA2B,QAA/B,EAAyC;AACvC,YAAKd,WAAL,CAAiBc,OAAjB,GAA2BzB,OAAO,CAACyB,OAAnC;AACD,KAhDqC,CAkDtC;;;AACA,QAAMC,eAAe,GAAG7B,QAAQ,CAACW,CAAT,CAAWR,OAAnC;;AACA,QAAI,OAAO0B,eAAe,CAACC,YAAvB,KAAwC,SAA5C,EAAuD;AACrD,YAAKhB,WAAL,CAAiBgB,YAAjB,GAAgCD,eAAe,CAACC,YAAhD;AACD,KAFD,MAEO,IAAI,OAAO3B,OAAO,CAAC2B,YAAf,KAAgC,SAApC,EAA+C;AACpD,YAAKhB,WAAL,CAAiBgB,YAAjB,GAAgC3B,OAAO,CAAC2B,YAAxC;AACD,KAxDqC,CA0DtC;;;AACA,QAAI,OAAOD,eAAe,CAACE,aAAvB,KAAyC,SAA7C,EAAwD;AACtD,YAAKjB,WAAL,CAAiBiB,aAAjB,GAAiCF,eAAe,CAACE,aAAjD;AACD,KAFD,MAEO,IAAI,OAAO5B,OAAO,CAAC4B,aAAf,KAAiC,SAArC,EAAgD;AACrD,YAAKjB,WAAL,CAAiBiB,aAAjB,GAAiC5B,OAAO,CAAC4B,aAAzC;AACD,KA/DqC,CAiEtC;;;AACA,QAAI,OAAOF,eAAe,CAACG,cAAvB,KAA0C,SAA9C,EAAyD;AACvD,YAAKlB,WAAL,CAAiBkB,cAAjB,GAAkCH,eAAe,CAACG,cAAlD;AACD,KAFD,MAEO,IAAI,OAAO7B,OAAO,CAAC6B,cAAf,KAAkC,SAAtC,EAAiD;AACtD,YAAKlB,WAAL,CAAiBkB,cAAjB,GAAkC7B,OAAO,CAAC6B,cAA1C;AACD;;AAED,QAAIH,eAAe,CAACI,SAApB,EAA+B;AAC7B,YAAKnB,WAAL,CAAiBmB,SAAjB,GAA6BJ,eAAe,CAACI,SAA7C;AACD,KA1EqC,CA4EtC;;;AACA,UAAKC,MAAL,GAAc7D,MAAM,CAAC,QAAD,EAAWwD,eAAX,CAApB,CA7EsC,CA+EtC;AACA;;AACA,QAAI,OAAO3B,GAAP,KAAe,QAAnB,EAA6B;AAC3B,YAAKY,WAAL,CAAiBC,QAAjB,GAA4B5B,IAAI,CAACgD,UAAL,CAAgBjC,GAAhB,CAA5B;AACA,YAAKY,WAAL,CAAiBsB,YAAjB,GAAgC,MAAKtB,WAAL,CAAiBC,QAAjD;AACD,KAHD,MAGO,IAAIb,GAAG,YAAYf,IAAnB,EAAyB;AAC9B,YAAK2B,WAAL,CAAiBC,QAAjB,GAA4Bb,GAA5B;AACA,YAAKY,WAAL,CAAiBsB,YAAjB,GAAgClC,GAAhC;AACD,KAvFqC,CAyFtC;;;AACA,QAAI,MAAKG,SAAT,EAAoB;AAClB,YAAKA,SAAL,CAAeS,WAAf,GAA6B,MAAKA,WAAlC;AACD;;AA5FqC;AA6FvC;;;;uCAEkBuB,K,EAAO;AACxB,WAAKvB,WAAL,CAAiBU,SAAjB,GAA6Ba,KAA7B;AACD;;;sCAEiB;AAChB,aAAO,KAAKvB,WAAL,CAAiBU,SAAxB;AACD;;;mCAEca,K,EAAO;AACpB,WAAKvB,WAAL,CAAiBQ,KAAjB,GAAyBe,KAAzB;AACD;;;kCAEa;AACZ,aAAO,KAAKvB,WAAL,CAAiBQ,KAAxB;AACD;;;kCAEae,K,EAAO;AACnB,WAAKvB,WAAL,CAAiBS,IAAjB,GAAwBc,KAAxB;AACD;;;iCAEY;AACX,aAAO,KAAKvB,WAAL,CAAiBS,IAAxB;AACD;AAED;;;;;;;;0BAKM7B,Q,EAAU;AACd4C,MAAAA,YAAY,CAAC,IAAD,EAAO5C,QAAP,CAAZ;AACD;AAED;;;;;;;;4BAKQ;AACN,aAAO,KAAKM,QAAL,CAAcuC,MAAd,CAAqB,KAAKtC,EAA1B,EAA8B,KAAKC,GAAnC,EAAwC,KAAKC,OAA7C,CAAP;AACD;AAED;;;;;;;;6BAKS;AACP,aAAO,KAAKW,WAAL,CAAiBI,IAAjB,KAA0B,IAAjC;AACD;AAED;;;;;;;;+BAKW;AACT,aAAO,KAAKJ,WAAL,CAAiBK,MAAjB,KAA4B,IAAnC;AACD;AAED;;;;;;;;iCAKa;AACX,aAAO,KAAKL,WAAL,CAAiBO,QAAjB,KAA8B,IAArC;AACD;AAED;;;;;;;;oCAKgB;AACd,aAAO,KAAKP,WAAL,CAAiBE,SAAjB,CAA2BwB,MAA3B,GAAoC,KAAK1B,WAAL,CAAiBG,WAA5D;AACD;AAED;;;;;;;;0CAKsBwB,M,EAAQ;AAC5B,UAAMC,qBAAqB,GAAG,KAAK5B,WAAL,CAAiBE,SAAjB,CAA2BwB,MAA3B,GAAoC,KAAK1B,WAAL,CAAiBG,WAAnF;AACA,UAAMuB,MAAM,GAAGC,MAAM,GAAGC,qBAAT,GAAiCD,MAAjC,GAA0CC,qBAAzD;AACA,UAAIC,QAAQ,GAAG,KAAK7B,WAAL,CAAiBE,SAAjB,CAA2B4B,KAA3B,CACb,KAAK9B,WAAL,CAAiBG,WADJ,EAEb,KAAKH,WAAL,CAAiBG,WAAjB,GAA+BuB,MAFlB,CAAf,CAH4B,CAQ5B;;AACA,UAAI,KAAK1B,WAAL,CAAiBY,UAAjB,IAA+B,OAAO,KAAKZ,WAAL,CAAiBY,UAAjB,CAA4BmB,GAAnC,KAA2C,UAA9E,EAA0F;AACxF;AACA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,QAAQ,CAACH,MAA7B,EAAqCM,CAAC,EAAtC,EAA0C;AACxCH,UAAAA,QAAQ,CAACG,CAAD,CAAR,GAAc,KAAKhC,WAAL,CAAiBY,UAAjB,CAA4BmB,GAA5B,CAAgCF,QAAQ,CAACG,CAAD,CAAxC,CAAd;AACD;AACF,OAd2B,CAgB5B;AACA;;;AACA,UACE,KAAKhC,WAAL,CAAiBQ,KAAjB,GAAyB,CAAzB,IACA,KAAKR,WAAL,CAAiBW,YAAjB,GAAgCkB,QAAQ,CAACH,MAAzC,GAAkD,KAAK1B,WAAL,CAAiBQ,KAFrE,EAGE;AACAqB,QAAAA,QAAQ,GAAGA,QAAQ,CAACC,KAAT,CAAe,CAAf,EAAkB,KAAK9B,WAAL,CAAiBQ,KAAjB,GAAyB,KAAKR,WAAL,CAAiBW,YAA5D,CAAX;AACA,aAAKsB,IAAL;AACD,OAxB2B,CA0B5B;;;AACA,WAAKjC,WAAL,CAAiBW,YAAjB,GAAgC,KAAKX,WAAL,CAAiBW,YAAjB,GAAgCkB,QAAQ,CAACH,MAAzE;AACA,WAAK1B,WAAL,CAAiBG,WAAjB,GAA+B,KAAKH,WAAL,CAAiBG,WAAjB,GAA+B0B,QAAQ,CAACH,MAAvE,CA5B4B,CA8B5B;;AACA,aAAOG,QAAP;AACD;AAED;;;;;;;;yBAKKjD,Q,EAAU;AACb;AACA,WAAKoB,WAAL,CAAiBI,IAAjB,GAAwB,IAAxB;AACA,WAAKJ,WAAL,CAAiBK,MAAjB,GAA0B,IAA1B,CAHa,CAIb;;AACA,WAAKL,WAAL,CAAiBE,SAAjB,GAA6B,EAA7B,CALa,CAOb;;AACA,UACE,KAAKF,WAAL,CAAiBC,QAAjB,IAA6B,IAA7B,IACA,KAAKD,WAAL,CAAiBC,QAAjB,CAA0BiC,MAA1B,EADA,IAEA,KAAKlC,WAAL,CAAiBM,IAAjB,KAA0B,KAH5B,EAIE;AACA,YAAI1B,QAAJ,EAAcA,QAAQ,CAAC,IAAD,EAAO,IAAP,CAAR;AACd;AACD;;AAED,WAAKc,MAAL,CAAYyC,WAAZ,CAAwB,KAAKhD,EAA7B,EAAiC,KAAKa,WAAtC,EAAmDpB,QAAnD;AACD;AAED;;;;;;6BAGS;AACP,UAAI,KAAKoB,WAAL,CAAiBM,IAArB,EAA2B;AACzB,YAAI,CAAC,KAAKN,WAAL,CAAiBI,IAAtB,EAA4B;AAC1B,eAAK6B,IAAL;AACD;;AAED,aAAKjC,WAAL,CAAiBW,YAAjB,GAAgC,CAAhC;AACA,aAAKX,WAAL,CAAiBM,IAAjB,GAAwB,KAAxB;AACA,aAAKN,WAAL,CAAiBI,IAAjB,GAAwB,KAAxB;AACA,aAAKJ,WAAL,CAAiBK,MAAjB,GAA0B,KAA1B;AACA,aAAKL,WAAL,CAAiBO,QAAjB,GAA4B,KAA5B;AACA,aAAKP,WAAL,CAAiBE,SAAjB,GAA6B,EAA7B;AACA,aAAKF,WAAL,CAAiBC,QAAjB,GAA4B,IAA5B;AACA,aAAKD,WAAL,CAAiBG,WAAjB,GAA+B,CAA/B;AACD;AACF,K,CAED;;;;4BACQ;AAAA;;AACN,UAAK,KAAKN,CAAL,IAAU,KAAKA,CAAL,CAAOuC,KAAP,KAAiB9D,WAAW,CAACG,MAAxC,IAAmD,KAAK4D,MAAL,EAAvD,EAAsE;AACpE,eAAO,KAAKC,IAAL,CAAU,IAAV,CAAP;AACD,OAHK,CAKN;;;AACA,WAAKC,KAAL,CAAW,UAAC1D,GAAD,EAAMC,MAAN,EAAiB;AAC1B,YAAID,GAAJ,EAAS;AACP,cAAI,MAAI,CAAC2D,SAAL,CAAe,OAAf,KAA2B,MAAI,CAACA,SAAL,CAAe,OAAf,EAAwBd,MAAxB,GAAiC,CAAhE,EAAmE;AACjE,YAAA,MAAI,CAACe,IAAL,CAAU,OAAV,EAAmB5D,GAAnB;AACD;;AACD,cAAI,CAAC,MAAI,CAACwD,MAAL,EAAL,EAAoB,MAAI,CAACK,KAAL,GAJb,CAMP;;AACA,UAAA,MAAI,CAACD,IAAL,CAAU,KAAV;;AACA,iBAAO,MAAI,CAACA,IAAL,CAAU,QAAV,CAAP;AACD,SAVyB,CAY1B;;;AACA,YACE,MAAI,CAACzC,WAAL,CAAiB2C,aAAjB,IACA,OAAO,MAAI,CAAC3C,WAAL,CAAiB2C,aAAjB,CAA+BC,SAAtC,KAAoD,UADpD,IAEA9D,MAAM,IAAI,IAHZ,EAIE;AACA,iBAAO,MAAI,CAACwD,IAAL,CAAU,MAAI,CAACtC,WAAL,CAAiB2C,aAAjB,CAA+BC,SAA/B,CAAyC9D,MAAzC,CAAV,CAAP;AACD,SAnByB,CAqB1B;;;AACA,QAAA,MAAI,CAACwD,IAAL,CAAUxD,MAAV;;AAEA,YAAIA,MAAM,KAAK,IAAX,IAAmB,MAAI,CAACuD,MAAL,EAAvB,EAAsC;AACpC,UAAA,MAAI,CAACQ,IAAL,CAAU,KAAV,EAAiB,YAAM;AACrB,YAAA,MAAI,CAACH,KAAL;;AACA,YAAA,MAAI,CAACD,IAAL,CAAU,QAAV;AACD,WAHD;AAID;AACF,OA9BD;AA+BD;;;gCAEWpD,O,EAAST,Q,EAAU;AAC7B,UAAI,OAAOS,OAAP,KAAmB,UAAvB,EAAmC;AACjCT,QAAAA,QAAQ,GAAGS,OAAX;AACAA,QAAAA,OAAO,GAAG,EAAV;AACD;;AACDA,MAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AAEA,UAAMyB,OAAO,GAAG,KAAKd,WAAL,CAAiBc,OAAjC;;AAEA,UAAIA,OAAO,KAAKzB,OAAO,CAACyD,KAAR,IAAiBhC,OAAO,CAACiC,KAAR,KAAkB,IAAxC,CAAX,EAA0D;AACxD,aAAK/C,WAAL,CAAiBc,OAAjB,GAA2BkC,SAA3B;;AAEA,YAAI,KAAKzD,SAAT,EAAoB;AAClB,eAAKA,SAAL,CAAe0D,YAAf;AACD;;AAEDnC,QAAAA,OAAO,CAACoC,UAAR,CAAmBtE,QAAnB;AACA,eAAO,IAAP;AACD;;AAED,UAAIA,QAAJ,EAAc;AACZA,QAAAA,QAAQ;AACT;;AAED,aAAO,KAAP;AACD;;;6BAEQA,Q,EAAU;AAAA;;AACjB,UAAI,KAAKwC,MAAL,CAAY+B,OAAZ,EAAJ,EAA2B;AACzB,aAAK/B,MAAL,CAAYgC,KAAZ,4CAAsDC,IAAI,CAACC,SAAL,CAAe,KAAKC,KAApB,CAAtD;AACD,OAHgB,CAKjB;;;AACA,UAAI7C,SAAS,GAAG,KAAKV,WAAL,CAAiBU,SAAjC;;AACA,UACE,KAAKV,WAAL,CAAiBQ,KAAjB,GAAyB,CAAzB,IACA,KAAKR,WAAL,CAAiBW,YAAjB,GAAgCD,SAAhC,GAA4C,KAAKV,WAAL,CAAiBQ,KAF/D,EAGE;AACAE,QAAAA,SAAS,GAAG,KAAKV,WAAL,CAAiBQ,KAAjB,GAAyB,KAAKR,WAAL,CAAiBW,YAAtD;AACD;;AAED,UAAMX,WAAW,GAAG,KAAKA,WAAzB;AACA,WAAKN,MAAL,CAAY8D,OAAZ,CAAoB,KAAKrE,EAAzB,EAA6Ba,WAA7B,EAA0CU,SAA1C,EAAqD,KAAKrB,OAA1D,EAAmE,UAACR,GAAD,EAAMC,MAAN,EAAc2E,IAAd,EAAuB;AACxF;AACA,YAAI5E,GAAG,IAAKmB,WAAW,CAACC,QAAZ,IAAwBD,WAAW,CAACC,QAAZ,CAAqBiC,MAArB,EAApC,EAAoE;AAClE,UAAA,MAAI,CAACwB,WAAL;AACD;;AAED9E,QAAAA,QAAQ,CAACC,GAAD,EAAMC,MAAN,EAAc2E,IAAd,CAAR;AACD,OAPD;AAQD;;;sCAEiB7E,Q,EAAU;AAAA;;AAC1B,UAAM6C,MAAM,GAAG,IAAf,CAD0B,CAG1B;;AACA,UAAI3D,iBAAiB,CAAC2D,MAAM,CAACvC,QAAR,CAAjB,IAAsCuC,MAAM,CAACvC,QAAP,CAAgByE,4BAAhB,EAA1C,EAA0F;AACxFlC,QAAAA,MAAM,CAACvC,QAAP,CAAgB0E,YAAhB,CAA6B/F,cAAc,CAACgG,gBAA5C,EAA8D,UAAAhF,GAAG,EAAI;AACnE,cAAIA,GAAJ,EAAS;AACPD,YAAAA,QAAQ,CAACC,GAAD,CAAR;AACA;AACD;;AAED,UAAA,MAAI,CAACiF,iBAAL,CAAuBlF,QAAvB;AACD,SAPD;AASA;AACD;;AAED,eAASmF,IAAT,CAAclF,GAAd,EAAmBC,MAAnB,EAA2B;AACzB,YAAMkB,WAAW,GAAGyB,MAAM,CAACzB,WAA3B;;AACA,YAAInB,GAAG,IAAKmB,WAAW,CAACC,QAAZ,IAAwBD,WAAW,CAACC,QAAZ,CAAqBiC,MAArB,EAApC,EAAoE;AAClET,UAAAA,MAAM,CAACiC,WAAP;AACD;;AAED,YACE1D,WAAW,CAACE,SAAZ,CAAsBwB,MAAtB,KAAiC,CAAjC,IACA1B,WAAW,CAACC,QADZ,IAEAD,WAAW,CAACC,QAAZ,CAAqBiC,MAArB,EAFA,IAGA,CAACT,MAAM,CAACrC,GAAP,CAAW4E,QAHZ,IAIA,CAACvC,MAAM,CAACrC,GAAP,CAAW6E,SALd,EAME;AACA,iBAAOC,iBAAiB,CAACzC,MAAD,EAAS7C,QAAT,CAAxB;AACD;;AAEDA,QAAAA,QAAQ,CAACC,GAAD,EAAMC,MAAN,CAAR;AACD;;AAED,UAAMqF,aAAa,GAAG,SAAhBA,aAAgB,CAACtF,GAAD,EAAMuF,CAAN,EAAY;AAChC,YAAIvF,GAAJ,EAAS;AACP,iBAAOkF,IAAI,CAAClF,GAAD,CAAX;AACD;;AAED,YAAMC,MAAM,GAAGsF,CAAC,CAACC,OAAjB;;AACA,YAAIvF,MAAM,CAACwF,YAAX,EAAyB;AACvB,iBAAOP,IAAI,CAAC,IAAIrG,UAAJ,CAAeoB,MAAM,CAACoB,SAAP,CAAiB,CAAjB,CAAf,CAAD,EAAsC,IAAtC,CAAX;AACD,SAR+B,CAUhC;;;AACA,YACEqE,KAAK,CAACC,OAAN,CAAc1F,MAAM,CAACoB,SAArB,KACApB,MAAM,CAACoB,SAAP,CAAiBwB,MAAjB,KAA4B,CAD5B,KAEC,CAACD,MAAM,CAACrC,GAAP,CAAWqF,IAAZ,IAAqBhD,MAAM,CAACrC,GAAP,CAAWqF,IAAX,IAAmBhD,MAAM,CAACrC,GAAP,CAAWsF,OAAX,KAAuB,KAFhE,MAGC,OAAO5F,MAAM,CAACoB,SAAP,CAAiB,CAAjB,EAAoBuB,MAA3B,KAAsC,QAAtC,IACC3C,MAAM,CAACoB,SAAP,CAAiB,CAAjB,EAAoB,MAApB,CADD,IAECpB,MAAM,CAACoB,SAAP,CAAiB,CAAjB,EAAoB,QAApB,CAFD,IAGCqE,KAAK,CAACC,OAAN,CAAc1F,MAAM,CAACoB,SAAP,CAAiB,CAAjB,EAAoBpB,MAAlC,CANF,CADF,EAQE;AACA;AACA,cAAIA,MAAM,CAACoB,SAAP,CAAiB,CAAjB,EAAoB,MAApB,KAA+BpB,MAAM,CAACoB,SAAP,CAAiB,CAAjB,EAAoB,QAApB,CAAnC,EAAkE;AAChE,mBAAO6D,IAAI,CAAC,IAAIrG,UAAJ,CAAeoB,MAAM,CAACoB,SAAP,CAAiB,CAAjB,CAAf,CAAD,EAAsC,IAAtC,CAAX;AACD,WAJD,CAMA;;;AACA,cAAIpB,MAAM,CAACoB,SAAP,CAAiB,CAAjB,EAAoBuB,MAApB,IAA8B,IAA9B,IAAsC,OAAO3C,MAAM,CAACoB,SAAP,CAAiB,CAAjB,EAAoBuB,MAA3B,KAAsC,QAAhF,EAA0F;AACxF,gBAAMkD,EAAE,GAAG7F,MAAM,CAACoB,SAAP,CAAiB,CAAjB,EAAoBuB,MAApB,CAA2BkD,EAAtC,CADwF,CAExF;;AACA,gBAAI7F,MAAM,CAACoB,SAAP,CAAiB,CAAjB,EAAoBuB,MAApB,CAA2BtC,EAA/B,EAAmC;AACjCsC,cAAAA,MAAM,CAACtC,EAAP,GAAYL,MAAM,CAACoB,SAAP,CAAiB,CAAjB,EAAoBuB,MAApB,CAA2BtC,EAAvC;AACD,aALuF,CAMxF;;;AACAsC,YAAAA,MAAM,CAACzB,WAAP,CAAmBC,QAAnB,GAA8B,OAAO0E,EAAP,KAAc,QAAd,GAAyBtG,IAAI,CAACgD,UAAL,CAAgBsD,EAAhB,CAAzB,GAA+CA,EAA7E;AACAlD,YAAAA,MAAM,CAACzB,WAAP,CAAmBsB,YAAnB,GAAkCG,MAAM,CAACzB,WAAP,CAAmBC,QAArD;AACAwB,YAAAA,MAAM,CAACzB,WAAP,CAAmB4E,aAAnB,GAAmC9F,MAAM,CAACoB,SAAP,CAAiB,CAAjB,EAAoB0E,aAAvD,CATwF,CAWxF;;AACA,gBAAIL,KAAK,CAACC,OAAN,CAAc1F,MAAM,CAACoB,SAAP,CAAiB,CAAjB,EAAoBuB,MAApB,CAA2BoD,UAAzC,CAAJ,EAA0D;AACxDpD,cAAAA,MAAM,CAACzB,WAAP,CAAmBE,SAAnB,GAA+BpB,MAAM,CAACoB,SAAP,CAAiB,CAAjB,EAAoBuB,MAApB,CAA2BoD,UAA1D,CADwD,CACc;AACvE,aAduF,CAgBxF;;;AACA,mBAAOd,IAAI,CAAC,IAAD,EAAOjF,MAAP,CAAX;AACD;;AAED,cAAIyF,KAAK,CAACC,OAAN,CAAc1F,MAAM,CAACoB,SAAP,CAAiB,CAAjB,EAAoBpB,MAAlC,CAAJ,EAA+C;AAC7C2C,YAAAA,MAAM,CAACzB,WAAP,CAAmBE,SAAnB,GAA+BpB,MAAM,CAACoB,SAAP,CAAiB,CAAjB,EAAoBpB,MAAnD;AACA2C,YAAAA,MAAM,CAACzB,WAAP,CAAmBC,QAAnB,GAA8B5B,IAAI,CAACyG,IAAnC;AACA,mBAAOf,IAAI,CAAC,IAAD,EAAOjF,MAAP,CAAX;AACD;AACF,SAnD+B,CAqDhC;;;AACA,YAAMmB,QAAQ,GAAGnB,MAAM,CAACmB,QAAP,IAAmB,CAApC;AACAwB,QAAAA,MAAM,CAACzB,WAAP,CAAmBC,QAAnB,GAA8BA,QAAQ,YAAY5B,IAApB,GAA2B4B,QAA3B,GAAsC5B,IAAI,CAACgD,UAAL,CAAgBpB,QAAhB,CAApE;AACAwB,QAAAA,MAAM,CAACzB,WAAP,CAAmBE,SAAnB,GAA+BpB,MAAM,CAACoB,SAAtC;AACAuB,QAAAA,MAAM,CAACzB,WAAP,CAAmBsB,YAAnB,GAAkCxC,MAAM,CAACmB,QAAzC,CAzDgC,CA2DhC;;AACA,YACEwB,MAAM,CAACzB,WAAP,CAAmBY,UAAnB,IACA,OAAOa,MAAM,CAACzB,WAAP,CAAmBY,UAAnB,CAA8B2C,KAArC,KAA+C,UAFjD,EAGE;AACA9B,UAAAA,MAAM,CAACzB,WAAP,CAAmBE,SAAnB,GAA+BuB,MAAM,CAACzB,WAAP,CAAmBY,UAAnB,CAA8B2C,KAA9B,CAAoCzE,MAApC,CAA/B;AACD;;AAEDiF,QAAAA,IAAI,CAAC,IAAD,EAAOjF,MAAP,CAAJ;AACD,OApED;;AAsEA,UAAI2C,MAAM,CAAClC,SAAX,EAAsB;AACpB,YAAIkC,MAAM,CAACL,MAAP,CAAc+B,OAAd,EAAJ,EAA6B;AAC3B1B,UAAAA,MAAM,CAACL,MAAP,CAAcgC,KAAd,gCAC0BC,IAAI,CAACC,SAAL,CAAe7B,MAAM,CAACrC,GAAtB,CAD1B,2BACqEiE,IAAI,CAACC,SAAL,CACjE7B,MAAM,CAAC8B,KAD0D,CADrE;AAKD;;AAEDxF,QAAAA,gBAAgB,CAAC0D,MAAM,CAACvC,QAAR,EAAkBuC,MAAM,CAAClC,SAAzB,EAAoC,UAACV,GAAD,EAAMC,MAAN,EAAiB;AACnE,cAAID,GAAJ,EAAS;AACPkF,YAAAA,IAAI,CAAClF,GAAD,CAAJ;AACA;AACD;;AAED4C,UAAAA,MAAM,CAAC/B,MAAP,GAAgB+B,MAAM,CAAClC,SAAP,CAAiBG,MAAjC;AACA+B,UAAAA,MAAM,CAACzB,WAAP,CAAmBM,IAAnB,GAA0B,IAA1B,CAPmE,CASnE;;AACA,cAAImB,MAAM,CAACzB,WAAP,CAAmBC,QAAnB,IAA+B,IAAnC,EAAyC;AACvC,mBAAO8D,IAAI,EAAX;AACD;;AAEDI,UAAAA,aAAa,CAACtF,GAAD,EAAMC,MAAN,CAAb;AACD,SAfe,CAAhB;AAiBA;AACD,OArIyB,CAuI1B;;;AACA,UAAMiG,mBAAmB,GAAG,EAA5B;;AACA,UAAItD,MAAM,CAACzB,WAAP,CAAmBc,OAAvB,EAAgC;AAC9BiE,QAAAA,mBAAmB,CAACjE,OAApB,GAA8BW,MAAM,CAACzB,WAAP,CAAmBc,OAAjD;AACD;;AAED,UAAIW,MAAM,CAAClC,SAAX,EAAsB;AACpBwF,QAAAA,mBAAmB,CAACC,cAApB,GAAqCvD,MAAM,CAAClC,SAAP,CAAiByF,cAAtD;AACD,OAFD,MAEO,IAAIvD,MAAM,CAACpC,OAAP,CAAe2F,cAAnB,EAAmC;AACxCD,QAAAA,mBAAmB,CAACC,cAApB,GAAqCvD,MAAM,CAACpC,OAAP,CAAe2F,cAApD;AACD;;AAED,aAAOvD,MAAM,CAACvC,QAAP,CAAgB0E,YAAhB,CAA6BmB,mBAA7B,EAAkD,UAAClG,GAAD,EAAMa,MAAN,EAAiB;AACxE,YAAIb,GAAJ,EAAS;AACP,cAAMc,iBAAiB,GAAG8B,MAAM,CAAC9B,iBAAjC;;AACA,cAAIA,iBAAiB,IAAI,IAAzB,EAA+B;AAC7B,mBAAOA,iBAAiB,CAACsF,kBAAlB,CACL,QADK,EAELxD,MAFK,EAGL,MAHK,EAIL,CAAC7C,QAAD,CAJK,EAKLA,QALK,CAAP;AAOD;;AAED,iBAAOA,QAAQ,CAACC,GAAD,CAAf;AACD;;AAED4C,QAAAA,MAAM,CAAC/B,MAAP,GAAgBA,MAAhB;AACA+B,QAAAA,MAAM,CAACzB,WAAP,CAAmBM,IAAnB,GAA0B,IAA1B;;AACA,YAAI1C,qBAAqB,CAAC6D,MAAM,CAAC/B,MAAR,EAAgB+B,MAAM,CAACrC,GAAvB,CAAzB,EAAsD;AACpD,iBAAOR,QAAQ,CAAC,IAAIlB,UAAJ,kBAAyB+D,MAAM,CAAC/B,MAAP,CAAcwF,IAAvC,iCAAD,CAAf;AACD,SApBuE,CAsBxE;;;AACA,YAAIzD,MAAM,CAACzB,WAAP,CAAmBC,QAAnB,IAA+B,IAAnC,EAAyC;AACvC,iBAAO8D,IAAI,EAAX;AACD;;AAED,YAAItC,MAAM,CAACL,MAAP,CAAc+B,OAAd,EAAJ,EAA6B;AAC3B1B,UAAAA,MAAM,CAACL,MAAP,CAAcgC,KAAd,gCAC0BC,IAAI,CAACC,SAAL,CAAe7B,MAAM,CAACrC,GAAtB,CAD1B,2BACqEiE,IAAI,CAACC,SAAL,CACjE7B,MAAM,CAAC8B,KAD0D,CADrE;AAKD;;AAED,YAAI9B,MAAM,CAACrC,GAAP,CAAWqF,IAAX,IAAmB,IAAvB,EAA6B;AAC3B/E,UAAAA,MAAM,CAAC6D,KAAP,CAAa9B,MAAM,CAACtC,EAApB,EAAwBsC,MAAM,CAACrC,GAA/B,EAAoCqC,MAAM,CAACzB,WAA3C,EAAwDyB,MAAM,CAACpC,OAA/D,EAAwE8E,aAAxE;AACA;AACD;;AAED,YAAMgB,cAAc,GAAGC,MAAM,CAACC,MAAP,CAAc;AAAEvE,UAAAA,OAAO,EAAEW,MAAM,CAACzB,WAAP,CAAmBc;AAA9B,SAAd,EAAuDW,MAAM,CAACpC,OAA9D,CAAvB;AACAK,QAAAA,MAAM,CAAC4F,OAAP,CAAe7D,MAAM,CAACtC,EAAtB,EAA0BsC,MAAM,CAACrC,GAAjC,EAAsC+F,cAAtC,EAAsDhB,aAAtD;AACD,OA1CM,CAAP;AA2CD;;;;EA1iBsBnG,Q;;AA6iBzB,IAAIC,QAAQ,CAACsH,cAAb,EAA6B;AAC3BtG,EAAAA,UAAU,CAACuG,SAAX,CAAqBC,MAAM,CAACC,aAA5B,IAA6ClI,OAAO,CAAC,yBAAD,CAAP,CAAmCkI,aAAhF;AACD;AAED;;;;;AAGA,SAASC,gBAAT,CAA0BC,IAA1B,EAAgChH,QAAhC,EAA0C;AACxC,MAAIgH,IAAI,CAACnG,IAAL,IAAamG,IAAI,CAACnG,IAAL,CAAUoG,WAAV,EAAjB,EAA0C;AACxCD,IAAAA,IAAI,CAAC5F,WAAL,CAAiBK,MAAjB,GAA0B,IAA1B;AACA,QAAMxB,GAAG,GAAG,IAAIlB,iBAAJ,8BACYiI,IAAI,CAACnG,IAAL,CAAUqG,IADtB,cAC8BF,IAAI,CAACnG,IAAL,CAAUsG,IADxC,oBAAZ;;AAIAC,IAAAA,sBAAsB,CAACJ,IAAD,EAAO;AAAA,aAAMhH,QAAQ,CAACC,GAAD,CAAd;AAAA,KAAP,CAAtB;;AACA,WAAO,IAAP;AACD;;AAED,SAAO,KAAP;AACD;AAED;;;;;AAGA,SAASoH,wBAAT,CAAkCL,IAAlC,EAAwChH,QAAxC,EAAkD;AAChD;AACA,MAAIgH,IAAI,CAAC5F,WAAL,CAAiBI,IAAjB,IAAyB,CAACwF,IAAI,CAAC5F,WAAL,CAAiBK,MAA/C,EAAuD;AACrDuF,IAAAA,IAAI,CAAC5F,WAAL,CAAiBK,MAAjB,GAA0B,IAA1B;AACA6D,IAAAA,iBAAiB,CAAC0B,IAAD,EAAOhH,QAAP,CAAjB;AACA,WAAO,IAAP;AACD;;AAED,SAAO,KAAP;AACD;AAED;;;;;AAGA,SAASsH,qBAAT,CAA+BN,IAA/B,EAAqChH,QAArC,EAA+C;AAC7C,MAAIgH,IAAI,CAAC5F,WAAL,CAAiBI,IAAjB,IAAyBwF,IAAI,CAAC5F,WAAL,CAAiBK,MAA9C,EAAsD;AACpD1B,IAAAA,cAAc,CAACC,QAAD,EAAW,IAAIlB,UAAJ,CAAe,gBAAf,CAAX,CAAd;AACA,WAAO,IAAP;AACD;;AAED,SAAO,KAAP;AACD;AAED;;;;;AAGA,SAASyI,cAAT,CAAwBP,IAAxB,EAA8BhH,QAA9B,EAAwC;AACtC,MAAIgH,IAAI,CAAC5F,WAAL,CAAiBK,MAArB,EAA6B;AAC3B6D,IAAAA,iBAAiB,CAAC0B,IAAD,EAAOhH,QAAP,CAAjB;AACA,WAAO,IAAP;AACD;;AAED,SAAO,KAAP;AACD;AAED;;;;;AAGA,SAASwH,wBAAT,CAAkCR,IAAlC,EAAwChH,QAAxC,EAAkD;AAChDgH,EAAAA,IAAI,CAAC5F,WAAL,CAAiBI,IAAjB,GAAwB,IAAxB;AACA8D,EAAAA,iBAAiB,CAAC0B,IAAD,EAAOhH,QAAP,CAAjB;AACD;AAED;;;;;AAGA,SAASsF,iBAAT,CAA2B0B,IAA3B,EAAiChH,QAAjC,EAA2C;AACzCoH,EAAAA,sBAAsB,CAACJ,IAAD,EAAO;AAAA,WAAMjH,cAAc,CAACC,QAAD,EAAW,IAAX,EAAiB,IAAjB,CAApB;AAAA,GAAP,CAAtB;AACD;;AAED,SAASoH,sBAAT,CAAgCJ,IAAhC,EAAsChH,QAAtC,EAAgD;AAC9CgH,EAAAA,IAAI,CAAC5F,WAAL,CAAiBO,QAAjB,GAA4B,IAA5B;AACAqF,EAAAA,IAAI,CAAC5F,WAAL,CAAiBE,SAAjB,GAA6B,EAA7B;AACA0F,EAAAA,IAAI,CAAC5F,WAAL,CAAiBG,WAAjB,GAA+B,CAA/B;;AAEA,MAAIyF,IAAI,CAAC5F,WAAL,CAAiBc,OAArB,EAA8B;AAC5B8E,IAAAA,IAAI,CAAClC,WAAL,CAAiB9E,QAAjB;;AACA;AACD;;AAED,SAAOA,QAAQ,EAAf;AACD;;AAED,SAAS4C,YAAT,CAAsBoE,IAAtB,EAA4BhH,QAA5B,EAAsC;AACpC;AACA,MAAIgH,IAAI,CAAC5F,WAAL,CAAiBO,QAArB,EAA+B;AAC7B,WAAO3B,QAAQ,CAAC,IAAIyH,KAAJ,CAAU,qBAAV,CAAD,CAAf;AACD,GAJmC,CAMpC;;;AACA,MAAIF,cAAc,CAACP,IAAD,EAAOhH,QAAP,CAAlB,EAAoC,OAPA,CASpC;;AACA,MAAIqH,wBAAwB,CAACL,IAAD,EAAOhH,QAAP,CAA5B,EAA8C,OAVV,CAYpC;;AACA,MAAIsH,qBAAqB,CAACN,IAAD,EAAOhH,QAAP,CAAzB,EAA2C,OAbP,CAepC;;AACA,MAAI,CAACgH,IAAI,CAAC5F,WAAL,CAAiBM,IAAtB,EAA4B;AAC1B;AACA;AACA,QAAI,CAACsF,IAAI,CAAC1G,QAAL,CAAcoH,WAAd,CAA0BV,IAAI,CAACvG,OAA/B,CAAL,EAA8C;AAC5C;AACA;AACA,UAAIuG,IAAI,CAAC1G,QAAL,CAAcqH,KAAd,KAAwB,QAAxB,IAAoC,CAACX,IAAI,CAAC1G,QAAL,CAAcW,CAAd,CAAgBR,OAAhB,CAAwB8B,SAAjE,EAA4E;AAC1E;AACA,eAAOvC,QAAQ,CAAC,IAAIlB,UAAJ,CAAe,yBAAf,CAAD,CAAf;AACD;;AAED,UAAIkI,IAAI,CAACjG,iBAAL,IAA0B,IAA9B,EAAoC;AAClC,YAAIiG,IAAI,CAAC1G,QAAL,CAAc2G,WAAd,EAAJ,EAAiC;AAC/B;AACA,iBAAOjH,QAAQ,CAAC,IAAIlB,UAAJ,CAAe,wBAAf,CAAD,CAAf;AACD;;AAEDkI,QAAAA,IAAI,CAACjG,iBAAL,CAAuBsF,kBAAvB,CAA0C,QAA1C,EAAoDW,IAApD,EAA0D,MAA1D,EAAkE,CAAChH,QAAD,CAAlE,EAA8EA,QAA9E;AACA;AACD;AACF;;AAEDgH,IAAAA,IAAI,CAAC9B,iBAAL,CAAuB,UAACjF,GAAD,EAAMC,MAAN,EAAiB;AACtC,UAAID,GAAG,IAAIC,MAAM,KAAK,IAAtB,EAA4B;AAC1BF,QAAAA,QAAQ,CAACC,GAAD,EAAMC,MAAN,CAAR;AACA;AACD;;AAED0C,MAAAA,YAAY,CAACoE,IAAD,EAAOhH,QAAP,CAAZ;AACD,KAPD;;AASA;AACD;;AAED,MAAIgH,IAAI,CAAC5F,WAAL,CAAiBQ,KAAjB,GAAyB,CAAzB,IAA8BoF,IAAI,CAAC5F,WAAL,CAAiBW,YAAjB,IAAiCiF,IAAI,CAAC5F,WAAL,CAAiBQ,KAApF,EAA2F;AACzF;AACAoF,IAAAA,IAAI,CAAC3D,IAAL,GAFyF,CAGzF;;AACA,WAAOmE,wBAAwB,CAACR,IAAD,EAAOhH,QAAP,CAA/B;AACD,GALD,MAKO,IACLgH,IAAI,CAAC5F,WAAL,CAAiBG,WAAjB,KAAiCyF,IAAI,CAAC5F,WAAL,CAAiBE,SAAjB,CAA2BwB,MAA5D,IACA,CAACrD,IAAI,CAACyG,IAAL,CAAU0B,MAAV,CAAiBZ,IAAI,CAAC5F,WAAL,CAAiBC,QAAlC,CAFI,EAGL;AACA;AACA2F,IAAAA,IAAI,CAAC5F,WAAL,CAAiBE,SAAjB,GAA6B,EAA7B;AACA0F,IAAAA,IAAI,CAAC5F,WAAL,CAAiBG,WAAjB,GAA+B,CAA/B,CAHA,CAKA;;AACA,QAAIyF,IAAI,CAAC1G,QAAL,CAAc2G,WAAd,EAAJ,EACE,OAAOjH,QAAQ,CACb,IAAIjB,iBAAJ,CAAsB,0DAAtB,CADa,CAAf,CAPF,CAWA;AACA;;AACA,QAAIgI,gBAAgB,CAACC,IAAD,EAAOhH,QAAP,CAApB,EAAsC,OAbtC,CAeA;;AACAgH,IAAAA,IAAI,CAACa,QAAL,CAAc,UAAS5H,GAAT,EAAckD,GAAd,EAAmB2E,UAAnB,EAA+B;AAC3C,UAAI7H,GAAJ,EAAS;AACP,eAAOF,cAAc,CAACC,QAAD,EAAWC,GAAX,CAArB;AACD,OAH0C,CAK3C;;;AACA+G,MAAAA,IAAI,CAACc,UAAL,GAAkBA,UAAlB,CAN2C,CAQ3C;AACA;AACA;;AACA,UACEd,IAAI,CAAC5F,WAAL,CAAiBE,SAAjB,CAA2BwB,MAA3B,KAAsC,CAAtC,IACAkE,IAAI,CAACxG,GAAL,CAAS4E,QADT,IAEA3F,IAAI,CAACyG,IAAL,CAAU0B,MAAV,CAAiBZ,IAAI,CAAC5F,WAAL,CAAiBC,QAAlC,CAHF,EAIE;AACA;AACA,eAAOtB,cAAc,CACnBC,QADmB,EAEnB,IAAIlB,UAAJ,CAAe;AACb2G,UAAAA,OAAO,EAAE,oCADI;AAEbL,UAAAA,QAAQ,EAAE4B,IAAI,CAACxG,GAAL,CAAS4E,QAFN;AAGbC,UAAAA,SAAS,EAAE2B,IAAI,CAACxG,GAAL,CAAS6E;AAHP,SAAf,CAFmB,CAArB;AAQD,OAdD,MAcO,IACL2B,IAAI,CAAC5F,WAAL,CAAiBE,SAAjB,CAA2BwB,MAA3B,KAAsC,CAAtC,IACAkE,IAAI,CAACxG,GAAL,CAAS4E,QADT,IAEA,CAAC3F,IAAI,CAACyG,IAAL,CAAU0B,MAAV,CAAiBZ,IAAI,CAAC5F,WAAL,CAAiBC,QAAlC,CAHI,EAIL;AACA,eAAOuB,YAAY,CAACoE,IAAD,EAAOhH,QAAP,CAAnB;AACD;;AAED,UAAIgH,IAAI,CAAC5F,WAAL,CAAiBQ,KAAjB,GAAyB,CAAzB,IAA8BoF,IAAI,CAAC5F,WAAL,CAAiBW,YAAjB,IAAiCiF,IAAI,CAAC5F,WAAL,CAAiBQ,KAApF,EAA2F;AACzF,eAAO4F,wBAAwB,CAACR,IAAD,EAAOhH,QAAP,CAA/B;AACD;;AAED4C,MAAAA,YAAY,CAACoE,IAAD,EAAOhH,QAAP,CAAZ;AACD,KAtCD;AAuCD,GA1DM,MA0DA,IACLgH,IAAI,CAAC5F,WAAL,CAAiBE,SAAjB,CAA2BwB,MAA3B,KAAsCkE,IAAI,CAAC5F,WAAL,CAAiBG,WAAvD,IACAyF,IAAI,CAACxG,GAAL,CAAS4E,QADT,IAEA3F,IAAI,CAACyG,IAAL,CAAU0B,MAAV,CAAiBZ,IAAI,CAAC5F,WAAL,CAAiBC,QAAlC,CAHK,EAIL;AACA,WAAOtB,cAAc,CACnBC,QADmB,EAEnB,IAAIlB,UAAJ,CAAe;AACb2G,MAAAA,OAAO,EAAE,oCADI;AAEbL,MAAAA,QAAQ,EAAE4B,IAAI,CAACxG,GAAL,CAAS4E,QAFN;AAGbC,MAAAA,SAAS,EAAE2B,IAAI,CAACxG,GAAL,CAAS6E;AAHP,KAAf,CAFmB,CAArB;AAQD,GAbM,MAaA,IACL2B,IAAI,CAAC5F,WAAL,CAAiBE,SAAjB,CAA2BwB,MAA3B,KAAsCkE,IAAI,CAAC5F,WAAL,CAAiBG,WAAvD,IACA9B,IAAI,CAACyG,IAAL,CAAU0B,MAAV,CAAiBZ,IAAI,CAAC5F,WAAL,CAAiBC,QAAlC,CAFK,EAGL;AACAmG,IAAAA,wBAAwB,CAACR,IAAD,EAAOhH,QAAP,CAAxB;AACD,GALM,MAKA;AACL,QAAIgH,IAAI,CAAC5F,WAAL,CAAiBQ,KAAjB,GAAyB,CAAzB,IAA8BoF,IAAI,CAAC5F,WAAL,CAAiBW,YAAjB,IAAiCiF,IAAI,CAAC5F,WAAL,CAAiBQ,KAApF,EAA2F;AACzF;AACAoF,MAAAA,IAAI,CAAC3D,IAAL,GAFyF,CAGzF;;AACA,aAAOmE,wBAAwB,CAACR,IAAD,EAAOhH,QAAP,CAA/B;AACD,KANI,CAQL;;;AACAgH,IAAAA,IAAI,CAAC5F,WAAL,CAAiBW,YAAjB,IAAiC,CAAjC,CATK,CAWL;;AACA,QAAIoB,GAAG,GAAG6D,IAAI,CAAC5F,WAAL,CAAiBE,SAAjB,CAA2B0F,IAAI,CAAC5F,WAAL,CAAiBG,WAAjB,EAA3B,CAAV,CAZK,CAcL;;AACA,QAAI,CAAC4B,GAAD,IAAQA,GAAG,CAAC4E,IAAhB,EAAsB;AACpB;AACAf,MAAAA,IAAI,CAAC3D,IAAL,GAFoB,CAGpB;;AACA,aAAOmE,wBAAwB,CAACR,IAAD,EAAO,YAAW;AAC/CjH,QAAAA,cAAc,CAACC,QAAD,EAAW,IAAIlB,UAAJ,CAAeqE,GAAG,GAAGA,GAAG,CAAC4E,IAAP,GAAc3D,SAAhC,CAAX,CAAd;AACD,OAF8B,CAA/B;AAGD,KAtBI,CAwBL;;;AACA,QAAI4C,IAAI,CAAC5F,WAAL,CAAiBY,UAAjB,IAA+B,OAAOgF,IAAI,CAAC5F,WAAL,CAAiBY,UAAjB,CAA4BmB,GAAnC,KAA2C,UAA9E,EAA0F;AACxFA,MAAAA,GAAG,GAAG6D,IAAI,CAAC5F,WAAL,CAAiBY,UAAjB,CAA4BmB,GAA5B,CAAgCA,GAAhC,CAAN;AACD,KA3BI,CA6BL;;;AACApD,IAAAA,cAAc,CAACC,QAAD,EAAW,IAAX,EAAiBmD,GAAjB,CAAd;AACD;AACF;;AAED6E,MAAM,CAACC,OAAP,GAAiB;AACfvI,EAAAA,WAAW,EAAXA,WADe;AAEfW,EAAAA,UAAU,EAAVA;AAFe,CAAjB","sourcesContent":["'use strict';\n\nconst Logger = require('./connection/logger');\nconst retrieveBSON = require('./connection/utils').retrieveBSON;\nconst MongoError = require('./error').MongoError;\nconst MongoNetworkError = require('./error').MongoNetworkError;\nconst collationNotSupported = require('./utils').collationNotSupported;\nconst ReadPreference = require('./topologies/read_preference');\nconst isUnifiedTopology = require('./utils').isUnifiedTopology;\nconst executeOperation = require('../operations/execute_operation');\nconst Readable = require('stream').Readable;\nconst SUPPORTS = require('../utils').SUPPORTS;\nconst MongoDBNamespace = require('../utils').MongoDBNamespace;\nconst OperationBase = require('../operations/operation').OperationBase;\n\nconst BSON = retrieveBSON();\nconst Long = BSON.Long;\n\n// Possible states for a cursor\nconst CursorState = {\n  INIT: 0,\n  OPEN: 1,\n  CLOSED: 2,\n  GET_MORE: 3\n};\n\n//\n// Handle callback (including any exceptions thrown)\nfunction handleCallback(callback, err, result) {\n  try {\n    callback(err, result);\n  } catch (err) {\n    process.nextTick(function() {\n      throw err;\n    });\n  }\n}\n\n/**\n * This is a cursor results callback\n *\n * @callback resultCallback\n * @param {error} error An error object. Set to null if no error present\n * @param {object} document\n */\n\n/**\n * @fileOverview The **Cursor** class is an internal class that embodies a cursor on MongoDB\n * allowing for iteration over the results returned from the underlying query.\n *\n * **CURSORS Cannot directly be instantiated**\n */\n\n/**\n * The core cursor class. All cursors in the driver build off of this one.\n *\n * @property {number} cursorBatchSize The current cursorBatchSize for the cursor\n * @property {number} cursorLimit The current cursorLimit for the cursor\n * @property {number} cursorSkip The current cursorSkip for the cursor\n */\nclass CoreCursor extends Readable {\n  /**\n   * Create a new core `Cursor` instance.\n   * **NOTE** Not to be instantiated directly\n   *\n   * @param {object} topology The server topology instance.\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {{object}|Long} cmd The selector (can be a command or a cursorId)\n   * @param {object} [options=null] Optional settings.\n   * @param {object} [options.batchSize=1000] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find/| find command documentation} and {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n   * @param {array} [options.documents=[]] Initial documents list for cursor\n   * @param {object} [options.transforms=null] Transform methods for the cursor results\n   * @param {function} [options.transforms.query] Transform the value returned from the initial query\n   * @param {function} [options.transforms.doc] Transform each document returned from Cursor.prototype._next\n   */\n  constructor(topology, ns, cmd, options) {\n    super({ objectMode: true });\n    options = options || {};\n\n    if (ns instanceof OperationBase) {\n      this.operation = ns;\n      ns = this.operation.ns.toString();\n      options = this.operation.options;\n      cmd = this.operation.cmd ? this.operation.cmd : {};\n    }\n\n    // Cursor pool\n    this.pool = null;\n    // Cursor server\n    this.server = null;\n\n    // Do we have a not connected handler\n    this.disconnectHandler = options.disconnectHandler;\n\n    // Set local values\n    this.bson = topology.s.bson;\n    this.ns = ns;\n    this.namespace = MongoDBNamespace.fromString(ns);\n    this.cmd = cmd;\n    this.options = options;\n    this.topology = topology;\n\n    // All internal state\n    this.cursorState = {\n      cursorId: null,\n      cmd,\n      documents: options.documents || [],\n      cursorIndex: 0,\n      dead: false,\n      killed: false,\n      init: false,\n      notified: false,\n      limit: options.limit || cmd.limit || 0,\n      skip: options.skip || cmd.skip || 0,\n      batchSize: options.batchSize || cmd.batchSize || 1000,\n      currentLimit: 0,\n      // Result field name if not a cursor (contains the array of results)\n      transforms: options.transforms,\n      raw: options.raw || (cmd && cmd.raw)\n    };\n\n    if (typeof options.session === 'object') {\n      this.cursorState.session = options.session;\n    }\n\n    // Add promoteLong to cursor state\n    const topologyOptions = topology.s.options;\n    if (typeof topologyOptions.promoteLongs === 'boolean') {\n      this.cursorState.promoteLongs = topologyOptions.promoteLongs;\n    } else if (typeof options.promoteLongs === 'boolean') {\n      this.cursorState.promoteLongs = options.promoteLongs;\n    }\n\n    // Add promoteValues to cursor state\n    if (typeof topologyOptions.promoteValues === 'boolean') {\n      this.cursorState.promoteValues = topologyOptions.promoteValues;\n    } else if (typeof options.promoteValues === 'boolean') {\n      this.cursorState.promoteValues = options.promoteValues;\n    }\n\n    // Add promoteBuffers to cursor state\n    if (typeof topologyOptions.promoteBuffers === 'boolean') {\n      this.cursorState.promoteBuffers = topologyOptions.promoteBuffers;\n    } else if (typeof options.promoteBuffers === 'boolean') {\n      this.cursorState.promoteBuffers = options.promoteBuffers;\n    }\n\n    if (topologyOptions.reconnect) {\n      this.cursorState.reconnect = topologyOptions.reconnect;\n    }\n\n    // Logger\n    this.logger = Logger('Cursor', topologyOptions);\n\n    //\n    // Did we pass in a cursor id\n    if (typeof cmd === 'number') {\n      this.cursorState.cursorId = Long.fromNumber(cmd);\n      this.cursorState.lastCursorId = this.cursorState.cursorId;\n    } else if (cmd instanceof Long) {\n      this.cursorState.cursorId = cmd;\n      this.cursorState.lastCursorId = cmd;\n    }\n\n    // TODO: remove as part of NODE-2104\n    if (this.operation) {\n      this.operation.cursorState = this.cursorState;\n    }\n  }\n\n  setCursorBatchSize(value) {\n    this.cursorState.batchSize = value;\n  }\n\n  cursorBatchSize() {\n    return this.cursorState.batchSize;\n  }\n\n  setCursorLimit(value) {\n    this.cursorState.limit = value;\n  }\n\n  cursorLimit() {\n    return this.cursorState.limit;\n  }\n\n  setCursorSkip(value) {\n    this.cursorState.skip = value;\n  }\n\n  cursorSkip() {\n    return this.cursorState.skip;\n  }\n\n  /**\n   * Retrieve the next document from the cursor\n   * @method\n   * @param {resultCallback} callback A callback function\n   */\n  _next(callback) {\n    nextFunction(this, callback);\n  }\n\n  /**\n   * Clone the cursor\n   * @method\n   * @return {Cursor}\n   */\n  clone() {\n    return this.topology.cursor(this.ns, this.cmd, this.options);\n  }\n\n  /**\n   * Checks if the cursor is dead\n   * @method\n   * @return {boolean} A boolean signifying if the cursor is dead or not\n   */\n  isDead() {\n    return this.cursorState.dead === true;\n  }\n\n  /**\n   * Checks if the cursor was killed by the application\n   * @method\n   * @return {boolean} A boolean signifying if the cursor was killed by the application\n   */\n  isKilled() {\n    return this.cursorState.killed === true;\n  }\n\n  /**\n   * Checks if the cursor notified it's caller about it's death\n   * @method\n   * @return {boolean} A boolean signifying if the cursor notified the callback\n   */\n  isNotified() {\n    return this.cursorState.notified === true;\n  }\n\n  /**\n   * Returns current buffered documents length\n   * @method\n   * @return {number} The number of items in the buffered documents\n   */\n  bufferedCount() {\n    return this.cursorState.documents.length - this.cursorState.cursorIndex;\n  }\n\n  /**\n   * Returns current buffered documents\n   * @method\n   * @return {Array} An array of buffered documents\n   */\n  readBufferedDocuments(number) {\n    const unreadDocumentsLength = this.cursorState.documents.length - this.cursorState.cursorIndex;\n    const length = number < unreadDocumentsLength ? number : unreadDocumentsLength;\n    let elements = this.cursorState.documents.slice(\n      this.cursorState.cursorIndex,\n      this.cursorState.cursorIndex + length\n    );\n\n    // Transform the doc with passed in transformation method if provided\n    if (this.cursorState.transforms && typeof this.cursorState.transforms.doc === 'function') {\n      // Transform all the elements\n      for (let i = 0; i < elements.length; i++) {\n        elements[i] = this.cursorState.transforms.doc(elements[i]);\n      }\n    }\n\n    // Ensure we do not return any more documents than the limit imposed\n    // Just return the number of elements up to the limit\n    if (\n      this.cursorState.limit > 0 &&\n      this.cursorState.currentLimit + elements.length > this.cursorState.limit\n    ) {\n      elements = elements.slice(0, this.cursorState.limit - this.cursorState.currentLimit);\n      this.kill();\n    }\n\n    // Adjust current limit\n    this.cursorState.currentLimit = this.cursorState.currentLimit + elements.length;\n    this.cursorState.cursorIndex = this.cursorState.cursorIndex + elements.length;\n\n    // Return elements\n    return elements;\n  }\n\n  /**\n   * Resets local state for this cursor instance, and issues a `killCursors` command to the server\n   *\n   * @param {resultCallback} callback A callback function\n   */\n  kill(callback) {\n    // Set cursor to dead\n    this.cursorState.dead = true;\n    this.cursorState.killed = true;\n    // Remove documents\n    this.cursorState.documents = [];\n\n    // If no cursor id just return\n    if (\n      this.cursorState.cursorId == null ||\n      this.cursorState.cursorId.isZero() ||\n      this.cursorState.init === false\n    ) {\n      if (callback) callback(null, null);\n      return;\n    }\n\n    this.server.killCursors(this.ns, this.cursorState, callback);\n  }\n\n  /**\n   * Resets the cursor\n   */\n  rewind() {\n    if (this.cursorState.init) {\n      if (!this.cursorState.dead) {\n        this.kill();\n      }\n\n      this.cursorState.currentLimit = 0;\n      this.cursorState.init = false;\n      this.cursorState.dead = false;\n      this.cursorState.killed = false;\n      this.cursorState.notified = false;\n      this.cursorState.documents = [];\n      this.cursorState.cursorId = null;\n      this.cursorState.cursorIndex = 0;\n    }\n  }\n\n  // Internal methods\n  _read() {\n    if ((this.s && this.s.state === CursorState.CLOSED) || this.isDead()) {\n      return this.push(null);\n    }\n\n    // Get the next item\n    this._next((err, result) => {\n      if (err) {\n        if (this.listeners('error') && this.listeners('error').length > 0) {\n          this.emit('error', err);\n        }\n        if (!this.isDead()) this.close();\n\n        // Emit end event\n        this.emit('end');\n        return this.emit('finish');\n      }\n\n      // If we provided a transformation method\n      if (\n        this.cursorState.streamOptions &&\n        typeof this.cursorState.streamOptions.transform === 'function' &&\n        result != null\n      ) {\n        return this.push(this.cursorState.streamOptions.transform(result));\n      }\n\n      // Return the result\n      this.push(result);\n\n      if (result === null && this.isDead()) {\n        this.once('end', () => {\n          this.close();\n          this.emit('finish');\n        });\n      }\n    });\n  }\n\n  _endSession(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    options = options || {};\n\n    const session = this.cursorState.session;\n\n    if (session && (options.force || session.owner === this)) {\n      this.cursorState.session = undefined;\n\n      if (this.operation) {\n        this.operation.clearSession();\n      }\n\n      session.endSession(callback);\n      return true;\n    }\n\n    if (callback) {\n      callback();\n    }\n\n    return false;\n  }\n\n  _getMore(callback) {\n    if (this.logger.isDebug()) {\n      this.logger.debug(`schedule getMore call for query [${JSON.stringify(this.query)}]`);\n    }\n\n    // Set the current batchSize\n    let batchSize = this.cursorState.batchSize;\n    if (\n      this.cursorState.limit > 0 &&\n      this.cursorState.currentLimit + batchSize > this.cursorState.limit\n    ) {\n      batchSize = this.cursorState.limit - this.cursorState.currentLimit;\n    }\n\n    const cursorState = this.cursorState;\n    this.server.getMore(this.ns, cursorState, batchSize, this.options, (err, result, conn) => {\n      // NOTE: `getMore` modifies `cursorState`, would be very ideal not to do so in the future\n      if (err || (cursorState.cursorId && cursorState.cursorId.isZero())) {\n        this._endSession();\n      }\n\n      callback(err, result, conn);\n    });\n  }\n\n  _initializeCursor(callback) {\n    const cursor = this;\n\n    // NOTE: this goes away once cursors use `executeOperation`\n    if (isUnifiedTopology(cursor.topology) && cursor.topology.shouldCheckForSessionSupport()) {\n      cursor.topology.selectServer(ReadPreference.primaryPreferred, err => {\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        this._initializeCursor(callback);\n      });\n\n      return;\n    }\n\n    function done(err, result) {\n      const cursorState = cursor.cursorState;\n      if (err || (cursorState.cursorId && cursorState.cursorId.isZero())) {\n        cursor._endSession();\n      }\n\n      if (\n        cursorState.documents.length === 0 &&\n        cursorState.cursorId &&\n        cursorState.cursorId.isZero() &&\n        !cursor.cmd.tailable &&\n        !cursor.cmd.awaitData\n      ) {\n        return setCursorNotified(cursor, callback);\n      }\n\n      callback(err, result);\n    }\n\n    const queryCallback = (err, r) => {\n      if (err) {\n        return done(err);\n      }\n\n      const result = r.message;\n      if (result.queryFailure) {\n        return done(new MongoError(result.documents[0]), null);\n      }\n\n      // Check if we have a command cursor\n      if (\n        Array.isArray(result.documents) &&\n        result.documents.length === 1 &&\n        (!cursor.cmd.find || (cursor.cmd.find && cursor.cmd.virtual === false)) &&\n        (typeof result.documents[0].cursor !== 'string' ||\n          result.documents[0]['$err'] ||\n          result.documents[0]['errmsg'] ||\n          Array.isArray(result.documents[0].result))\n      ) {\n        // We have an error document, return the error\n        if (result.documents[0]['$err'] || result.documents[0]['errmsg']) {\n          return done(new MongoError(result.documents[0]), null);\n        }\n\n        // We have a cursor document\n        if (result.documents[0].cursor != null && typeof result.documents[0].cursor !== 'string') {\n          const id = result.documents[0].cursor.id;\n          // If we have a namespace change set the new namespace for getmores\n          if (result.documents[0].cursor.ns) {\n            cursor.ns = result.documents[0].cursor.ns;\n          }\n          // Promote id to long if needed\n          cursor.cursorState.cursorId = typeof id === 'number' ? Long.fromNumber(id) : id;\n          cursor.cursorState.lastCursorId = cursor.cursorState.cursorId;\n          cursor.cursorState.operationTime = result.documents[0].operationTime;\n\n          // If we have a firstBatch set it\n          if (Array.isArray(result.documents[0].cursor.firstBatch)) {\n            cursor.cursorState.documents = result.documents[0].cursor.firstBatch; //.reverse();\n          }\n\n          // Return after processing command cursor\n          return done(null, result);\n        }\n\n        if (Array.isArray(result.documents[0].result)) {\n          cursor.cursorState.documents = result.documents[0].result;\n          cursor.cursorState.cursorId = Long.ZERO;\n          return done(null, result);\n        }\n      }\n\n      // Otherwise fall back to regular find path\n      const cursorId = result.cursorId || 0;\n      cursor.cursorState.cursorId = cursorId instanceof Long ? cursorId : Long.fromNumber(cursorId);\n      cursor.cursorState.documents = result.documents;\n      cursor.cursorState.lastCursorId = result.cursorId;\n\n      // Transform the results with passed in transformation method if provided\n      if (\n        cursor.cursorState.transforms &&\n        typeof cursor.cursorState.transforms.query === 'function'\n      ) {\n        cursor.cursorState.documents = cursor.cursorState.transforms.query(result);\n      }\n\n      done(null, result);\n    };\n\n    if (cursor.operation) {\n      if (cursor.logger.isDebug()) {\n        cursor.logger.debug(\n          `issue initial query [${JSON.stringify(cursor.cmd)}] with flags [${JSON.stringify(\n            cursor.query\n          )}]`\n        );\n      }\n\n      executeOperation(cursor.topology, cursor.operation, (err, result) => {\n        if (err) {\n          done(err);\n          return;\n        }\n\n        cursor.server = cursor.operation.server;\n        cursor.cursorState.init = true;\n\n        // NOTE: this is a special internal method for cloning a cursor, consider removing\n        if (cursor.cursorState.cursorId != null) {\n          return done();\n        }\n\n        queryCallback(err, result);\n      });\n\n      return;\n    }\n\n    // Very explicitly choose what is passed to selectServer\n    const serverSelectOptions = {};\n    if (cursor.cursorState.session) {\n      serverSelectOptions.session = cursor.cursorState.session;\n    }\n\n    if (cursor.operation) {\n      serverSelectOptions.readPreference = cursor.operation.readPreference;\n    } else if (cursor.options.readPreference) {\n      serverSelectOptions.readPreference = cursor.options.readPreference;\n    }\n\n    return cursor.topology.selectServer(serverSelectOptions, (err, server) => {\n      if (err) {\n        const disconnectHandler = cursor.disconnectHandler;\n        if (disconnectHandler != null) {\n          return disconnectHandler.addObjectAndMethod(\n            'cursor',\n            cursor,\n            'next',\n            [callback],\n            callback\n          );\n        }\n\n        return callback(err);\n      }\n\n      cursor.server = server;\n      cursor.cursorState.init = true;\n      if (collationNotSupported(cursor.server, cursor.cmd)) {\n        return callback(new MongoError(`server ${cursor.server.name} does not support collation`));\n      }\n\n      // NOTE: this is a special internal method for cloning a cursor, consider removing\n      if (cursor.cursorState.cursorId != null) {\n        return done();\n      }\n\n      if (cursor.logger.isDebug()) {\n        cursor.logger.debug(\n          `issue initial query [${JSON.stringify(cursor.cmd)}] with flags [${JSON.stringify(\n            cursor.query\n          )}]`\n        );\n      }\n\n      if (cursor.cmd.find != null) {\n        server.query(cursor.ns, cursor.cmd, cursor.cursorState, cursor.options, queryCallback);\n        return;\n      }\n\n      const commandOptions = Object.assign({ session: cursor.cursorState.session }, cursor.options);\n      server.command(cursor.ns, cursor.cmd, commandOptions, queryCallback);\n    });\n  }\n}\n\nif (SUPPORTS.ASYNC_ITERATOR) {\n  CoreCursor.prototype[Symbol.asyncIterator] = require('../async/async_iterator').asyncIterator;\n}\n\n/**\n * Validate if the pool is dead and return error\n */\nfunction isConnectionDead(self, callback) {\n  if (self.pool && self.pool.isDestroyed()) {\n    self.cursorState.killed = true;\n    const err = new MongoNetworkError(\n      `connection to host ${self.pool.host}:${self.pool.port} was destroyed`\n    );\n\n    _setCursorNotifiedImpl(self, () => callback(err));\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Validate if the cursor is dead but was not explicitly killed by user\n */\nfunction isCursorDeadButNotkilled(self, callback) {\n  // Cursor is dead but not marked killed, return null\n  if (self.cursorState.dead && !self.cursorState.killed) {\n    self.cursorState.killed = true;\n    setCursorNotified(self, callback);\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Validate if the cursor is dead and was killed by user\n */\nfunction isCursorDeadAndKilled(self, callback) {\n  if (self.cursorState.dead && self.cursorState.killed) {\n    handleCallback(callback, new MongoError('cursor is dead'));\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Validate if the cursor was killed by the user\n */\nfunction isCursorKilled(self, callback) {\n  if (self.cursorState.killed) {\n    setCursorNotified(self, callback);\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Mark cursor as being dead and notified\n */\nfunction setCursorDeadAndNotified(self, callback) {\n  self.cursorState.dead = true;\n  setCursorNotified(self, callback);\n}\n\n/**\n * Mark cursor as being notified\n */\nfunction setCursorNotified(self, callback) {\n  _setCursorNotifiedImpl(self, () => handleCallback(callback, null, null));\n}\n\nfunction _setCursorNotifiedImpl(self, callback) {\n  self.cursorState.notified = true;\n  self.cursorState.documents = [];\n  self.cursorState.cursorIndex = 0;\n\n  if (self.cursorState.session) {\n    self._endSession(callback);\n    return;\n  }\n\n  return callback();\n}\n\nfunction nextFunction(self, callback) {\n  // We have notified about it\n  if (self.cursorState.notified) {\n    return callback(new Error('cursor is exhausted'));\n  }\n\n  // Cursor is killed return null\n  if (isCursorKilled(self, callback)) return;\n\n  // Cursor is dead but not marked killed, return null\n  if (isCursorDeadButNotkilled(self, callback)) return;\n\n  // We have a dead and killed cursor, attempting to call next should error\n  if (isCursorDeadAndKilled(self, callback)) return;\n\n  // We have just started the cursor\n  if (!self.cursorState.init) {\n    // Topology is not connected, save the call in the provided store to be\n    // Executed at some point when the handler deems it's reconnected\n    if (!self.topology.isConnected(self.options)) {\n      // Only need this for single server, because repl sets and mongos\n      // will always continue trying to reconnect\n      if (self.topology._type === 'server' && !self.topology.s.options.reconnect) {\n        // Reconnect is disabled, so we'll never reconnect\n        return callback(new MongoError('no connection available'));\n      }\n\n      if (self.disconnectHandler != null) {\n        if (self.topology.isDestroyed()) {\n          // Topology was destroyed, so don't try to wait for it to reconnect\n          return callback(new MongoError('Topology was destroyed'));\n        }\n\n        self.disconnectHandler.addObjectAndMethod('cursor', self, 'next', [callback], callback);\n        return;\n      }\n    }\n\n    self._initializeCursor((err, result) => {\n      if (err || result === null) {\n        callback(err, result);\n        return;\n      }\n\n      nextFunction(self, callback);\n    });\n\n    return;\n  }\n\n  if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {\n    // Ensure we kill the cursor on the server\n    self.kill();\n    // Set cursor in dead and notified state\n    return setCursorDeadAndNotified(self, callback);\n  } else if (\n    self.cursorState.cursorIndex === self.cursorState.documents.length &&\n    !Long.ZERO.equals(self.cursorState.cursorId)\n  ) {\n    // Ensure an empty cursor state\n    self.cursorState.documents = [];\n    self.cursorState.cursorIndex = 0;\n\n    // Check if topology is destroyed\n    if (self.topology.isDestroyed())\n      return callback(\n        new MongoNetworkError('connection destroyed, not possible to instantiate cursor')\n      );\n\n    // Check if connection is dead and return if not possible to\n    // execute a getMore on this connection\n    if (isConnectionDead(self, callback)) return;\n\n    // Execute the next get more\n    self._getMore(function(err, doc, connection) {\n      if (err) {\n        return handleCallback(callback, err);\n      }\n\n      // Save the returned connection to ensure all getMore's fire over the same connection\n      self.connection = connection;\n\n      // Tailable cursor getMore result, notify owner about it\n      // No attempt is made here to retry, this is left to the user of the\n      // core module to handle to keep core simple\n      if (\n        self.cursorState.documents.length === 0 &&\n        self.cmd.tailable &&\n        Long.ZERO.equals(self.cursorState.cursorId)\n      ) {\n        // No more documents in the tailed cursor\n        return handleCallback(\n          callback,\n          new MongoError({\n            message: 'No more documents in tailed cursor',\n            tailable: self.cmd.tailable,\n            awaitData: self.cmd.awaitData\n          })\n        );\n      } else if (\n        self.cursorState.documents.length === 0 &&\n        self.cmd.tailable &&\n        !Long.ZERO.equals(self.cursorState.cursorId)\n      ) {\n        return nextFunction(self, callback);\n      }\n\n      if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {\n        return setCursorDeadAndNotified(self, callback);\n      }\n\n      nextFunction(self, callback);\n    });\n  } else if (\n    self.cursorState.documents.length === self.cursorState.cursorIndex &&\n    self.cmd.tailable &&\n    Long.ZERO.equals(self.cursorState.cursorId)\n  ) {\n    return handleCallback(\n      callback,\n      new MongoError({\n        message: 'No more documents in tailed cursor',\n        tailable: self.cmd.tailable,\n        awaitData: self.cmd.awaitData\n      })\n    );\n  } else if (\n    self.cursorState.documents.length === self.cursorState.cursorIndex &&\n    Long.ZERO.equals(self.cursorState.cursorId)\n  ) {\n    setCursorDeadAndNotified(self, callback);\n  } else {\n    if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {\n      // Ensure we kill the cursor on the server\n      self.kill();\n      // Set cursor in dead and notified state\n      return setCursorDeadAndNotified(self, callback);\n    }\n\n    // Increment the current cursor limit\n    self.cursorState.currentLimit += 1;\n\n    // Get the document\n    let doc = self.cursorState.documents[self.cursorState.cursorIndex++];\n\n    // Doc overflow\n    if (!doc || doc.$err) {\n      // Ensure we kill the cursor on the server\n      self.kill();\n      // Set cursor in dead and notified state\n      return setCursorDeadAndNotified(self, function() {\n        handleCallback(callback, new MongoError(doc ? doc.$err : undefined));\n      });\n    }\n\n    // Transform the doc with passed in transformation method if provided\n    if (self.cursorState.transforms && typeof self.cursorState.transforms.doc === 'function') {\n      doc = self.cursorState.transforms.doc(doc);\n    }\n\n    // Return the document\n    handleCallback(callback, null, doc);\n  }\n}\n\nmodule.exports = {\n  CursorState,\n  CoreCursor\n};\n"]},"metadata":{},"sourceType":"script"}