{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar ReadPreference = require('./core').ReadPreference;\n\nvar MongoError = require('./core').MongoError;\n\nvar Cursor = require('./cursor');\n\nvar CursorState = require('./core/cursor').CursorState;\n/**\n * @fileOverview The **CommandCursor** class is an internal class that embodies a\n * generalized cursor based on a MongoDB command allowing for iteration over the\n * results returned. It supports one by one document iteration, conversion to an\n * array or can be iterated as a Node 0.10.X or higher stream\n *\n * **CommandCursor Cannot directly be instantiated**\n * @example\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, client) {\n *   // Create a collection we want to drop later\n *   const col = client.db(dbName).collection('listCollectionsExample1');\n *   // Insert a bunch of documents\n *   col.insert([{a:1, b:1}\n *     , {a:2, b:2}, {a:3, b:3}\n *     , {a:4, b:4}], {w:1}, function(err, result) {\n *     test.equal(null, err);\n *     // List the database collections available\n *     db.listCollections().toArray(function(err, items) {\n *       test.equal(null, err);\n *       client.close();\n *     });\n *   });\n * });\n */\n\n/**\n * Namespace provided by the browser.\n * @external Readable\n */\n\n/**\n * Creates a new Command Cursor instance (INTERNAL TYPE, do not instantiate directly)\n * @class CommandCursor\n * @extends external:Readable\n * @fires CommandCursor#data\n * @fires CommandCursor#end\n * @fires CommandCursor#close\n * @fires CommandCursor#readable\n * @return {CommandCursor} an CommandCursor instance.\n */\n\n\nvar CommandCursor = /*#__PURE__*/function (_Cursor) {\n  _inherits(CommandCursor, _Cursor);\n\n  var _super = _createSuper(CommandCursor);\n\n  function CommandCursor(topology, ns, cmd, options) {\n    _classCallCheck(this, CommandCursor);\n\n    return _super.call(this, topology, ns, cmd, options);\n  }\n  /**\n   * Set the ReadPreference for the cursor.\n   * @method\n   * @param {(string|ReadPreference)} readPreference The new read preference for the cursor.\n   * @throws {MongoError}\n   * @return {Cursor}\n   */\n\n\n  _createClass(CommandCursor, [{\n    key: \"setReadPreference\",\n    value: function setReadPreference(readPreference) {\n      if (this.s.state === CursorState.CLOSED || this.isDead()) {\n        throw MongoError.create({\n          message: 'Cursor is closed',\n          driver: true\n        });\n      }\n\n      if (this.s.state !== CursorState.INIT) {\n        throw MongoError.create({\n          message: 'cannot change cursor readPreference after cursor has been accessed',\n          driver: true\n        });\n      }\n\n      if (readPreference instanceof ReadPreference) {\n        this.options.readPreference = readPreference;\n      } else if (typeof readPreference === 'string') {\n        this.options.readPreference = new ReadPreference(readPreference);\n      } else {\n        throw new TypeError('Invalid read preference: ' + readPreference);\n      }\n\n      return this;\n    }\n    /**\n     * Set the batch size for the cursor.\n     * @method\n     * @param {number} value The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find/|find command documentation}.\n     * @throws {MongoError}\n     * @return {CommandCursor}\n     */\n\n  }, {\n    key: \"batchSize\",\n    value: function batchSize(value) {\n      if (this.s.state === CursorState.CLOSED || this.isDead()) {\n        throw MongoError.create({\n          message: 'Cursor is closed',\n          driver: true\n        });\n      }\n\n      if (typeof value !== 'number') {\n        throw MongoError.create({\n          message: 'batchSize requires an integer',\n          driver: true\n        });\n      }\n\n      if (this.cmd.cursor) {\n        this.cmd.cursor.batchSize = value;\n      }\n\n      this.setCursorBatchSize(value);\n      return this;\n    }\n    /**\n     * Add a maxTimeMS stage to the aggregation pipeline\n     * @method\n     * @param {number} value The state maxTimeMS value.\n     * @return {CommandCursor}\n     */\n\n  }, {\n    key: \"maxTimeMS\",\n    value: function maxTimeMS(value) {\n      if (this.topology.lastIsMaster().minWireVersion > 2) {\n        this.cmd.maxTimeMS = value;\n      }\n\n      return this;\n    }\n    /**\n     * Return the cursor logger\n     * @method\n     * @return {Logger} return the cursor logger\n     * @ignore\n     */\n\n  }, {\n    key: \"getLogger\",\n    value: function getLogger() {\n      return this.logger;\n    }\n  }]);\n\n  return CommandCursor;\n}(Cursor); // aliases\n\n\nCommandCursor.prototype.get = CommandCursor.prototype.toArray;\n/**\n * CommandCursor stream data event, fired for each document in the cursor.\n *\n * @event CommandCursor#data\n * @type {object}\n */\n\n/**\n * CommandCursor stream end event\n *\n * @event CommandCursor#end\n * @type {null}\n */\n\n/**\n * CommandCursor stream close event\n *\n * @event CommandCursor#close\n * @type {null}\n */\n\n/**\n * CommandCursor stream readable event\n *\n * @event CommandCursor#readable\n * @type {null}\n */\n\n/**\n * Get the next available document from the cursor, returns null if no more documents are available.\n * @function CommandCursor.prototype.next\n * @param {CommandCursor~resultCallback} [callback] The result callback.\n * @throws {MongoError}\n * @return {Promise} returns Promise if no callback passed\n */\n\n/**\n * Check if there is any document still available in the cursor\n * @function CommandCursor.prototype.hasNext\n * @param {CommandCursor~resultCallback} [callback] The result callback.\n * @throws {MongoError}\n * @return {Promise} returns Promise if no callback passed\n */\n\n/**\n * The callback format for results\n * @callback CommandCursor~toArrayResultCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {object[]} documents All the documents the satisfy the cursor.\n */\n\n/**\n * Returns an array of documents. The caller is responsible for making sure that there\n * is enough memory to store the results. Note that the array only contain partial\n * results when this cursor had been previously accessed.\n * @method CommandCursor.prototype.toArray\n * @param {CommandCursor~toArrayResultCallback} [callback] The result callback.\n * @throws {MongoError}\n * @return {Promise} returns Promise if no callback passed\n */\n\n/**\n * The callback format for results\n * @callback CommandCursor~resultCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {(object|null)} result The result object if the command was executed successfully.\n */\n\n/**\n * Iterates over all the documents for this cursor. As with **{cursor.toArray}**,\n * not all of the elements will be iterated if this cursor had been previously accessed.\n * In that case, **{cursor.rewind}** can be used to reset the cursor. However, unlike\n * **{cursor.toArray}**, the cursor will only hold a maximum of batch size elements\n * at any given time if batch size is specified. Otherwise, the caller is responsible\n * for making sure that the entire result can fit the memory.\n * @method CommandCursor.prototype.each\n * @param {CommandCursor~resultCallback} callback The result callback.\n * @throws {MongoError}\n * @return {null}\n */\n\n/**\n * Close the cursor, sending a KillCursor command and emitting close.\n * @method CommandCursor.prototype.close\n * @param {CommandCursor~resultCallback} [callback] The result callback.\n * @return {Promise} returns Promise if no callback passed\n */\n\n/**\n * Is the cursor closed\n * @method CommandCursor.prototype.isClosed\n * @return {boolean}\n */\n\n/**\n * Clone the cursor\n * @function CommandCursor.prototype.clone\n * @return {CommandCursor}\n */\n\n/**\n * Resets the cursor\n * @function CommandCursor.prototype.rewind\n * @return {CommandCursor}\n */\n\n/**\n * The callback format for the forEach iterator method\n * @callback CommandCursor~iteratorCallback\n * @param {Object} doc An emitted document for the iterator\n */\n\n/**\n * The callback error format for the forEach iterator method\n * @callback CommandCursor~endCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n */\n\n/*\n * Iterates over all the documents for this cursor using the iterator, callback pattern.\n * @method CommandCursor.prototype.forEach\n * @param {CommandCursor~iteratorCallback} iterator The iteration callback.\n * @param {CommandCursor~endCallback} callback The end callback.\n * @throws {MongoError}\n * @return {null}\n */\n\nmodule.exports = CommandCursor;","map":{"version":3,"sources":["/Users/S/Desktop/nodeprotake2/node_modules/mongodb/lib/command_cursor.js"],"names":["ReadPreference","require","MongoError","Cursor","CursorState","CommandCursor","topology","ns","cmd","options","readPreference","s","state","CLOSED","isDead","create","message","driver","INIT","TypeError","value","cursor","batchSize","setCursorBatchSize","lastIsMaster","minWireVersion","maxTimeMS","logger","prototype","get","toArray","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst ReadPreference = require('./core').ReadPreference;\nconst MongoError = require('./core').MongoError;\nconst Cursor = require('./cursor');\nconst CursorState = require('./core/cursor').CursorState;\n\n/**\n * @fileOverview The **CommandCursor** class is an internal class that embodies a\n * generalized cursor based on a MongoDB command allowing for iteration over the\n * results returned. It supports one by one document iteration, conversion to an\n * array or can be iterated as a Node 0.10.X or higher stream\n *\n * **CommandCursor Cannot directly be instantiated**\n * @example\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, client) {\n *   // Create a collection we want to drop later\n *   const col = client.db(dbName).collection('listCollectionsExample1');\n *   // Insert a bunch of documents\n *   col.insert([{a:1, b:1}\n *     , {a:2, b:2}, {a:3, b:3}\n *     , {a:4, b:4}], {w:1}, function(err, result) {\n *     test.equal(null, err);\n *     // List the database collections available\n *     db.listCollections().toArray(function(err, items) {\n *       test.equal(null, err);\n *       client.close();\n *     });\n *   });\n * });\n */\n\n/**\n * Namespace provided by the browser.\n * @external Readable\n */\n\n/**\n * Creates a new Command Cursor instance (INTERNAL TYPE, do not instantiate directly)\n * @class CommandCursor\n * @extends external:Readable\n * @fires CommandCursor#data\n * @fires CommandCursor#end\n * @fires CommandCursor#close\n * @fires CommandCursor#readable\n * @return {CommandCursor} an CommandCursor instance.\n */\nclass CommandCursor extends Cursor {\n  constructor(topology, ns, cmd, options) {\n    super(topology, ns, cmd, options);\n  }\n\n  /**\n   * Set the ReadPreference for the cursor.\n   * @method\n   * @param {(string|ReadPreference)} readPreference The new read preference for the cursor.\n   * @throws {MongoError}\n   * @return {Cursor}\n   */\n  setReadPreference(readPreference) {\n    if (this.s.state === CursorState.CLOSED || this.isDead()) {\n      throw MongoError.create({ message: 'Cursor is closed', driver: true });\n    }\n\n    if (this.s.state !== CursorState.INIT) {\n      throw MongoError.create({\n        message: 'cannot change cursor readPreference after cursor has been accessed',\n        driver: true\n      });\n    }\n\n    if (readPreference instanceof ReadPreference) {\n      this.options.readPreference = readPreference;\n    } else if (typeof readPreference === 'string') {\n      this.options.readPreference = new ReadPreference(readPreference);\n    } else {\n      throw new TypeError('Invalid read preference: ' + readPreference);\n    }\n\n    return this;\n  }\n\n  /**\n   * Set the batch size for the cursor.\n   * @method\n   * @param {number} value The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find/|find command documentation}.\n   * @throws {MongoError}\n   * @return {CommandCursor}\n   */\n  batchSize(value) {\n    if (this.s.state === CursorState.CLOSED || this.isDead()) {\n      throw MongoError.create({ message: 'Cursor is closed', driver: true });\n    }\n\n    if (typeof value !== 'number') {\n      throw MongoError.create({ message: 'batchSize requires an integer', driver: true });\n    }\n\n    if (this.cmd.cursor) {\n      this.cmd.cursor.batchSize = value;\n    }\n\n    this.setCursorBatchSize(value);\n    return this;\n  }\n\n  /**\n   * Add a maxTimeMS stage to the aggregation pipeline\n   * @method\n   * @param {number} value The state maxTimeMS value.\n   * @return {CommandCursor}\n   */\n  maxTimeMS(value) {\n    if (this.topology.lastIsMaster().minWireVersion > 2) {\n      this.cmd.maxTimeMS = value;\n    }\n\n    return this;\n  }\n\n  /**\n   * Return the cursor logger\n   * @method\n   * @return {Logger} return the cursor logger\n   * @ignore\n   */\n  getLogger() {\n    return this.logger;\n  }\n}\n\n// aliases\nCommandCursor.prototype.get = CommandCursor.prototype.toArray;\n\n/**\n * CommandCursor stream data event, fired for each document in the cursor.\n *\n * @event CommandCursor#data\n * @type {object}\n */\n\n/**\n * CommandCursor stream end event\n *\n * @event CommandCursor#end\n * @type {null}\n */\n\n/**\n * CommandCursor stream close event\n *\n * @event CommandCursor#close\n * @type {null}\n */\n\n/**\n * CommandCursor stream readable event\n *\n * @event CommandCursor#readable\n * @type {null}\n */\n\n/**\n * Get the next available document from the cursor, returns null if no more documents are available.\n * @function CommandCursor.prototype.next\n * @param {CommandCursor~resultCallback} [callback] The result callback.\n * @throws {MongoError}\n * @return {Promise} returns Promise if no callback passed\n */\n\n/**\n * Check if there is any document still available in the cursor\n * @function CommandCursor.prototype.hasNext\n * @param {CommandCursor~resultCallback} [callback] The result callback.\n * @throws {MongoError}\n * @return {Promise} returns Promise if no callback passed\n */\n\n/**\n * The callback format for results\n * @callback CommandCursor~toArrayResultCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {object[]} documents All the documents the satisfy the cursor.\n */\n\n/**\n * Returns an array of documents. The caller is responsible for making sure that there\n * is enough memory to store the results. Note that the array only contain partial\n * results when this cursor had been previously accessed.\n * @method CommandCursor.prototype.toArray\n * @param {CommandCursor~toArrayResultCallback} [callback] The result callback.\n * @throws {MongoError}\n * @return {Promise} returns Promise if no callback passed\n */\n\n/**\n * The callback format for results\n * @callback CommandCursor~resultCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {(object|null)} result The result object if the command was executed successfully.\n */\n\n/**\n * Iterates over all the documents for this cursor. As with **{cursor.toArray}**,\n * not all of the elements will be iterated if this cursor had been previously accessed.\n * In that case, **{cursor.rewind}** can be used to reset the cursor. However, unlike\n * **{cursor.toArray}**, the cursor will only hold a maximum of batch size elements\n * at any given time if batch size is specified. Otherwise, the caller is responsible\n * for making sure that the entire result can fit the memory.\n * @method CommandCursor.prototype.each\n * @param {CommandCursor~resultCallback} callback The result callback.\n * @throws {MongoError}\n * @return {null}\n */\n\n/**\n * Close the cursor, sending a KillCursor command and emitting close.\n * @method CommandCursor.prototype.close\n * @param {CommandCursor~resultCallback} [callback] The result callback.\n * @return {Promise} returns Promise if no callback passed\n */\n\n/**\n * Is the cursor closed\n * @method CommandCursor.prototype.isClosed\n * @return {boolean}\n */\n\n/**\n * Clone the cursor\n * @function CommandCursor.prototype.clone\n * @return {CommandCursor}\n */\n\n/**\n * Resets the cursor\n * @function CommandCursor.prototype.rewind\n * @return {CommandCursor}\n */\n\n/**\n * The callback format for the forEach iterator method\n * @callback CommandCursor~iteratorCallback\n * @param {Object} doc An emitted document for the iterator\n */\n\n/**\n * The callback error format for the forEach iterator method\n * @callback CommandCursor~endCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n */\n\n/*\n * Iterates over all the documents for this cursor using the iterator, callback pattern.\n * @method CommandCursor.prototype.forEach\n * @param {CommandCursor~iteratorCallback} iterator The iteration callback.\n * @param {CommandCursor~endCallback} callback The end callback.\n * @throws {MongoError}\n * @return {null}\n */\n\nmodule.exports = CommandCursor;\n"]},"metadata":{},"sourceType":"script"}