{"ast":null,"code":"'use strict';\n\nvar os = require('os');\n\nvar crypto = require('crypto');\n\nvar requireOptional = require('require_optional');\n/**\n * Generate a UUIDv4\n */\n\n\nvar uuidV4 = function uuidV4() {\n  var result = crypto.randomBytes(16);\n  result[6] = result[6] & 0x0f | 0x40;\n  result[8] = result[8] & 0x3f | 0x80;\n  return result;\n};\n/**\n * Returns the duration calculated from two high resolution timers in milliseconds\n *\n * @param {Object} started A high resolution timestamp created from `process.hrtime()`\n * @returns {Number} The duration in milliseconds\n */\n\n\nvar calculateDurationInMs = function calculateDurationInMs(started) {\n  var hrtime = process.hrtime(started);\n  return (hrtime[0] * 1e9 + hrtime[1]) / 1e6;\n};\n/**\n * Relays events for a given listener and emitter\n *\n * @param {EventEmitter} listener the EventEmitter to listen to the events from\n * @param {EventEmitter} emitter the EventEmitter to relay the events to\n */\n\n\nfunction relayEvents(listener, emitter, events) {\n  events.forEach(function (eventName) {\n    return listener.on(eventName, function (event) {\n      return emitter.emit(eventName, event);\n    });\n  });\n}\n\nfunction retrieveKerberos() {\n  var kerberos;\n\n  try {\n    kerberos = requireOptional('kerberos');\n  } catch (err) {\n    if (err.code === 'MODULE_NOT_FOUND') {\n      throw new Error('The `kerberos` module was not found. Please install it and try again.');\n    }\n\n    throw err;\n  }\n\n  return kerberos;\n} // Throw an error if an attempt to use EJSON is made when it is not installed\n\n\nvar noEJSONError = function noEJSONError() {\n  throw new Error('The `mongodb-extjson` module was not found. Please install it and try again.');\n}; // Facilitate loading EJSON optionally\n\n\nfunction retrieveEJSON() {\n  var EJSON = null;\n\n  try {\n    EJSON = requireOptional('mongodb-extjson');\n  } catch (error) {} // eslint-disable-line\n\n\n  if (!EJSON) {\n    EJSON = {\n      parse: noEJSONError,\n      deserialize: noEJSONError,\n      serialize: noEJSONError,\n      stringify: noEJSONError,\n      setBSONModule: noEJSONError,\n      BSON: noEJSONError\n    };\n  }\n\n  return EJSON;\n}\n/**\n * A helper function for determining `maxWireVersion` between legacy and new topology\n * instances\n *\n * @private\n * @param {(Topology|Server)} topologyOrServer\n */\n\n\nfunction maxWireVersion(topologyOrServer) {\n  if (topologyOrServer) {\n    if (topologyOrServer.ismaster) {\n      return topologyOrServer.ismaster.maxWireVersion;\n    }\n\n    if (typeof topologyOrServer.lastIsMaster === 'function') {\n      var lastIsMaster = topologyOrServer.lastIsMaster();\n\n      if (lastIsMaster) {\n        return lastIsMaster.maxWireVersion;\n      }\n    }\n\n    if (topologyOrServer.description) {\n      return topologyOrServer.description.maxWireVersion;\n    }\n  }\n\n  return 0;\n}\n/*\n * Checks that collation is supported by server.\n *\n * @param {Server} [server] to check against\n * @param {object} [cmd] object where collation may be specified\n * @param {function} [callback] callback function\n * @return true if server does not support collation\n */\n\n\nfunction collationNotSupported(server, cmd) {\n  return cmd && cmd.collation && maxWireVersion(server) < 5;\n}\n/**\n * Checks if a given value is a Promise\n *\n * @param {*} maybePromise\n * @return true if the provided value is a Promise\n */\n\n\nfunction isPromiseLike(maybePromise) {\n  return maybePromise && typeof maybePromise.then === 'function';\n}\n/**\n * Applies the function `eachFn` to each item in `arr`, in parallel.\n *\n * @param {array} arr an array of items to asynchronusly iterate over\n * @param {function} eachFn A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.\n * @param {function} callback The callback called after every item has been iterated\n */\n\n\nfunction eachAsync(arr, eachFn, callback) {\n  arr = arr || [];\n  var idx = 0;\n  var awaiting = 0;\n\n  for (idx = 0; idx < arr.length; ++idx) {\n    awaiting++;\n    eachFn(arr[idx], eachCallback);\n  }\n\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n\n  function eachCallback(err) {\n    awaiting--;\n\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n    }\n  }\n}\n\nfunction isUnifiedTopology(topology) {\n  return topology.description != null;\n}\n\nfunction arrayStrictEqual(arr, arr2) {\n  if (!Array.isArray(arr) || !Array.isArray(arr2)) {\n    return false;\n  }\n\n  return arr.length === arr2.length && arr.every(function (elt, idx) {\n    return elt === arr2[idx];\n  });\n}\n\nfunction tagsStrictEqual(tags, tags2) {\n  var tagsKeys = Object.keys(tags);\n  var tags2Keys = Object.keys(tags2);\n  return tagsKeys.length === tags2Keys.length && tagsKeys.every(function (key) {\n    return tags2[key] === tags[key];\n  });\n}\n\nfunction errorStrictEqual(lhs, rhs) {\n  if (lhs === rhs) {\n    return true;\n  }\n\n  if (lhs == null && rhs != null || lhs != null && rhs == null) {\n    return false;\n  }\n\n  if (lhs.constructor.name !== rhs.constructor.name) {\n    return false;\n  }\n\n  if (lhs.message !== rhs.message) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction makeStateMachine(stateTable) {\n  return function stateTransition(target, newState) {\n    var legalStates = stateTable[target.s.state];\n\n    if (legalStates && legalStates.indexOf(newState) < 0) {\n      throw new TypeError(\"illegal state transition from [\".concat(target.s.state, \"] => [\").concat(newState, \"], allowed: [\").concat(legalStates, \"]\"));\n    }\n\n    target.emit('stateChanged', target.s.state, newState);\n    target.s.state = newState;\n  };\n}\n\nfunction makeClientMetadata(options) {\n  options = options || {};\n  var metadata = {\n    driver: {\n      name: 'nodejs',\n      version: require('../../package.json').version\n    },\n    os: {\n      type: os.type(),\n      name: process.platform,\n      architecture: process.arch,\n      version: os.release()\n    },\n    platform: \"'Node.js \".concat(process.version, \", \").concat(os.endianness, \" (\").concat(options.useUnifiedTopology ? 'unified' : 'legacy', \")\")\n  }; // support optionally provided wrapping driver info\n\n  if (options.driverInfo) {\n    if (options.driverInfo.name) {\n      metadata.driver.name = \"\".concat(metadata.driver.name, \"|\").concat(options.driverInfo.name);\n    }\n\n    if (options.driverInfo.version) {\n      metadata.version = \"\".concat(metadata.driver.version, \"|\").concat(options.driverInfo.version);\n    }\n\n    if (options.driverInfo.platform) {\n      metadata.platform = \"\".concat(metadata.platform, \"|\").concat(options.driverInfo.platform);\n    }\n  }\n\n  if (options.appname) {\n    // MongoDB requires the appname not exceed a byte length of 128\n    var buffer = Buffer.from(options.appname);\n    metadata.application = {\n      name: buffer.length > 128 ? buffer.slice(0, 128).toString('utf8') : options.appname\n    };\n  }\n\n  return metadata;\n}\n\nvar noop = function noop() {};\n\nmodule.exports = {\n  uuidV4: uuidV4,\n  calculateDurationInMs: calculateDurationInMs,\n  relayEvents: relayEvents,\n  collationNotSupported: collationNotSupported,\n  retrieveEJSON: retrieveEJSON,\n  retrieveKerberos: retrieveKerberos,\n  maxWireVersion: maxWireVersion,\n  isPromiseLike: isPromiseLike,\n  eachAsync: eachAsync,\n  isUnifiedTopology: isUnifiedTopology,\n  arrayStrictEqual: arrayStrictEqual,\n  tagsStrictEqual: tagsStrictEqual,\n  errorStrictEqual: errorStrictEqual,\n  makeStateMachine: makeStateMachine,\n  makeClientMetadata: makeClientMetadata,\n  noop: noop\n};","map":{"version":3,"sources":["/Users/S/Desktop/nodeprotake2/node_modules/mongodb/lib/core/utils.js"],"names":["os","require","crypto","requireOptional","uuidV4","result","randomBytes","calculateDurationInMs","started","hrtime","process","relayEvents","listener","emitter","events","forEach","eventName","on","event","emit","retrieveKerberos","kerberos","err","code","Error","noEJSONError","retrieveEJSON","EJSON","error","parse","deserialize","serialize","stringify","setBSONModule","BSON","maxWireVersion","topologyOrServer","ismaster","lastIsMaster","description","collationNotSupported","server","cmd","collation","isPromiseLike","maybePromise","then","eachAsync","arr","eachFn","callback","idx","awaiting","length","eachCallback","isUnifiedTopology","topology","arrayStrictEqual","arr2","Array","isArray","every","elt","tagsStrictEqual","tags","tags2","tagsKeys","Object","keys","tags2Keys","key","errorStrictEqual","lhs","rhs","constructor","name","message","makeStateMachine","stateTable","stateTransition","target","newState","legalStates","s","state","indexOf","TypeError","makeClientMetadata","options","metadata","driver","version","type","platform","architecture","arch","release","endianness","useUnifiedTopology","driverInfo","appname","buffer","Buffer","from","application","slice","toString","noop","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst os = require('os');\nconst crypto = require('crypto');\nconst requireOptional = require('require_optional');\n\n/**\n * Generate a UUIDv4\n */\nconst uuidV4 = () => {\n  const result = crypto.randomBytes(16);\n  result[6] = (result[6] & 0x0f) | 0x40;\n  result[8] = (result[8] & 0x3f) | 0x80;\n  return result;\n};\n\n/**\n * Returns the duration calculated from two high resolution timers in milliseconds\n *\n * @param {Object} started A high resolution timestamp created from `process.hrtime()`\n * @returns {Number} The duration in milliseconds\n */\nconst calculateDurationInMs = started => {\n  const hrtime = process.hrtime(started);\n  return (hrtime[0] * 1e9 + hrtime[1]) / 1e6;\n};\n\n/**\n * Relays events for a given listener and emitter\n *\n * @param {EventEmitter} listener the EventEmitter to listen to the events from\n * @param {EventEmitter} emitter the EventEmitter to relay the events to\n */\nfunction relayEvents(listener, emitter, events) {\n  events.forEach(eventName => listener.on(eventName, event => emitter.emit(eventName, event)));\n}\n\nfunction retrieveKerberos() {\n  let kerberos;\n\n  try {\n    kerberos = requireOptional('kerberos');\n  } catch (err) {\n    if (err.code === 'MODULE_NOT_FOUND') {\n      throw new Error('The `kerberos` module was not found. Please install it and try again.');\n    }\n\n    throw err;\n  }\n\n  return kerberos;\n}\n\n// Throw an error if an attempt to use EJSON is made when it is not installed\nconst noEJSONError = function() {\n  throw new Error('The `mongodb-extjson` module was not found. Please install it and try again.');\n};\n\n// Facilitate loading EJSON optionally\nfunction retrieveEJSON() {\n  let EJSON = null;\n  try {\n    EJSON = requireOptional('mongodb-extjson');\n  } catch (error) {} // eslint-disable-line\n  if (!EJSON) {\n    EJSON = {\n      parse: noEJSONError,\n      deserialize: noEJSONError,\n      serialize: noEJSONError,\n      stringify: noEJSONError,\n      setBSONModule: noEJSONError,\n      BSON: noEJSONError\n    };\n  }\n\n  return EJSON;\n}\n\n/**\n * A helper function for determining `maxWireVersion` between legacy and new topology\n * instances\n *\n * @private\n * @param {(Topology|Server)} topologyOrServer\n */\nfunction maxWireVersion(topologyOrServer) {\n  if (topologyOrServer) {\n    if (topologyOrServer.ismaster) {\n      return topologyOrServer.ismaster.maxWireVersion;\n    }\n\n    if (typeof topologyOrServer.lastIsMaster === 'function') {\n      const lastIsMaster = topologyOrServer.lastIsMaster();\n      if (lastIsMaster) {\n        return lastIsMaster.maxWireVersion;\n      }\n    }\n\n    if (topologyOrServer.description) {\n      return topologyOrServer.description.maxWireVersion;\n    }\n  }\n\n  return 0;\n}\n\n/*\n * Checks that collation is supported by server.\n *\n * @param {Server} [server] to check against\n * @param {object} [cmd] object where collation may be specified\n * @param {function} [callback] callback function\n * @return true if server does not support collation\n */\nfunction collationNotSupported(server, cmd) {\n  return cmd && cmd.collation && maxWireVersion(server) < 5;\n}\n\n/**\n * Checks if a given value is a Promise\n *\n * @param {*} maybePromise\n * @return true if the provided value is a Promise\n */\nfunction isPromiseLike(maybePromise) {\n  return maybePromise && typeof maybePromise.then === 'function';\n}\n\n/**\n * Applies the function `eachFn` to each item in `arr`, in parallel.\n *\n * @param {array} arr an array of items to asynchronusly iterate over\n * @param {function} eachFn A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.\n * @param {function} callback The callback called after every item has been iterated\n */\nfunction eachAsync(arr, eachFn, callback) {\n  arr = arr || [];\n\n  let idx = 0;\n  let awaiting = 0;\n  for (idx = 0; idx < arr.length; ++idx) {\n    awaiting++;\n    eachFn(arr[idx], eachCallback);\n  }\n\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n\n  function eachCallback(err) {\n    awaiting--;\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n    }\n  }\n}\n\nfunction isUnifiedTopology(topology) {\n  return topology.description != null;\n}\n\nfunction arrayStrictEqual(arr, arr2) {\n  if (!Array.isArray(arr) || !Array.isArray(arr2)) {\n    return false;\n  }\n\n  return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);\n}\n\nfunction tagsStrictEqual(tags, tags2) {\n  const tagsKeys = Object.keys(tags);\n  const tags2Keys = Object.keys(tags2);\n  return tagsKeys.length === tags2Keys.length && tagsKeys.every(key => tags2[key] === tags[key]);\n}\n\nfunction errorStrictEqual(lhs, rhs) {\n  if (lhs === rhs) {\n    return true;\n  }\n\n  if ((lhs == null && rhs != null) || (lhs != null && rhs == null)) {\n    return false;\n  }\n\n  if (lhs.constructor.name !== rhs.constructor.name) {\n    return false;\n  }\n\n  if (lhs.message !== rhs.message) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction makeStateMachine(stateTable) {\n  return function stateTransition(target, newState) {\n    const legalStates = stateTable[target.s.state];\n    if (legalStates && legalStates.indexOf(newState) < 0) {\n      throw new TypeError(\n        `illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`\n      );\n    }\n\n    target.emit('stateChanged', target.s.state, newState);\n    target.s.state = newState;\n  };\n}\n\nfunction makeClientMetadata(options) {\n  options = options || {};\n\n  const metadata = {\n    driver: {\n      name: 'nodejs',\n      version: require('../../package.json').version\n    },\n    os: {\n      type: os.type(),\n      name: process.platform,\n      architecture: process.arch,\n      version: os.release()\n    },\n    platform: `'Node.js ${process.version}, ${os.endianness} (${\n      options.useUnifiedTopology ? 'unified' : 'legacy'\n    })`\n  };\n\n  // support optionally provided wrapping driver info\n  if (options.driverInfo) {\n    if (options.driverInfo.name) {\n      metadata.driver.name = `${metadata.driver.name}|${options.driverInfo.name}`;\n    }\n\n    if (options.driverInfo.version) {\n      metadata.version = `${metadata.driver.version}|${options.driverInfo.version}`;\n    }\n\n    if (options.driverInfo.platform) {\n      metadata.platform = `${metadata.platform}|${options.driverInfo.platform}`;\n    }\n  }\n\n  if (options.appname) {\n    // MongoDB requires the appname not exceed a byte length of 128\n    const buffer = Buffer.from(options.appname);\n    metadata.application = {\n      name: buffer.length > 128 ? buffer.slice(0, 128).toString('utf8') : options.appname\n    };\n  }\n\n  return metadata;\n}\n\nconst noop = () => {};\n\nmodule.exports = {\n  uuidV4,\n  calculateDurationInMs,\n  relayEvents,\n  collationNotSupported,\n  retrieveEJSON,\n  retrieveKerberos,\n  maxWireVersion,\n  isPromiseLike,\n  eachAsync,\n  isUnifiedTopology,\n  arrayStrictEqual,\n  tagsStrictEqual,\n  errorStrictEqual,\n  makeStateMachine,\n  makeClientMetadata,\n  noop\n};\n"]},"metadata":{},"sourceType":"script"}