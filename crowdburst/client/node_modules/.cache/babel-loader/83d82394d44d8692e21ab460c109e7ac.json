{"ast":null,"code":"'use strict';\n\nvar _assertThisInitialized = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _createClass = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _classCallCheck = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar Long = require('../core').BSON.Long;\n\nvar MongoError = require('../core').MongoError;\n\nvar ObjectID = require('../core').BSON.ObjectID;\n\nvar BSON = require('../core').BSON;\n\nvar MongoWriteConcernError = require('../core').MongoWriteConcernError;\n\nvar toError = require('../utils').toError;\n\nvar handleCallback = require('../utils').handleCallback;\n\nvar applyRetryableWrites = require('../utils').applyRetryableWrites;\n\nvar applyWriteConcern = require('../utils').applyWriteConcern;\n\nvar executeLegacyOperation = require('../utils').executeLegacyOperation;\n\nvar isPromiseLike = require('../utils').isPromiseLike; // Error codes\n\n\nvar WRITE_CONCERN_ERROR = 64; // Insert types\n\nvar INSERT = 1;\nvar UPDATE = 2;\nvar REMOVE = 3;\nvar bson = new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128, BSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey, BSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp]);\n/**\n * Keeps the state of a unordered batch so we can rewrite the results\n * correctly after command execution\n * @ignore\n */\n\nvar Batch = function Batch(batchType, originalZeroIndex) {\n  _classCallCheck(this, Batch);\n\n  this.originalZeroIndex = originalZeroIndex;\n  this.currentIndex = 0;\n  this.originalIndexes = [];\n  this.batchType = batchType;\n  this.operations = [];\n  this.size = 0;\n  this.sizeBytes = 0;\n};\n/**\n * @classdesc\n * The result of a bulk write.\n */\n\n\nvar BulkWriteResult = /*#__PURE__*/function () {\n  /**\n   * Create a new BulkWriteResult instance\n   *\n   * **NOTE:** Internal Type, do not instantiate directly\n   */\n  function BulkWriteResult(bulkResult) {\n    _classCallCheck(this, BulkWriteResult);\n\n    this.result = bulkResult;\n  }\n  /**\n   * Evaluates to true if the bulk operation correctly executes\n   * @type {boolean}\n   */\n\n\n  _createClass(BulkWriteResult, [{\n    key: \"getInsertedIds\",\n\n    /**\n     * Returns an array of all inserted ids\n     *\n     * @return {object[]}\n     */\n    value: function getInsertedIds() {\n      return this.result.insertedIds;\n    }\n    /**\n     * Returns an array of all upserted ids\n     *\n     * @return {object[]}\n     */\n\n  }, {\n    key: \"getUpsertedIds\",\n    value: function getUpsertedIds() {\n      return this.result.upserted;\n    }\n    /**\n     * Returns the upserted id at the given index\n     *\n     * @param {number} index the number of the upserted id to return, returns undefined if no result for passed in index\n     * @return {object}\n     */\n\n  }, {\n    key: \"getUpsertedIdAt\",\n    value: function getUpsertedIdAt(index) {\n      return this.result.upserted[index];\n    }\n    /**\n     * Returns raw internal result\n     *\n     * @return {object}\n     */\n\n  }, {\n    key: \"getRawResponse\",\n    value: function getRawResponse() {\n      return this.result;\n    }\n    /**\n     * Returns true if the bulk operation contains a write error\n     *\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"hasWriteErrors\",\n    value: function hasWriteErrors() {\n      return this.result.writeErrors.length > 0;\n    }\n    /**\n     * Returns the number of write errors off the bulk operation\n     *\n     * @return {number}\n     */\n\n  }, {\n    key: \"getWriteErrorCount\",\n    value: function getWriteErrorCount() {\n      return this.result.writeErrors.length;\n    }\n    /**\n     * Returns a specific write error object\n     *\n     * @param {number} index of the write error to return, returns null if there is no result for passed in index\n     * @return {WriteError}\n     */\n\n  }, {\n    key: \"getWriteErrorAt\",\n    value: function getWriteErrorAt(index) {\n      if (index < this.result.writeErrors.length) {\n        return this.result.writeErrors[index];\n      }\n\n      return null;\n    }\n    /**\n     * Retrieve all write errors\n     *\n     * @return {WriteError[]}\n     */\n\n  }, {\n    key: \"getWriteErrors\",\n    value: function getWriteErrors() {\n      return this.result.writeErrors;\n    }\n    /**\n     * Retrieve lastOp if available\n     *\n     * @return {object}\n     */\n\n  }, {\n    key: \"getLastOp\",\n    value: function getLastOp() {\n      return this.result.lastOp;\n    }\n    /**\n     * Retrieve the write concern error if any\n     *\n     * @return {WriteConcernError}\n     */\n\n  }, {\n    key: \"getWriteConcernError\",\n    value: function getWriteConcernError() {\n      if (this.result.writeConcernErrors.length === 0) {\n        return null;\n      } else if (this.result.writeConcernErrors.length === 1) {\n        // Return the error\n        return this.result.writeConcernErrors[0];\n      } else {\n        // Combine the errors\n        var errmsg = '';\n\n        for (var i = 0; i < this.result.writeConcernErrors.length; i++) {\n          var err = this.result.writeConcernErrors[i];\n          errmsg = errmsg + err.errmsg; // TODO: Something better\n\n          if (i === 0) errmsg = errmsg + ' and ';\n        }\n\n        return new WriteConcernError({\n          errmsg: errmsg,\n          code: WRITE_CONCERN_ERROR\n        });\n      }\n    }\n    /**\n     * @return {object}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.result;\n    }\n    /**\n     * @return {string}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"BulkWriteResult(\".concat(this.toJSON(this.result), \")\");\n    }\n    /**\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isOk\",\n    value: function isOk() {\n      return this.result.ok === 1;\n    }\n  }, {\n    key: \"ok\",\n    get: function get() {\n      return this.result.ok;\n    }\n    /**\n     * The number of inserted documents\n     * @type {number}\n     */\n\n  }, {\n    key: \"nInserted\",\n    get: function get() {\n      return this.result.nInserted;\n    }\n    /**\n     * Number of upserted documents\n     * @type {number}\n     */\n\n  }, {\n    key: \"nUpserted\",\n    get: function get() {\n      return this.result.nUpserted;\n    }\n    /**\n     * Number of matched documents\n     * @type {number}\n     */\n\n  }, {\n    key: \"nMatched\",\n    get: function get() {\n      return this.result.nMatched;\n    }\n    /**\n     * Number of documents updated physically on disk\n     * @type {number}\n     */\n\n  }, {\n    key: \"nModified\",\n    get: function get() {\n      return this.result.nModified;\n    }\n    /**\n     * Number of removed documents\n     * @type {number}\n     */\n\n  }, {\n    key: \"nRemoved\",\n    get: function get() {\n      return this.result.nRemoved;\n    }\n  }]);\n\n  return BulkWriteResult;\n}();\n/**\n * @classdesc An error representing a failure by the server to apply the requested write concern to the bulk operation.\n */\n\n\nvar WriteConcernError = /*#__PURE__*/function () {\n  /**\n   * Create a new WriteConcernError instance\n   *\n   * **NOTE:** Internal Type, do not instantiate directly\n   */\n  function WriteConcernError(err) {\n    _classCallCheck(this, WriteConcernError);\n\n    this.err = err;\n  }\n  /**\n   * Write concern error code.\n   * @type {number}\n   */\n\n\n  _createClass(WriteConcernError, [{\n    key: \"toJSON\",\n\n    /**\n     * @return {object}\n     */\n    value: function toJSON() {\n      return {\n        code: this.err.code,\n        errmsg: this.err.errmsg\n      };\n    }\n    /**\n     * @return {string}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"WriteConcernError(\".concat(this.err.errmsg, \")\");\n    }\n  }, {\n    key: \"code\",\n    get: function get() {\n      return this.err.code;\n    }\n    /**\n     * Write concern error message.\n     * @type {string}\n     */\n\n  }, {\n    key: \"errmsg\",\n    get: function get() {\n      return this.err.errmsg;\n    }\n  }]);\n\n  return WriteConcernError;\n}();\n/**\n * @classdesc An error that occurred during a BulkWrite on the server.\n */\n\n\nvar WriteError = /*#__PURE__*/function () {\n  /**\n   * Create a new WriteError instance\n   *\n   * **NOTE:** Internal Type, do not instantiate directly\n   */\n  function WriteError(err) {\n    _classCallCheck(this, WriteError);\n\n    this.err = err;\n  }\n  /**\n   * WriteError code.\n   * @type {number}\n   */\n\n\n  _createClass(WriteError, [{\n    key: \"getOperation\",\n\n    /**\n     * Returns the underlying operation that caused the error\n     * @return {object}\n     */\n    value: function getOperation() {\n      return this.err.op;\n    }\n    /**\n     * @return {object}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        code: this.err.code,\n        index: this.err.index,\n        errmsg: this.err.errmsg,\n        op: this.err.op\n      };\n    }\n    /**\n     * @return {string}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"WriteError(\".concat(JSON.stringify(this.toJSON()), \")\");\n    }\n  }, {\n    key: \"code\",\n    get: function get() {\n      return this.err.code;\n    }\n    /**\n     * WriteError original bulk operation index.\n     * @type {number}\n     */\n\n  }, {\n    key: \"index\",\n    get: function get() {\n      return this.err.index;\n    }\n    /**\n     * WriteError message.\n     * @type {string}\n     */\n\n  }, {\n    key: \"errmsg\",\n    get: function get() {\n      return this.err.errmsg;\n    }\n  }]);\n\n  return WriteError;\n}();\n/**\n * Merges results into shared data structure\n * @ignore\n */\n\n\nfunction mergeBatchResults(batch, bulkResult, err, result) {\n  // If we have an error set the result to be the err object\n  if (err) {\n    result = err;\n  } else if (result && result.result) {\n    result = result.result;\n  } else if (result == null) {\n    return;\n  } // Do we have a top level error stop processing and return\n\n\n  if (result.ok === 0 && bulkResult.ok === 1) {\n    bulkResult.ok = 0;\n    var writeError = {\n      index: 0,\n      code: result.code || 0,\n      errmsg: result.message,\n      op: batch.operations[0]\n    };\n    bulkResult.writeErrors.push(new WriteError(writeError));\n    return;\n  } else if (result.ok === 0 && bulkResult.ok === 0) {\n    return;\n  } // Deal with opTime if available\n\n\n  if (result.opTime || result.lastOp) {\n    var opTime = result.lastOp || result.opTime;\n    var lastOpTS = null;\n    var lastOpT = null; // We have a time stamp\n\n    if (opTime && opTime._bsontype === 'Timestamp') {\n      if (bulkResult.lastOp == null) {\n        bulkResult.lastOp = opTime;\n      } else if (opTime.greaterThan(bulkResult.lastOp)) {\n        bulkResult.lastOp = opTime;\n      }\n    } else {\n      // Existing TS\n      if (bulkResult.lastOp) {\n        lastOpTS = typeof bulkResult.lastOp.ts === 'number' ? Long.fromNumber(bulkResult.lastOp.ts) : bulkResult.lastOp.ts;\n        lastOpT = typeof bulkResult.lastOp.t === 'number' ? Long.fromNumber(bulkResult.lastOp.t) : bulkResult.lastOp.t;\n      } // Current OpTime TS\n\n\n      var opTimeTS = typeof opTime.ts === 'number' ? Long.fromNumber(opTime.ts) : opTime.ts;\n      var opTimeT = typeof opTime.t === 'number' ? Long.fromNumber(opTime.t) : opTime.t; // Compare the opTime's\n\n      if (bulkResult.lastOp == null) {\n        bulkResult.lastOp = opTime;\n      } else if (opTimeTS.greaterThan(lastOpTS)) {\n        bulkResult.lastOp = opTime;\n      } else if (opTimeTS.equals(lastOpTS)) {\n        if (opTimeT.greaterThan(lastOpT)) {\n          bulkResult.lastOp = opTime;\n        }\n      }\n    }\n  } // If we have an insert Batch type\n\n\n  if (batch.batchType === INSERT && result.n) {\n    bulkResult.nInserted = bulkResult.nInserted + result.n;\n  } // If we have an insert Batch type\n\n\n  if (batch.batchType === REMOVE && result.n) {\n    bulkResult.nRemoved = bulkResult.nRemoved + result.n;\n  }\n\n  var nUpserted = 0; // We have an array of upserted values, we need to rewrite the indexes\n\n  if (Array.isArray(result.upserted)) {\n    nUpserted = result.upserted.length;\n\n    for (var i = 0; i < result.upserted.length; i++) {\n      bulkResult.upserted.push({\n        index: result.upserted[i].index + batch.originalZeroIndex,\n        _id: result.upserted[i]._id\n      });\n    }\n  } else if (result.upserted) {\n    nUpserted = 1;\n    bulkResult.upserted.push({\n      index: batch.originalZeroIndex,\n      _id: result.upserted\n    });\n  } // If we have an update Batch type\n\n\n  if (batch.batchType === UPDATE && result.n) {\n    var nModified = result.nModified;\n    bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;\n    bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);\n\n    if (typeof nModified === 'number') {\n      bulkResult.nModified = bulkResult.nModified + nModified;\n    } else {\n      bulkResult.nModified = null;\n    }\n  }\n\n  if (Array.isArray(result.writeErrors)) {\n    for (var _i = 0; _i < result.writeErrors.length; _i++) {\n      var _writeError = {\n        index: batch.originalIndexes[result.writeErrors[_i].index],\n        code: result.writeErrors[_i].code,\n        errmsg: result.writeErrors[_i].errmsg,\n        op: batch.operations[result.writeErrors[_i].index]\n      };\n      bulkResult.writeErrors.push(new WriteError(_writeError));\n    }\n  }\n\n  if (result.writeConcernError) {\n    bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));\n  }\n}\n\nfunction executeCommands(bulkOperation, options, callback) {\n  if (bulkOperation.s.batches.length === 0) {\n    return handleCallback(callback, null, new BulkWriteResult(bulkOperation.s.bulkResult));\n  }\n\n  var batch = bulkOperation.s.batches.shift();\n\n  function resultHandler(err, result) {\n    // Error is a driver related error not a bulk op error, terminate\n    if ((err && err.driver || err && err.message) && !(err instanceof MongoWriteConcernError)) {\n      return handleCallback(callback, err);\n    } // If we have and error\n\n\n    if (err) err.ok = 0;\n\n    if (err instanceof MongoWriteConcernError) {\n      return handleMongoWriteConcernError(batch, bulkOperation.s.bulkResult, err, callback);\n    } // Merge the results together\n\n\n    var writeResult = new BulkWriteResult(bulkOperation.s.bulkResult);\n    var mergeResult = mergeBatchResults(batch, bulkOperation.s.bulkResult, err, result);\n\n    if (mergeResult != null) {\n      return handleCallback(callback, null, writeResult);\n    }\n\n    if (bulkOperation.handleWriteError(callback, writeResult)) return; // Execute the next command in line\n\n    executeCommands(bulkOperation, options, callback);\n  }\n\n  bulkOperation.finalOptionsHandler({\n    options: options,\n    batch: batch,\n    resultHandler: resultHandler\n  }, callback);\n}\n/**\n * handles write concern error\n *\n * @ignore\n * @param {object} batch\n * @param {object} bulkResult\n * @param {boolean} ordered\n * @param {WriteConcernError} err\n * @param {function} callback\n */\n\n\nfunction handleMongoWriteConcernError(batch, bulkResult, err, callback) {\n  mergeBatchResults(batch, bulkResult, null, err.result);\n  var wrappedWriteConcernError = new WriteConcernError({\n    errmsg: err.result.writeConcernError.errmsg,\n    code: err.result.writeConcernError.result\n  });\n  return handleCallback(callback, new BulkWriteError(toError(wrappedWriteConcernError), new BulkWriteResult(bulkResult)), null);\n}\n/**\n * @classdesc An error indicating an unsuccessful Bulk Write\n */\n\n\nvar BulkWriteError = /*#__PURE__*/function (_MongoError) {\n  _inherits(BulkWriteError, _MongoError);\n\n  var _super = _createSuper(BulkWriteError);\n\n  /**\n   * Creates a new BulkWriteError\n   *\n   * @param {Error|string|object} message The error message\n   * @param {BulkWriteResult} result The result of the bulk write operation\n   * @extends {MongoError}\n   */\n  function BulkWriteError(error, result) {\n    var _this;\n\n    _classCallCheck(this, BulkWriteError);\n\n    var message = error.err || error.errmsg || error.errMessage || error;\n    _this = _super.call(this, message);\n    Object.assign(_assertThisInitialized(_this), error);\n    _this.name = 'BulkWriteError';\n    _this.result = result;\n    return _this;\n  }\n\n  return BulkWriteError;\n}(MongoError);\n/**\n * @classdesc A builder object that is returned from {@link BulkOperationBase#find}.\n * Is used to build a write operation that involves a query filter.\n */\n\n\nvar FindOperators = /*#__PURE__*/function () {\n  /**\n   * Creates a new FindOperators object.\n   *\n   * **NOTE:** Internal Type, do not instantiate directly\n   * @param {OrderedBulkOperation|UnorderedBulkOperation} bulkOperation\n   */\n  function FindOperators(bulkOperation) {\n    _classCallCheck(this, FindOperators);\n\n    this.s = bulkOperation.s;\n  }\n  /**\n   * Add a multiple update operation to the bulk operation\n   *\n   * @method\n   * @param {object} updateDocument An update field for an update operation. See {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-u u documentation}\n   * @param {object} [options.hint] An optional hint for query optimization. See the {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-hint|update command} reference for more information.\n   * @throws {MongoError} If operation cannot be added to bulk write\n   * @return {OrderedBulkOperation|UnorderedBulkOperation} A reference to the parent BulkOperation\n   */\n\n\n  _createClass(FindOperators, [{\n    key: \"update\",\n    value: function update(updateDocument) {\n      // Perform upsert\n      var upsert = typeof this.s.currentOp.upsert === 'boolean' ? this.s.currentOp.upsert : false; // Establish the update command\n\n      var document = {\n        q: this.s.currentOp.selector,\n        u: updateDocument,\n        multi: true,\n        upsert: upsert\n      };\n\n      if (updateDocument.hint) {\n        document.hint = updateDocument.hint;\n      } // Clear out current Op\n\n\n      this.s.currentOp = null;\n      return this.s.options.addToOperationsList(this, UPDATE, document);\n    }\n    /**\n     * Add a single update operation to the bulk operation\n     *\n     * @method\n     * @param {object} updateDocument An update field for an update operation. See {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-u u documentation}\n     * @param {object} [options.hint] An optional hint for query optimization. See the {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-hint|update command} reference for more information.\n     * @throws {MongoError} If operation cannot be added to bulk write\n     * @return {OrderedBulkOperation|UnorderedBulkOperation} A reference to the parent BulkOperation\n     */\n\n  }, {\n    key: \"updateOne\",\n    value: function updateOne(updateDocument) {\n      // Perform upsert\n      var upsert = typeof this.s.currentOp.upsert === 'boolean' ? this.s.currentOp.upsert : false; // Establish the update command\n\n      var document = {\n        q: this.s.currentOp.selector,\n        u: updateDocument,\n        multi: false,\n        upsert: upsert\n      };\n\n      if (updateDocument.hint) {\n        document.hint = updateDocument.hint;\n      } // Clear out current Op\n\n\n      this.s.currentOp = null;\n      return this.s.options.addToOperationsList(this, UPDATE, document);\n    }\n    /**\n     * Add a replace one operation to the bulk operation\n     *\n     * @method\n     * @param {object} updateDocument the new document to replace the existing one with\n     * @throws {MongoError} If operation cannot be added to bulk write\n     * @return {OrderedBulkOperation|UnorderedBulkOperation} A reference to the parent BulkOperation\n     */\n\n  }, {\n    key: \"replaceOne\",\n    value: function replaceOne(updateDocument) {\n      this.updateOne(updateDocument);\n    }\n    /**\n     * Upsert modifier for update bulk operation, noting that this operation is an upsert.\n     *\n     * @method\n     * @throws {MongoError} If operation cannot be added to bulk write\n     * @return {FindOperators} reference to self\n     */\n\n  }, {\n    key: \"upsert\",\n    value: function upsert() {\n      this.s.currentOp.upsert = true;\n      return this;\n    }\n    /**\n     * Add a delete one operation to the bulk operation\n     *\n     * @method\n     * @throws {MongoError} If operation cannot be added to bulk write\n     * @return {OrderedBulkOperation|UnorderedBulkOperation} A reference to the parent BulkOperation\n     */\n\n  }, {\n    key: \"deleteOne\",\n    value: function deleteOne() {\n      // Establish the update command\n      var document = {\n        q: this.s.currentOp.selector,\n        limit: 1\n      }; // Clear out current Op\n\n      this.s.currentOp = null;\n      return this.s.options.addToOperationsList(this, REMOVE, document);\n    }\n    /**\n     * Add a delete many operation to the bulk operation\n     *\n     * @method\n     * @throws {MongoError} If operation cannot be added to bulk write\n     * @return {OrderedBulkOperation|UnorderedBulkOperation} A reference to the parent BulkOperation\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      // Establish the update command\n      var document = {\n        q: this.s.currentOp.selector,\n        limit: 0\n      }; // Clear out current Op\n\n      this.s.currentOp = null;\n      return this.s.options.addToOperationsList(this, REMOVE, document);\n    }\n    /**\n     * backwards compatability for deleteOne\n     */\n\n  }, {\n    key: \"removeOne\",\n    value: function removeOne() {\n      return this.deleteOne();\n    }\n    /**\n     * backwards compatability for delete\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      return this.delete();\n    }\n  }]);\n\n  return FindOperators;\n}();\n/**\n * @classdesc Parent class to OrderedBulkOperation and UnorderedBulkOperation\n *\n * **NOTE:** Internal Type, do not instantiate directly\n */\n\n\nvar BulkOperationBase = /*#__PURE__*/function () {\n  /**\n   * Create a new OrderedBulkOperation or UnorderedBulkOperation instance\n   * @property {number} length Get the number of operations in the bulk.\n   */\n  function BulkOperationBase(topology, collection, options, isOrdered) {\n    _classCallCheck(this, BulkOperationBase);\n\n    // determine whether bulkOperation is ordered or unordered\n    this.isOrdered = isOrdered;\n    options = options == null ? {} : options; // TODO Bring from driver information in isMaster\n    // Get the namespace for the write operations\n\n    var namespace = collection.s.namespace; // Used to mark operation as executed\n\n    var executed = false; // Current item\n\n    var currentOp = null; // Handle to the bson serializer, used to calculate running sizes\n\n    var bson = topology.bson; // Set max byte size\n\n    var isMaster = topology.lastIsMaster(); // If we have autoEncryption on, batch-splitting must be done on 2mb chunks, but single documents\n    // over 2mb are still allowed\n\n    var usingAutoEncryption = !!(topology.s.options && topology.s.options.autoEncrypter);\n    var maxBsonObjectSize = isMaster && isMaster.maxBsonObjectSize ? isMaster.maxBsonObjectSize : 1024 * 1024 * 16;\n    var maxBatchSizeBytes = usingAutoEncryption ? 1024 * 1024 * 2 : maxBsonObjectSize;\n    var maxWriteBatchSize = isMaster && isMaster.maxWriteBatchSize ? isMaster.maxWriteBatchSize : 1000; // Calculates the largest possible size of an Array key, represented as a BSON string\n    // element. This calculation:\n    //     1 byte for BSON type\n    //     # of bytes = length of (string representation of (maxWriteBatchSize - 1))\n    //   + 1 bytes for null terminator\n\n    var maxKeySize = (maxWriteBatchSize - 1).toString(10).length + 2; // Final options for retryable writes and write concern\n\n    var finalOptions = Object.assign({}, options);\n    finalOptions = applyRetryableWrites(finalOptions, collection.s.db);\n    finalOptions = applyWriteConcern(finalOptions, {\n      collection: collection\n    }, options);\n    var writeConcern = finalOptions.writeConcern; // Get the promiseLibrary\n\n    var promiseLibrary = options.promiseLibrary || Promise; // Final results\n\n    var bulkResult = {\n      ok: 1,\n      writeErrors: [],\n      writeConcernErrors: [],\n      insertedIds: [],\n      nInserted: 0,\n      nUpserted: 0,\n      nMatched: 0,\n      nModified: 0,\n      nRemoved: 0,\n      upserted: []\n    }; // Internal state\n\n    this.s = {\n      // Final result\n      bulkResult: bulkResult,\n      // Current batch state\n      currentBatch: null,\n      currentIndex: 0,\n      // ordered specific\n      currentBatchSize: 0,\n      currentBatchSizeBytes: 0,\n      // unordered specific\n      currentInsertBatch: null,\n      currentUpdateBatch: null,\n      currentRemoveBatch: null,\n      batches: [],\n      // Write concern\n      writeConcern: writeConcern,\n      // Max batch size options\n      maxBsonObjectSize: maxBsonObjectSize,\n      maxBatchSizeBytes: maxBatchSizeBytes,\n      maxWriteBatchSize: maxWriteBatchSize,\n      maxKeySize: maxKeySize,\n      // Namespace\n      namespace: namespace,\n      // BSON\n      bson: bson,\n      // Topology\n      topology: topology,\n      // Options\n      options: finalOptions,\n      // Current operation\n      currentOp: currentOp,\n      // Executed\n      executed: executed,\n      // Collection\n      collection: collection,\n      // Promise Library\n      promiseLibrary: promiseLibrary,\n      // Fundamental error\n      err: null,\n      // check keys\n      checkKeys: typeof options.checkKeys === 'boolean' ? options.checkKeys : true\n    }; // bypass Validation\n\n    if (options.bypassDocumentValidation === true) {\n      this.s.bypassDocumentValidation = true;\n    }\n  }\n  /**\n   * Add a single insert document to the bulk operation\n   *\n   * @param {object} document the document to insert\n   * @throws {MongoError}\n   * @return {BulkOperationBase} A reference to self\n   *\n   * @example\n   * const bulkOp = collection.initializeOrderedBulkOp();\n   * // Adds three inserts to the bulkOp.\n   * bulkOp\n   *   .insert({ a: 1 })\n   *   .insert({ b: 2 })\n   *   .insert({ c: 3 });\n   * await bulkOp.execute();\n   */\n\n\n  _createClass(BulkOperationBase, [{\n    key: \"insert\",\n    value: function insert(document) {\n      if (this.s.collection.s.db.options.forceServerObjectId !== true && document._id == null) document._id = new ObjectID();\n      return this.s.options.addToOperationsList(this, INSERT, document);\n    }\n    /**\n     * Builds a find operation for an update/updateOne/delete/deleteOne/replaceOne.\n     * Returns a builder object used to complete the definition of the operation.\n     *\n     * @method\n     * @param {object} selector The selector for the bulk operation. See {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-q q documentation}\n     * @throws {MongoError} if a selector is not specified\n     * @return {FindOperators} A helper object with which the write operation can be defined.\n     *\n     * @example\n     * const bulkOp = collection.initializeOrderedBulkOp();\n     *\n     * // Add an updateOne to the bulkOp\n     * bulkOp.find({ a: 1 }).updateOne({ $set: { b: 2 } });\n     *\n     * // Add an updateMany to the bulkOp\n     * bulkOp.find({ c: 3 }).update({ $set: { d: 4 } });\n     *\n     * // Add an upsert\n     * bulkOp.find({ e: 5 }).upsert().updateOne({ $set: { f: 6 } });\n     *\n     * // Add a deletion\n     * bulkOp.find({ g: 7 }).deleteOne();\n     *\n     * // Add a multi deletion\n     * bulkOp.find({ h: 8 }).delete();\n     *\n     * // Add a replaceOne\n     * bulkOp.find({ i: 9 }).replaceOne({ j: 10 });\n     *\n     * // Update using a pipeline (requires Mongodb 4.2 or higher)\n     * bulk.find({ k: 11, y: { $exists: true }, z: { $exists: true } }).updateOne([\n     *   { $set: { total: { $sum: [ '$y', '$z' ] } } }\n     * ]);\n     *\n     * // All of the ops will now be executed\n     * await bulkOp.execute();\n     */\n\n  }, {\n    key: \"find\",\n    value: function find(selector) {\n      if (!selector) {\n        throw toError('Bulk find operation must specify a selector');\n      } // Save a current selector\n\n\n      this.s.currentOp = {\n        selector: selector\n      };\n      return new FindOperators(this);\n    }\n    /**\n     * Specifies a raw operation to perform in the bulk write.\n     *\n     * @method\n     * @param {object} op The raw operation to perform.\n     * @param {object} [options.hint] An optional hint for query optimization. See the {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-hint|update command} reference for more information.\n     * @return {BulkOperationBase} A reference to self\n     */\n\n  }, {\n    key: \"raw\",\n    value: function raw(op) {\n      var key = Object.keys(op)[0]; // Set up the force server object id\n\n      var forceServerObjectId = typeof this.s.options.forceServerObjectId === 'boolean' ? this.s.options.forceServerObjectId : this.s.collection.s.db.options.forceServerObjectId; // Update operations\n\n      if (op.updateOne && op.updateOne.q || op.updateMany && op.updateMany.q || op.replaceOne && op.replaceOne.q) {\n        op[key].multi = op.updateOne || op.replaceOne ? false : true;\n        return this.s.options.addToOperationsList(this, UPDATE, op[key]);\n      } // Crud spec update format\n\n\n      if (op.updateOne || op.updateMany || op.replaceOne) {\n        var multi = op.updateOne || op.replaceOne ? false : true;\n        var operation = {\n          q: op[key].filter,\n          u: op[key].update || op[key].replacement,\n          multi: multi\n        };\n\n        if (op[key].hint) {\n          operation.hint = op[key].hint;\n        }\n\n        if (this.isOrdered) {\n          operation.upsert = op[key].upsert ? true : false;\n          if (op.collation) operation.collation = op.collation;\n        } else {\n          if (op[key].upsert) operation.upsert = true;\n        }\n\n        if (op[key].arrayFilters) operation.arrayFilters = op[key].arrayFilters;\n        return this.s.options.addToOperationsList(this, UPDATE, operation);\n      } // Remove operations\n\n\n      if (op.removeOne || op.removeMany || op.deleteOne && op.deleteOne.q || op.deleteMany && op.deleteMany.q) {\n        op[key].limit = op.removeOne ? 1 : 0;\n        return this.s.options.addToOperationsList(this, REMOVE, op[key]);\n      } // Crud spec delete operations, less efficient\n\n\n      if (op.deleteOne || op.deleteMany) {\n        var limit = op.deleteOne ? 1 : 0;\n        var _operation = {\n          q: op[key].filter,\n          limit: limit\n        };\n\n        if (this.isOrdered) {\n          if (op.collation) _operation.collation = op.collation;\n        }\n\n        return this.s.options.addToOperationsList(this, REMOVE, _operation);\n      } // Insert operations\n\n\n      if (op.insertOne && op.insertOne.document == null) {\n        if (forceServerObjectId !== true && op.insertOne._id == null) op.insertOne._id = new ObjectID();\n        return this.s.options.addToOperationsList(this, INSERT, op.insertOne);\n      } else if (op.insertOne && op.insertOne.document) {\n        if (forceServerObjectId !== true && op.insertOne.document._id == null) op.insertOne.document._id = new ObjectID();\n        return this.s.options.addToOperationsList(this, INSERT, op.insertOne.document);\n      }\n\n      if (op.insertMany) {\n        for (var i = 0; i < op.insertMany.length; i++) {\n          if (forceServerObjectId !== true && op.insertMany[i]._id == null) op.insertMany[i]._id = new ObjectID();\n          this.s.options.addToOperationsList(this, INSERT, op.insertMany[i]);\n        }\n\n        return;\n      } // No valid type of operation\n\n\n      throw toError('bulkWrite only supports insertOne, insertMany, updateOne, updateMany, removeOne, removeMany, deleteOne, deleteMany');\n    }\n    /**\n     * helper function to assist with promiseOrCallback behavior\n     * @ignore\n     * @param {*} err\n     * @param {*} callback\n     */\n\n  }, {\n    key: \"_handleEarlyError\",\n    value: function _handleEarlyError(err, callback) {\n      if (typeof callback === 'function') {\n        callback(err, null);\n        return;\n      }\n\n      return this.s.promiseLibrary.reject(err);\n    }\n    /**\n     * An internal helper method. Do not invoke directly. Will be going away in the future\n     *\n     * @ignore\n     * @method\n     * @param {class} bulk either OrderedBulkOperation or UnorderdBulkOperation\n     * @param {object} writeConcern\n     * @param {object} options\n     * @param {function} callback\n     */\n\n  }, {\n    key: \"bulkExecute\",\n    value: function bulkExecute(_writeConcern, options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      options = options || {};\n\n      if (typeof _writeConcern === 'function') {\n        callback = _writeConcern;\n      } else if (_writeConcern && typeof _writeConcern === 'object') {\n        this.s.writeConcern = _writeConcern;\n      }\n\n      if (this.s.executed) {\n        var executedError = toError('batch cannot be re-executed');\n        return this._handleEarlyError(executedError, callback);\n      } // If we have current batch\n\n\n      if (this.isOrdered) {\n        if (this.s.currentBatch) this.s.batches.push(this.s.currentBatch);\n      } else {\n        if (this.s.currentInsertBatch) this.s.batches.push(this.s.currentInsertBatch);\n        if (this.s.currentUpdateBatch) this.s.batches.push(this.s.currentUpdateBatch);\n        if (this.s.currentRemoveBatch) this.s.batches.push(this.s.currentRemoveBatch);\n      } // If we have no operations in the bulk raise an error\n\n\n      if (this.s.batches.length === 0) {\n        var emptyBatchError = toError('Invalid Operation, no operations specified');\n        return this._handleEarlyError(emptyBatchError, callback);\n      }\n\n      return {\n        options: options,\n        callback: callback\n      };\n    }\n    /**\n     * The callback format for results\n     * @callback BulkOperationBase~resultCallback\n     * @param {MongoError} error An error instance representing the error during the execution.\n     * @param {BulkWriteResult} result The bulk write result.\n     */\n\n    /**\n     * Execute the bulk operation\n     *\n     * @method\n     * @param {WriteConcern} [_writeConcern] Optional write concern. Can also be specified through options.\n     * @param {object} [options] Optional settings.\n     * @param {(number|string)} [options.w] The write concern.\n     * @param {number} [options.wtimeout] The write concern timeout.\n     * @param {boolean} [options.j=false] Specify a journal write concern.\n     * @param {boolean} [options.fsync=false] Specify a file sync write concern.\n     * @param {BulkOperationBase~resultCallback} [callback] A callback that will be invoked when bulkWrite finishes/errors\n     * @throws {MongoError} Throws error if the bulk object has already been executed\n     * @throws {MongoError} Throws error if the bulk object does not have any operations\n     * @return {Promise|void} returns Promise if no callback passed\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute(_writeConcern, options, callback) {\n      var ret = this.bulkExecute(_writeConcern, options, callback);\n\n      if (!ret || isPromiseLike(ret)) {\n        return ret;\n      }\n\n      options = ret.options;\n      callback = ret.callback;\n      return executeLegacyOperation(this.s.topology, executeCommands, [this, options, callback]);\n    }\n    /**\n     * Handles final options before executing command\n     *\n     * An internal method. Do not invoke. Will not be accessible in the future\n     *\n     * @ignore\n     * @param {object} config\n     * @param {object} config.options\n     * @param {number} config.batch\n     * @param {function} config.resultHandler\n     * @param {function} callback\n     */\n\n  }, {\n    key: \"finalOptionsHandler\",\n    value: function finalOptionsHandler(config, callback) {\n      var finalOptions = Object.assign({\n        ordered: this.isOrdered\n      }, config.options);\n\n      if (this.s.writeConcern != null) {\n        finalOptions.writeConcern = this.s.writeConcern;\n      }\n\n      if (finalOptions.bypassDocumentValidation !== true) {\n        delete finalOptions.bypassDocumentValidation;\n      } // Set an operationIf if provided\n\n\n      if (this.operationId) {\n        config.resultHandler.operationId = this.operationId;\n      } // Serialize functions\n\n\n      if (this.s.options.serializeFunctions) {\n        finalOptions.serializeFunctions = true;\n      } // Ignore undefined\n\n\n      if (this.s.options.ignoreUndefined) {\n        finalOptions.ignoreUndefined = true;\n      } // Is the bypassDocumentValidation options specific\n\n\n      if (this.s.bypassDocumentValidation === true) {\n        finalOptions.bypassDocumentValidation = true;\n      } // Is the checkKeys option disabled\n\n\n      if (this.s.checkKeys === false) {\n        finalOptions.checkKeys = false;\n      }\n\n      if (finalOptions.retryWrites) {\n        if (config.batch.batchType === UPDATE) {\n          finalOptions.retryWrites = finalOptions.retryWrites && !config.batch.operations.some(function (op) {\n            return op.multi;\n          });\n        }\n\n        if (config.batch.batchType === REMOVE) {\n          finalOptions.retryWrites = finalOptions.retryWrites && !config.batch.operations.some(function (op) {\n            return op.limit === 0;\n          });\n        }\n      }\n\n      try {\n        if (config.batch.batchType === INSERT) {\n          this.s.topology.insert(this.s.namespace, config.batch.operations, finalOptions, config.resultHandler);\n        } else if (config.batch.batchType === UPDATE) {\n          this.s.topology.update(this.s.namespace, config.batch.operations, finalOptions, config.resultHandler);\n        } else if (config.batch.batchType === REMOVE) {\n          this.s.topology.remove(this.s.namespace, config.batch.operations, finalOptions, config.resultHandler);\n        }\n      } catch (err) {\n        // Force top level error\n        err.ok = 0; // Merge top level error and return\n\n        handleCallback(callback, null, mergeBatchResults(config.batch, this.s.bulkResult, err, null));\n      }\n    }\n    /**\n     * Handles the write error before executing commands\n     *\n     * An internal helper method. Do not invoke directly. Will be going away in the future\n     *\n     * @ignore\n     * @param {function} callback\n     * @param {BulkWriteResult} writeResult\n     * @param {class} self either OrderedBulkOperation or UnorderedBulkOperation\n     */\n\n  }, {\n    key: \"handleWriteError\",\n    value: function handleWriteError(callback, writeResult) {\n      if (this.s.bulkResult.writeErrors.length > 0) {\n        var msg = this.s.bulkResult.writeErrors[0].errmsg ? this.s.bulkResult.writeErrors[0].errmsg : 'write operation failed';\n        handleCallback(callback, new BulkWriteError(toError({\n          message: msg,\n          code: this.s.bulkResult.writeErrors[0].code,\n          writeErrors: this.s.bulkResult.writeErrors\n        }), writeResult), null);\n        return true;\n      }\n\n      if (writeResult.getWriteConcernError()) {\n        handleCallback(callback, new BulkWriteError(toError(writeResult.getWriteConcernError()), writeResult), null);\n        return true;\n      }\n    }\n  }]);\n\n  return BulkOperationBase;\n}();\n\nObject.defineProperty(BulkOperationBase.prototype, 'length', {\n  enumerable: true,\n  get: function get() {\n    return this.s.currentIndex;\n  }\n}); // Exports symbols\n\nmodule.exports = {\n  Batch: Batch,\n  BulkOperationBase: BulkOperationBase,\n  bson: bson,\n  INSERT: INSERT,\n  UPDATE: UPDATE,\n  REMOVE: REMOVE,\n  BulkWriteError: BulkWriteError\n};","map":{"version":3,"sources":["/Users/S/Desktop/nodeprotake2/node_modules/mongodb/lib/bulk/common.js"],"names":["Long","require","BSON","MongoError","ObjectID","MongoWriteConcernError","toError","handleCallback","applyRetryableWrites","applyWriteConcern","executeLegacyOperation","isPromiseLike","WRITE_CONCERN_ERROR","INSERT","UPDATE","REMOVE","bson","Binary","Code","DBRef","Decimal128","Double","Int32","Map","MaxKey","MinKey","ObjectId","BSONRegExp","Symbol","Timestamp","Batch","batchType","originalZeroIndex","currentIndex","originalIndexes","operations","size","sizeBytes","BulkWriteResult","bulkResult","result","insertedIds","upserted","index","writeErrors","length","lastOp","writeConcernErrors","errmsg","i","err","WriteConcernError","code","toJSON","ok","nInserted","nUpserted","nMatched","nModified","nRemoved","WriteError","op","JSON","stringify","mergeBatchResults","batch","writeError","message","push","opTime","lastOpTS","lastOpT","_bsontype","greaterThan","ts","fromNumber","t","opTimeTS","opTimeT","equals","n","Array","isArray","_id","writeConcernError","executeCommands","bulkOperation","options","callback","s","batches","shift","resultHandler","driver","handleMongoWriteConcernError","writeResult","mergeResult","handleWriteError","finalOptionsHandler","wrappedWriteConcernError","BulkWriteError","error","errMessage","Object","assign","name","FindOperators","updateDocument","upsert","currentOp","document","q","selector","u","multi","hint","addToOperationsList","updateOne","limit","deleteOne","delete","BulkOperationBase","topology","collection","isOrdered","namespace","executed","isMaster","lastIsMaster","usingAutoEncryption","autoEncrypter","maxBsonObjectSize","maxBatchSizeBytes","maxWriteBatchSize","maxKeySize","toString","finalOptions","db","writeConcern","promiseLibrary","Promise","currentBatch","currentBatchSize","currentBatchSizeBytes","currentInsertBatch","currentUpdateBatch","currentRemoveBatch","checkKeys","bypassDocumentValidation","forceServerObjectId","key","keys","updateMany","replaceOne","operation","filter","update","replacement","collation","arrayFilters","removeOne","removeMany","deleteMany","insertOne","insertMany","reject","_writeConcern","executedError","_handleEarlyError","emptyBatchError","ret","bulkExecute","config","ordered","operationId","serializeFunctions","ignoreUndefined","retryWrites","some","insert","remove","msg","getWriteConcernError","defineProperty","prototype","enumerable","get","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Long = require('../core').BSON.Long;\nconst MongoError = require('../core').MongoError;\nconst ObjectID = require('../core').BSON.ObjectID;\nconst BSON = require('../core').BSON;\nconst MongoWriteConcernError = require('../core').MongoWriteConcernError;\nconst toError = require('../utils').toError;\nconst handleCallback = require('../utils').handleCallback;\nconst applyRetryableWrites = require('../utils').applyRetryableWrites;\nconst applyWriteConcern = require('../utils').applyWriteConcern;\nconst executeLegacyOperation = require('../utils').executeLegacyOperation;\nconst isPromiseLike = require('../utils').isPromiseLike;\n\n// Error codes\nconst WRITE_CONCERN_ERROR = 64;\n\n// Insert types\nconst INSERT = 1;\nconst UPDATE = 2;\nconst REMOVE = 3;\n\nconst bson = new BSON([\n  BSON.Binary,\n  BSON.Code,\n  BSON.DBRef,\n  BSON.Decimal128,\n  BSON.Double,\n  BSON.Int32,\n  BSON.Long,\n  BSON.Map,\n  BSON.MaxKey,\n  BSON.MinKey,\n  BSON.ObjectId,\n  BSON.BSONRegExp,\n  BSON.Symbol,\n  BSON.Timestamp\n]);\n\n/**\n * Keeps the state of a unordered batch so we can rewrite the results\n * correctly after command execution\n * @ignore\n */\nclass Batch {\n  constructor(batchType, originalZeroIndex) {\n    this.originalZeroIndex = originalZeroIndex;\n    this.currentIndex = 0;\n    this.originalIndexes = [];\n    this.batchType = batchType;\n    this.operations = [];\n    this.size = 0;\n    this.sizeBytes = 0;\n  }\n}\n\n/**\n * @classdesc\n * The result of a bulk write.\n */\nclass BulkWriteResult {\n  /**\n   * Create a new BulkWriteResult instance\n   *\n   * **NOTE:** Internal Type, do not instantiate directly\n   */\n  constructor(bulkResult) {\n    this.result = bulkResult;\n  }\n\n  /**\n   * Evaluates to true if the bulk operation correctly executes\n   * @type {boolean}\n   */\n  get ok() {\n    return this.result.ok;\n  }\n\n  /**\n   * The number of inserted documents\n   * @type {number}\n   */\n  get nInserted() {\n    return this.result.nInserted;\n  }\n\n  /**\n   * Number of upserted documents\n   * @type {number}\n   */\n  get nUpserted() {\n    return this.result.nUpserted;\n  }\n\n  /**\n   * Number of matched documents\n   * @type {number}\n   */\n  get nMatched() {\n    return this.result.nMatched;\n  }\n\n  /**\n   * Number of documents updated physically on disk\n   * @type {number}\n   */\n  get nModified() {\n    return this.result.nModified;\n  }\n\n  /**\n   * Number of removed documents\n   * @type {number}\n   */\n  get nRemoved() {\n    return this.result.nRemoved;\n  }\n\n  /**\n   * Returns an array of all inserted ids\n   *\n   * @return {object[]}\n   */\n  getInsertedIds() {\n    return this.result.insertedIds;\n  }\n\n  /**\n   * Returns an array of all upserted ids\n   *\n   * @return {object[]}\n   */\n  getUpsertedIds() {\n    return this.result.upserted;\n  }\n\n  /**\n   * Returns the upserted id at the given index\n   *\n   * @param {number} index the number of the upserted id to return, returns undefined if no result for passed in index\n   * @return {object}\n   */\n  getUpsertedIdAt(index) {\n    return this.result.upserted[index];\n  }\n\n  /**\n   * Returns raw internal result\n   *\n   * @return {object}\n   */\n  getRawResponse() {\n    return this.result;\n  }\n\n  /**\n   * Returns true if the bulk operation contains a write error\n   *\n   * @return {boolean}\n   */\n  hasWriteErrors() {\n    return this.result.writeErrors.length > 0;\n  }\n\n  /**\n   * Returns the number of write errors off the bulk operation\n   *\n   * @return {number}\n   */\n  getWriteErrorCount() {\n    return this.result.writeErrors.length;\n  }\n\n  /**\n   * Returns a specific write error object\n   *\n   * @param {number} index of the write error to return, returns null if there is no result for passed in index\n   * @return {WriteError}\n   */\n  getWriteErrorAt(index) {\n    if (index < this.result.writeErrors.length) {\n      return this.result.writeErrors[index];\n    }\n    return null;\n  }\n\n  /**\n   * Retrieve all write errors\n   *\n   * @return {WriteError[]}\n   */\n  getWriteErrors() {\n    return this.result.writeErrors;\n  }\n\n  /**\n   * Retrieve lastOp if available\n   *\n   * @return {object}\n   */\n  getLastOp() {\n    return this.result.lastOp;\n  }\n\n  /**\n   * Retrieve the write concern error if any\n   *\n   * @return {WriteConcernError}\n   */\n  getWriteConcernError() {\n    if (this.result.writeConcernErrors.length === 0) {\n      return null;\n    } else if (this.result.writeConcernErrors.length === 1) {\n      // Return the error\n      return this.result.writeConcernErrors[0];\n    } else {\n      // Combine the errors\n      let errmsg = '';\n      for (let i = 0; i < this.result.writeConcernErrors.length; i++) {\n        const err = this.result.writeConcernErrors[i];\n        errmsg = errmsg + err.errmsg;\n\n        // TODO: Something better\n        if (i === 0) errmsg = errmsg + ' and ';\n      }\n\n      return new WriteConcernError({ errmsg: errmsg, code: WRITE_CONCERN_ERROR });\n    }\n  }\n\n  /**\n   * @return {object}\n   */\n  toJSON() {\n    return this.result;\n  }\n\n  /**\n   * @return {string}\n   */\n  toString() {\n    return `BulkWriteResult(${this.toJSON(this.result)})`;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isOk() {\n    return this.result.ok === 1;\n  }\n}\n\n/**\n * @classdesc An error representing a failure by the server to apply the requested write concern to the bulk operation.\n */\nclass WriteConcernError {\n  /**\n   * Create a new WriteConcernError instance\n   *\n   * **NOTE:** Internal Type, do not instantiate directly\n   */\n  constructor(err) {\n    this.err = err;\n  }\n\n  /**\n   * Write concern error code.\n   * @type {number}\n   */\n  get code() {\n    return this.err.code;\n  }\n\n  /**\n   * Write concern error message.\n   * @type {string}\n   */\n  get errmsg() {\n    return this.err.errmsg;\n  }\n\n  /**\n   * @return {object}\n   */\n  toJSON() {\n    return { code: this.err.code, errmsg: this.err.errmsg };\n  }\n\n  /**\n   * @return {string}\n   */\n  toString() {\n    return `WriteConcernError(${this.err.errmsg})`;\n  }\n}\n\n/**\n * @classdesc An error that occurred during a BulkWrite on the server.\n */\nclass WriteError {\n  /**\n   * Create a new WriteError instance\n   *\n   * **NOTE:** Internal Type, do not instantiate directly\n   */\n  constructor(err) {\n    this.err = err;\n  }\n\n  /**\n   * WriteError code.\n   * @type {number}\n   */\n  get code() {\n    return this.err.code;\n  }\n\n  /**\n   * WriteError original bulk operation index.\n   * @type {number}\n   */\n  get index() {\n    return this.err.index;\n  }\n\n  /**\n   * WriteError message.\n   * @type {string}\n   */\n  get errmsg() {\n    return this.err.errmsg;\n  }\n\n  /**\n   * Returns the underlying operation that caused the error\n   * @return {object}\n   */\n  getOperation() {\n    return this.err.op;\n  }\n\n  /**\n   * @return {object}\n   */\n  toJSON() {\n    return { code: this.err.code, index: this.err.index, errmsg: this.err.errmsg, op: this.err.op };\n  }\n\n  /**\n   * @return {string}\n   */\n  toString() {\n    return `WriteError(${JSON.stringify(this.toJSON())})`;\n  }\n}\n\n/**\n * Merges results into shared data structure\n * @ignore\n */\nfunction mergeBatchResults(batch, bulkResult, err, result) {\n  // If we have an error set the result to be the err object\n  if (err) {\n    result = err;\n  } else if (result && result.result) {\n    result = result.result;\n  } else if (result == null) {\n    return;\n  }\n\n  // Do we have a top level error stop processing and return\n  if (result.ok === 0 && bulkResult.ok === 1) {\n    bulkResult.ok = 0;\n\n    const writeError = {\n      index: 0,\n      code: result.code || 0,\n      errmsg: result.message,\n      op: batch.operations[0]\n    };\n\n    bulkResult.writeErrors.push(new WriteError(writeError));\n    return;\n  } else if (result.ok === 0 && bulkResult.ok === 0) {\n    return;\n  }\n\n  // Deal with opTime if available\n  if (result.opTime || result.lastOp) {\n    const opTime = result.lastOp || result.opTime;\n    let lastOpTS = null;\n    let lastOpT = null;\n\n    // We have a time stamp\n    if (opTime && opTime._bsontype === 'Timestamp') {\n      if (bulkResult.lastOp == null) {\n        bulkResult.lastOp = opTime;\n      } else if (opTime.greaterThan(bulkResult.lastOp)) {\n        bulkResult.lastOp = opTime;\n      }\n    } else {\n      // Existing TS\n      if (bulkResult.lastOp) {\n        lastOpTS =\n          typeof bulkResult.lastOp.ts === 'number'\n            ? Long.fromNumber(bulkResult.lastOp.ts)\n            : bulkResult.lastOp.ts;\n        lastOpT =\n          typeof bulkResult.lastOp.t === 'number'\n            ? Long.fromNumber(bulkResult.lastOp.t)\n            : bulkResult.lastOp.t;\n      }\n\n      // Current OpTime TS\n      const opTimeTS = typeof opTime.ts === 'number' ? Long.fromNumber(opTime.ts) : opTime.ts;\n      const opTimeT = typeof opTime.t === 'number' ? Long.fromNumber(opTime.t) : opTime.t;\n\n      // Compare the opTime's\n      if (bulkResult.lastOp == null) {\n        bulkResult.lastOp = opTime;\n      } else if (opTimeTS.greaterThan(lastOpTS)) {\n        bulkResult.lastOp = opTime;\n      } else if (opTimeTS.equals(lastOpTS)) {\n        if (opTimeT.greaterThan(lastOpT)) {\n          bulkResult.lastOp = opTime;\n        }\n      }\n    }\n  }\n\n  // If we have an insert Batch type\n  if (batch.batchType === INSERT && result.n) {\n    bulkResult.nInserted = bulkResult.nInserted + result.n;\n  }\n\n  // If we have an insert Batch type\n  if (batch.batchType === REMOVE && result.n) {\n    bulkResult.nRemoved = bulkResult.nRemoved + result.n;\n  }\n\n  let nUpserted = 0;\n\n  // We have an array of upserted values, we need to rewrite the indexes\n  if (Array.isArray(result.upserted)) {\n    nUpserted = result.upserted.length;\n\n    for (let i = 0; i < result.upserted.length; i++) {\n      bulkResult.upserted.push({\n        index: result.upserted[i].index + batch.originalZeroIndex,\n        _id: result.upserted[i]._id\n      });\n    }\n  } else if (result.upserted) {\n    nUpserted = 1;\n\n    bulkResult.upserted.push({\n      index: batch.originalZeroIndex,\n      _id: result.upserted\n    });\n  }\n\n  // If we have an update Batch type\n  if (batch.batchType === UPDATE && result.n) {\n    const nModified = result.nModified;\n    bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;\n    bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);\n\n    if (typeof nModified === 'number') {\n      bulkResult.nModified = bulkResult.nModified + nModified;\n    } else {\n      bulkResult.nModified = null;\n    }\n  }\n\n  if (Array.isArray(result.writeErrors)) {\n    for (let i = 0; i < result.writeErrors.length; i++) {\n      const writeError = {\n        index: batch.originalIndexes[result.writeErrors[i].index],\n        code: result.writeErrors[i].code,\n        errmsg: result.writeErrors[i].errmsg,\n        op: batch.operations[result.writeErrors[i].index]\n      };\n\n      bulkResult.writeErrors.push(new WriteError(writeError));\n    }\n  }\n\n  if (result.writeConcernError) {\n    bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));\n  }\n}\n\nfunction executeCommands(bulkOperation, options, callback) {\n  if (bulkOperation.s.batches.length === 0) {\n    return handleCallback(callback, null, new BulkWriteResult(bulkOperation.s.bulkResult));\n  }\n\n  const batch = bulkOperation.s.batches.shift();\n\n  function resultHandler(err, result) {\n    // Error is a driver related error not a bulk op error, terminate\n    if (((err && err.driver) || (err && err.message)) && !(err instanceof MongoWriteConcernError)) {\n      return handleCallback(callback, err);\n    }\n\n    // If we have and error\n    if (err) err.ok = 0;\n    if (err instanceof MongoWriteConcernError) {\n      return handleMongoWriteConcernError(batch, bulkOperation.s.bulkResult, err, callback);\n    }\n\n    // Merge the results together\n    const writeResult = new BulkWriteResult(bulkOperation.s.bulkResult);\n    const mergeResult = mergeBatchResults(batch, bulkOperation.s.bulkResult, err, result);\n    if (mergeResult != null) {\n      return handleCallback(callback, null, writeResult);\n    }\n\n    if (bulkOperation.handleWriteError(callback, writeResult)) return;\n\n    // Execute the next command in line\n    executeCommands(bulkOperation, options, callback);\n  }\n\n  bulkOperation.finalOptionsHandler({ options, batch, resultHandler }, callback);\n}\n\n/**\n * handles write concern error\n *\n * @ignore\n * @param {object} batch\n * @param {object} bulkResult\n * @param {boolean} ordered\n * @param {WriteConcernError} err\n * @param {function} callback\n */\nfunction handleMongoWriteConcernError(batch, bulkResult, err, callback) {\n  mergeBatchResults(batch, bulkResult, null, err.result);\n\n  const wrappedWriteConcernError = new WriteConcernError({\n    errmsg: err.result.writeConcernError.errmsg,\n    code: err.result.writeConcernError.result\n  });\n  return handleCallback(\n    callback,\n    new BulkWriteError(toError(wrappedWriteConcernError), new BulkWriteResult(bulkResult)),\n    null\n  );\n}\n\n/**\n * @classdesc An error indicating an unsuccessful Bulk Write\n */\nclass BulkWriteError extends MongoError {\n  /**\n   * Creates a new BulkWriteError\n   *\n   * @param {Error|string|object} message The error message\n   * @param {BulkWriteResult} result The result of the bulk write operation\n   * @extends {MongoError}\n   */\n  constructor(error, result) {\n    const message = error.err || error.errmsg || error.errMessage || error;\n    super(message);\n\n    Object.assign(this, error);\n\n    this.name = 'BulkWriteError';\n    this.result = result;\n  }\n}\n\n/**\n * @classdesc A builder object that is returned from {@link BulkOperationBase#find}.\n * Is used to build a write operation that involves a query filter.\n */\nclass FindOperators {\n  /**\n   * Creates a new FindOperators object.\n   *\n   * **NOTE:** Internal Type, do not instantiate directly\n   * @param {OrderedBulkOperation|UnorderedBulkOperation} bulkOperation\n   */\n  constructor(bulkOperation) {\n    this.s = bulkOperation.s;\n  }\n\n  /**\n   * Add a multiple update operation to the bulk operation\n   *\n   * @method\n   * @param {object} updateDocument An update field for an update operation. See {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-u u documentation}\n   * @param {object} [options.hint] An optional hint for query optimization. See the {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-hint|update command} reference for more information.\n   * @throws {MongoError} If operation cannot be added to bulk write\n   * @return {OrderedBulkOperation|UnorderedBulkOperation} A reference to the parent BulkOperation\n   */\n  update(updateDocument) {\n    // Perform upsert\n    const upsert = typeof this.s.currentOp.upsert === 'boolean' ? this.s.currentOp.upsert : false;\n\n    // Establish the update command\n    const document = {\n      q: this.s.currentOp.selector,\n      u: updateDocument,\n      multi: true,\n      upsert: upsert\n    };\n\n    if (updateDocument.hint) {\n      document.hint = updateDocument.hint;\n    }\n\n    // Clear out current Op\n    this.s.currentOp = null;\n    return this.s.options.addToOperationsList(this, UPDATE, document);\n  }\n\n  /**\n   * Add a single update operation to the bulk operation\n   *\n   * @method\n   * @param {object} updateDocument An update field for an update operation. See {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-u u documentation}\n   * @param {object} [options.hint] An optional hint for query optimization. See the {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-hint|update command} reference for more information.\n   * @throws {MongoError} If operation cannot be added to bulk write\n   * @return {OrderedBulkOperation|UnorderedBulkOperation} A reference to the parent BulkOperation\n   */\n  updateOne(updateDocument) {\n    // Perform upsert\n    const upsert = typeof this.s.currentOp.upsert === 'boolean' ? this.s.currentOp.upsert : false;\n\n    // Establish the update command\n    const document = {\n      q: this.s.currentOp.selector,\n      u: updateDocument,\n      multi: false,\n      upsert: upsert\n    };\n\n    if (updateDocument.hint) {\n      document.hint = updateDocument.hint;\n    }\n\n    // Clear out current Op\n    this.s.currentOp = null;\n    return this.s.options.addToOperationsList(this, UPDATE, document);\n  }\n\n  /**\n   * Add a replace one operation to the bulk operation\n   *\n   * @method\n   * @param {object} updateDocument the new document to replace the existing one with\n   * @throws {MongoError} If operation cannot be added to bulk write\n   * @return {OrderedBulkOperation|UnorderedBulkOperation} A reference to the parent BulkOperation\n   */\n  replaceOne(updateDocument) {\n    this.updateOne(updateDocument);\n  }\n\n  /**\n   * Upsert modifier for update bulk operation, noting that this operation is an upsert.\n   *\n   * @method\n   * @throws {MongoError} If operation cannot be added to bulk write\n   * @return {FindOperators} reference to self\n   */\n  upsert() {\n    this.s.currentOp.upsert = true;\n    return this;\n  }\n\n  /**\n   * Add a delete one operation to the bulk operation\n   *\n   * @method\n   * @throws {MongoError} If operation cannot be added to bulk write\n   * @return {OrderedBulkOperation|UnorderedBulkOperation} A reference to the parent BulkOperation\n   */\n  deleteOne() {\n    // Establish the update command\n    const document = {\n      q: this.s.currentOp.selector,\n      limit: 1\n    };\n\n    // Clear out current Op\n    this.s.currentOp = null;\n    return this.s.options.addToOperationsList(this, REMOVE, document);\n  }\n\n  /**\n   * Add a delete many operation to the bulk operation\n   *\n   * @method\n   * @throws {MongoError} If operation cannot be added to bulk write\n   * @return {OrderedBulkOperation|UnorderedBulkOperation} A reference to the parent BulkOperation\n   */\n  delete() {\n    // Establish the update command\n    const document = {\n      q: this.s.currentOp.selector,\n      limit: 0\n    };\n\n    // Clear out current Op\n    this.s.currentOp = null;\n    return this.s.options.addToOperationsList(this, REMOVE, document);\n  }\n\n  /**\n   * backwards compatability for deleteOne\n   */\n  removeOne() {\n    return this.deleteOne();\n  }\n\n  /**\n   * backwards compatability for delete\n   */\n  remove() {\n    return this.delete();\n  }\n}\n\n/**\n * @classdesc Parent class to OrderedBulkOperation and UnorderedBulkOperation\n *\n * **NOTE:** Internal Type, do not instantiate directly\n */\nclass BulkOperationBase {\n  /**\n   * Create a new OrderedBulkOperation or UnorderedBulkOperation instance\n   * @property {number} length Get the number of operations in the bulk.\n   */\n  constructor(topology, collection, options, isOrdered) {\n    // determine whether bulkOperation is ordered or unordered\n    this.isOrdered = isOrdered;\n\n    options = options == null ? {} : options;\n    // TODO Bring from driver information in isMaster\n    // Get the namespace for the write operations\n    const namespace = collection.s.namespace;\n    // Used to mark operation as executed\n    const executed = false;\n\n    // Current item\n    const currentOp = null;\n\n    // Handle to the bson serializer, used to calculate running sizes\n    const bson = topology.bson;\n    // Set max byte size\n    const isMaster = topology.lastIsMaster();\n\n    // If we have autoEncryption on, batch-splitting must be done on 2mb chunks, but single documents\n    // over 2mb are still allowed\n    const usingAutoEncryption = !!(topology.s.options && topology.s.options.autoEncrypter);\n    const maxBsonObjectSize =\n      isMaster && isMaster.maxBsonObjectSize ? isMaster.maxBsonObjectSize : 1024 * 1024 * 16;\n    const maxBatchSizeBytes = usingAutoEncryption ? 1024 * 1024 * 2 : maxBsonObjectSize;\n    const maxWriteBatchSize =\n      isMaster && isMaster.maxWriteBatchSize ? isMaster.maxWriteBatchSize : 1000;\n\n    // Calculates the largest possible size of an Array key, represented as a BSON string\n    // element. This calculation:\n    //     1 byte for BSON type\n    //     # of bytes = length of (string representation of (maxWriteBatchSize - 1))\n    //   + 1 bytes for null terminator\n    const maxKeySize = (maxWriteBatchSize - 1).toString(10).length + 2;\n\n    // Final options for retryable writes and write concern\n    let finalOptions = Object.assign({}, options);\n    finalOptions = applyRetryableWrites(finalOptions, collection.s.db);\n    finalOptions = applyWriteConcern(finalOptions, { collection: collection }, options);\n    const writeConcern = finalOptions.writeConcern;\n\n    // Get the promiseLibrary\n    const promiseLibrary = options.promiseLibrary || Promise;\n\n    // Final results\n    const bulkResult = {\n      ok: 1,\n      writeErrors: [],\n      writeConcernErrors: [],\n      insertedIds: [],\n      nInserted: 0,\n      nUpserted: 0,\n      nMatched: 0,\n      nModified: 0,\n      nRemoved: 0,\n      upserted: []\n    };\n\n    // Internal state\n    this.s = {\n      // Final result\n      bulkResult: bulkResult,\n      // Current batch state\n      currentBatch: null,\n      currentIndex: 0,\n      // ordered specific\n      currentBatchSize: 0,\n      currentBatchSizeBytes: 0,\n      // unordered specific\n      currentInsertBatch: null,\n      currentUpdateBatch: null,\n      currentRemoveBatch: null,\n      batches: [],\n      // Write concern\n      writeConcern: writeConcern,\n      // Max batch size options\n      maxBsonObjectSize,\n      maxBatchSizeBytes,\n      maxWriteBatchSize,\n      maxKeySize,\n      // Namespace\n      namespace: namespace,\n      // BSON\n      bson: bson,\n      // Topology\n      topology: topology,\n      // Options\n      options: finalOptions,\n      // Current operation\n      currentOp: currentOp,\n      // Executed\n      executed: executed,\n      // Collection\n      collection: collection,\n      // Promise Library\n      promiseLibrary: promiseLibrary,\n      // Fundamental error\n      err: null,\n      // check keys\n      checkKeys: typeof options.checkKeys === 'boolean' ? options.checkKeys : true\n    };\n\n    // bypass Validation\n    if (options.bypassDocumentValidation === true) {\n      this.s.bypassDocumentValidation = true;\n    }\n  }\n\n  /**\n   * Add a single insert document to the bulk operation\n   *\n   * @param {object} document the document to insert\n   * @throws {MongoError}\n   * @return {BulkOperationBase} A reference to self\n   *\n   * @example\n   * const bulkOp = collection.initializeOrderedBulkOp();\n   * // Adds three inserts to the bulkOp.\n   * bulkOp\n   *   .insert({ a: 1 })\n   *   .insert({ b: 2 })\n   *   .insert({ c: 3 });\n   * await bulkOp.execute();\n   */\n  insert(document) {\n    if (this.s.collection.s.db.options.forceServerObjectId !== true && document._id == null)\n      document._id = new ObjectID();\n    return this.s.options.addToOperationsList(this, INSERT, document);\n  }\n\n  /**\n   * Builds a find operation for an update/updateOne/delete/deleteOne/replaceOne.\n   * Returns a builder object used to complete the definition of the operation.\n   *\n   * @method\n   * @param {object} selector The selector for the bulk operation. See {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-q q documentation}\n   * @throws {MongoError} if a selector is not specified\n   * @return {FindOperators} A helper object with which the write operation can be defined.\n   *\n   * @example\n   * const bulkOp = collection.initializeOrderedBulkOp();\n   *\n   * // Add an updateOne to the bulkOp\n   * bulkOp.find({ a: 1 }).updateOne({ $set: { b: 2 } });\n   *\n   * // Add an updateMany to the bulkOp\n   * bulkOp.find({ c: 3 }).update({ $set: { d: 4 } });\n   *\n   * // Add an upsert\n   * bulkOp.find({ e: 5 }).upsert().updateOne({ $set: { f: 6 } });\n   *\n   * // Add a deletion\n   * bulkOp.find({ g: 7 }).deleteOne();\n   *\n   * // Add a multi deletion\n   * bulkOp.find({ h: 8 }).delete();\n   *\n   * // Add a replaceOne\n   * bulkOp.find({ i: 9 }).replaceOne({ j: 10 });\n   *\n   * // Update using a pipeline (requires Mongodb 4.2 or higher)\n   * bulk.find({ k: 11, y: { $exists: true }, z: { $exists: true } }).updateOne([\n   *   { $set: { total: { $sum: [ '$y', '$z' ] } } }\n   * ]);\n   *\n   * // All of the ops will now be executed\n   * await bulkOp.execute();\n   */\n  find(selector) {\n    if (!selector) {\n      throw toError('Bulk find operation must specify a selector');\n    }\n\n    // Save a current selector\n    this.s.currentOp = {\n      selector: selector\n    };\n\n    return new FindOperators(this);\n  }\n\n  /**\n   * Specifies a raw operation to perform in the bulk write.\n   *\n   * @method\n   * @param {object} op The raw operation to perform.\n   * @param {object} [options.hint] An optional hint for query optimization. See the {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-hint|update command} reference for more information.\n   * @return {BulkOperationBase} A reference to self\n   */\n  raw(op) {\n    const key = Object.keys(op)[0];\n\n    // Set up the force server object id\n    const forceServerObjectId =\n      typeof this.s.options.forceServerObjectId === 'boolean'\n        ? this.s.options.forceServerObjectId\n        : this.s.collection.s.db.options.forceServerObjectId;\n\n    // Update operations\n    if (\n      (op.updateOne && op.updateOne.q) ||\n      (op.updateMany && op.updateMany.q) ||\n      (op.replaceOne && op.replaceOne.q)\n    ) {\n      op[key].multi = op.updateOne || op.replaceOne ? false : true;\n      return this.s.options.addToOperationsList(this, UPDATE, op[key]);\n    }\n\n    // Crud spec update format\n    if (op.updateOne || op.updateMany || op.replaceOne) {\n      const multi = op.updateOne || op.replaceOne ? false : true;\n      const operation = {\n        q: op[key].filter,\n        u: op[key].update || op[key].replacement,\n        multi: multi\n      };\n\n      if (op[key].hint) {\n        operation.hint = op[key].hint;\n      }\n\n      if (this.isOrdered) {\n        operation.upsert = op[key].upsert ? true : false;\n        if (op.collation) operation.collation = op.collation;\n      } else {\n        if (op[key].upsert) operation.upsert = true;\n      }\n      if (op[key].arrayFilters) operation.arrayFilters = op[key].arrayFilters;\n      return this.s.options.addToOperationsList(this, UPDATE, operation);\n    }\n\n    // Remove operations\n    if (\n      op.removeOne ||\n      op.removeMany ||\n      (op.deleteOne && op.deleteOne.q) ||\n      (op.deleteMany && op.deleteMany.q)\n    ) {\n      op[key].limit = op.removeOne ? 1 : 0;\n      return this.s.options.addToOperationsList(this, REMOVE, op[key]);\n    }\n\n    // Crud spec delete operations, less efficient\n    if (op.deleteOne || op.deleteMany) {\n      const limit = op.deleteOne ? 1 : 0;\n      const operation = { q: op[key].filter, limit: limit };\n      if (this.isOrdered) {\n        if (op.collation) operation.collation = op.collation;\n      }\n      return this.s.options.addToOperationsList(this, REMOVE, operation);\n    }\n\n    // Insert operations\n    if (op.insertOne && op.insertOne.document == null) {\n      if (forceServerObjectId !== true && op.insertOne._id == null)\n        op.insertOne._id = new ObjectID();\n      return this.s.options.addToOperationsList(this, INSERT, op.insertOne);\n    } else if (op.insertOne && op.insertOne.document) {\n      if (forceServerObjectId !== true && op.insertOne.document._id == null)\n        op.insertOne.document._id = new ObjectID();\n      return this.s.options.addToOperationsList(this, INSERT, op.insertOne.document);\n    }\n\n    if (op.insertMany) {\n      for (let i = 0; i < op.insertMany.length; i++) {\n        if (forceServerObjectId !== true && op.insertMany[i]._id == null)\n          op.insertMany[i]._id = new ObjectID();\n        this.s.options.addToOperationsList(this, INSERT, op.insertMany[i]);\n      }\n\n      return;\n    }\n\n    // No valid type of operation\n    throw toError(\n      'bulkWrite only supports insertOne, insertMany, updateOne, updateMany, removeOne, removeMany, deleteOne, deleteMany'\n    );\n  }\n\n  /**\n   * helper function to assist with promiseOrCallback behavior\n   * @ignore\n   * @param {*} err\n   * @param {*} callback\n   */\n  _handleEarlyError(err, callback) {\n    if (typeof callback === 'function') {\n      callback(err, null);\n      return;\n    }\n\n    return this.s.promiseLibrary.reject(err);\n  }\n\n  /**\n   * An internal helper method. Do not invoke directly. Will be going away in the future\n   *\n   * @ignore\n   * @method\n   * @param {class} bulk either OrderedBulkOperation or UnorderdBulkOperation\n   * @param {object} writeConcern\n   * @param {object} options\n   * @param {function} callback\n   */\n  bulkExecute(_writeConcern, options, callback) {\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = options || {};\n\n    if (typeof _writeConcern === 'function') {\n      callback = _writeConcern;\n    } else if (_writeConcern && typeof _writeConcern === 'object') {\n      this.s.writeConcern = _writeConcern;\n    }\n\n    if (this.s.executed) {\n      const executedError = toError('batch cannot be re-executed');\n      return this._handleEarlyError(executedError, callback);\n    }\n\n    // If we have current batch\n    if (this.isOrdered) {\n      if (this.s.currentBatch) this.s.batches.push(this.s.currentBatch);\n    } else {\n      if (this.s.currentInsertBatch) this.s.batches.push(this.s.currentInsertBatch);\n      if (this.s.currentUpdateBatch) this.s.batches.push(this.s.currentUpdateBatch);\n      if (this.s.currentRemoveBatch) this.s.batches.push(this.s.currentRemoveBatch);\n    }\n    // If we have no operations in the bulk raise an error\n    if (this.s.batches.length === 0) {\n      const emptyBatchError = toError('Invalid Operation, no operations specified');\n      return this._handleEarlyError(emptyBatchError, callback);\n    }\n    return { options, callback };\n  }\n\n  /**\n   * The callback format for results\n   * @callback BulkOperationBase~resultCallback\n   * @param {MongoError} error An error instance representing the error during the execution.\n   * @param {BulkWriteResult} result The bulk write result.\n   */\n\n  /**\n   * Execute the bulk operation\n   *\n   * @method\n   * @param {WriteConcern} [_writeConcern] Optional write concern. Can also be specified through options.\n   * @param {object} [options] Optional settings.\n   * @param {(number|string)} [options.w] The write concern.\n   * @param {number} [options.wtimeout] The write concern timeout.\n   * @param {boolean} [options.j=false] Specify a journal write concern.\n   * @param {boolean} [options.fsync=false] Specify a file sync write concern.\n   * @param {BulkOperationBase~resultCallback} [callback] A callback that will be invoked when bulkWrite finishes/errors\n   * @throws {MongoError} Throws error if the bulk object has already been executed\n   * @throws {MongoError} Throws error if the bulk object does not have any operations\n   * @return {Promise|void} returns Promise if no callback passed\n   */\n  execute(_writeConcern, options, callback) {\n    const ret = this.bulkExecute(_writeConcern, options, callback);\n    if (!ret || isPromiseLike(ret)) {\n      return ret;\n    }\n\n    options = ret.options;\n    callback = ret.callback;\n\n    return executeLegacyOperation(this.s.topology, executeCommands, [this, options, callback]);\n  }\n\n  /**\n   * Handles final options before executing command\n   *\n   * An internal method. Do not invoke. Will not be accessible in the future\n   *\n   * @ignore\n   * @param {object} config\n   * @param {object} config.options\n   * @param {number} config.batch\n   * @param {function} config.resultHandler\n   * @param {function} callback\n   */\n  finalOptionsHandler(config, callback) {\n    const finalOptions = Object.assign({ ordered: this.isOrdered }, config.options);\n    if (this.s.writeConcern != null) {\n      finalOptions.writeConcern = this.s.writeConcern;\n    }\n\n    if (finalOptions.bypassDocumentValidation !== true) {\n      delete finalOptions.bypassDocumentValidation;\n    }\n\n    // Set an operationIf if provided\n    if (this.operationId) {\n      config.resultHandler.operationId = this.operationId;\n    }\n\n    // Serialize functions\n    if (this.s.options.serializeFunctions) {\n      finalOptions.serializeFunctions = true;\n    }\n\n    // Ignore undefined\n    if (this.s.options.ignoreUndefined) {\n      finalOptions.ignoreUndefined = true;\n    }\n\n    // Is the bypassDocumentValidation options specific\n    if (this.s.bypassDocumentValidation === true) {\n      finalOptions.bypassDocumentValidation = true;\n    }\n\n    // Is the checkKeys option disabled\n    if (this.s.checkKeys === false) {\n      finalOptions.checkKeys = false;\n    }\n\n    if (finalOptions.retryWrites) {\n      if (config.batch.batchType === UPDATE) {\n        finalOptions.retryWrites =\n          finalOptions.retryWrites && !config.batch.operations.some(op => op.multi);\n      }\n\n      if (config.batch.batchType === REMOVE) {\n        finalOptions.retryWrites =\n          finalOptions.retryWrites && !config.batch.operations.some(op => op.limit === 0);\n      }\n    }\n\n    try {\n      if (config.batch.batchType === INSERT) {\n        this.s.topology.insert(\n          this.s.namespace,\n          config.batch.operations,\n          finalOptions,\n          config.resultHandler\n        );\n      } else if (config.batch.batchType === UPDATE) {\n        this.s.topology.update(\n          this.s.namespace,\n          config.batch.operations,\n          finalOptions,\n          config.resultHandler\n        );\n      } else if (config.batch.batchType === REMOVE) {\n        this.s.topology.remove(\n          this.s.namespace,\n          config.batch.operations,\n          finalOptions,\n          config.resultHandler\n        );\n      }\n    } catch (err) {\n      // Force top level error\n      err.ok = 0;\n      // Merge top level error and return\n      handleCallback(callback, null, mergeBatchResults(config.batch, this.s.bulkResult, err, null));\n    }\n  }\n\n  /**\n   * Handles the write error before executing commands\n   *\n   * An internal helper method. Do not invoke directly. Will be going away in the future\n   *\n   * @ignore\n   * @param {function} callback\n   * @param {BulkWriteResult} writeResult\n   * @param {class} self either OrderedBulkOperation or UnorderedBulkOperation\n   */\n  handleWriteError(callback, writeResult) {\n    if (this.s.bulkResult.writeErrors.length > 0) {\n      const msg = this.s.bulkResult.writeErrors[0].errmsg\n        ? this.s.bulkResult.writeErrors[0].errmsg\n        : 'write operation failed';\n\n      handleCallback(\n        callback,\n        new BulkWriteError(\n          toError({\n            message: msg,\n            code: this.s.bulkResult.writeErrors[0].code,\n            writeErrors: this.s.bulkResult.writeErrors\n          }),\n          writeResult\n        ),\n        null\n      );\n      return true;\n    }\n\n    if (writeResult.getWriteConcernError()) {\n      handleCallback(\n        callback,\n        new BulkWriteError(toError(writeResult.getWriteConcernError()), writeResult),\n        null\n      );\n      return true;\n    }\n  }\n}\n\nObject.defineProperty(BulkOperationBase.prototype, 'length', {\n  enumerable: true,\n  get: function() {\n    return this.s.currentIndex;\n  }\n});\n\n// Exports symbols\nmodule.exports = {\n  Batch,\n  BulkOperationBase,\n  bson,\n  INSERT: INSERT,\n  UPDATE: UPDATE,\n  REMOVE: REMOVE,\n  BulkWriteError\n};\n"]},"metadata":{},"sourceType":"script"}