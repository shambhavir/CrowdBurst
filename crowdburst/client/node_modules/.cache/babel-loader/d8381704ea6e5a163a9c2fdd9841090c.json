{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar MongoError = require('../error').MongoError;\n/**\n * Creates a new AuthProvider, which dictates how to authenticate for a given\n * mechanism.\n * @class\n */\n\n\nvar AuthProvider = /*#__PURE__*/function () {\n  function AuthProvider(bson) {\n    _classCallCheck(this, AuthProvider);\n\n    this.bson = bson;\n    this.authStore = [];\n  }\n  /**\n   * Authenticate\n   * @method\n   * @param {SendAuthCommand} sendAuthCommand Writes an auth command directly to a specific connection\n   * @param {Connection[]} connections Connections to authenticate using this authenticator\n   * @param {MongoCredentials} credentials Authentication credentials\n   * @param {authResultCallback} callback The callback to return the result from the authentication\n   */\n\n\n  _createClass(AuthProvider, [{\n    key: \"auth\",\n    value: function auth(sendAuthCommand, connections, credentials, callback) {\n      var _this = this;\n\n      // Total connections\n      var count = connections.length;\n\n      if (count === 0) {\n        callback(null, null);\n        return;\n      } // Valid connections\n\n\n      var numberOfValidConnections = 0;\n      var errorObject = null;\n\n      var execute = function execute(connection) {\n        _this._authenticateSingleConnection(sendAuthCommand, connection, credentials, function (err, r) {\n          // Adjust count\n          count = count - 1; // If we have an error\n\n          if (err) {\n            errorObject = new MongoError(err);\n          } else if (r && (r.$err || r.errmsg)) {\n            errorObject = new MongoError(r);\n          } else {\n            numberOfValidConnections = numberOfValidConnections + 1;\n          } // Still authenticating against other connections.\n\n\n          if (count !== 0) {\n            return;\n          } // We have authenticated all connections\n\n\n          if (numberOfValidConnections > 0) {\n            // Store the auth details\n            _this.addCredentials(credentials); // Return correct authentication\n\n\n            callback(null, true);\n          } else {\n            if (errorObject == null) {\n              errorObject = new MongoError(\"failed to authenticate using \".concat(credentials.mechanism));\n            }\n\n            callback(errorObject, false);\n          }\n        });\n      };\n\n      var executeInNextTick = function executeInNextTick(_connection) {\n        return process.nextTick(function () {\n          return execute(_connection);\n        });\n      }; // For each connection we need to authenticate\n\n\n      while (connections.length > 0) {\n        executeInNextTick(connections.shift());\n      }\n    }\n    /**\n     * Implementation of a single connection authenticating. Is meant to be overridden.\n     * Will error if called directly\n     * @ignore\n     */\n\n  }, {\n    key: \"_authenticateSingleConnection\",\n    value: function _authenticateSingleConnection()\n    /*sendAuthCommand, connection, credentials, callback*/\n    {\n      throw new Error('_authenticateSingleConnection must be overridden');\n    }\n    /**\n     * Adds credentials to store only if it does not exist\n     * @param {MongoCredentials} credentials credentials to add to store\n     */\n\n  }, {\n    key: \"addCredentials\",\n    value: function addCredentials(credentials) {\n      var found = this.authStore.some(function (cred) {\n        return cred.equals(credentials);\n      });\n\n      if (!found) {\n        this.authStore.push(credentials);\n      }\n    }\n    /**\n     * Re authenticate pool\n     * @method\n     * @param {SendAuthCommand} sendAuthCommand Writes an auth command directly to a specific connection\n     * @param {Connection[]} connections Connections to authenticate using this authenticator\n     * @param {authResultCallback} callback The callback to return the result from the authentication\n     */\n\n  }, {\n    key: \"reauthenticate\",\n    value: function reauthenticate(sendAuthCommand, connections, callback) {\n      var authStore = this.authStore.slice(0);\n      var count = authStore.length;\n\n      if (count === 0) {\n        return callback(null, null);\n      }\n\n      for (var i = 0; i < authStore.length; i++) {\n        this.auth(sendAuthCommand, connections, authStore[i], function (err) {\n          count = count - 1;\n\n          if (count === 0) {\n            callback(err, null);\n          }\n        });\n      }\n    }\n    /**\n     * Remove credentials that have been previously stored in the auth provider\n     * @method\n     * @param {string} source Name of database we are removing authStore details about\n     * @return {object}\n     */\n\n  }, {\n    key: \"logout\",\n    value: function logout(source) {\n      this.authStore = this.authStore.filter(function (credentials) {\n        return credentials.source !== source;\n      });\n    }\n  }]);\n\n  return AuthProvider;\n}();\n/**\n * A function that writes authentication commands to a specific connection\n * @callback SendAuthCommand\n * @param {Connection} connection The connection to write to\n * @param {Command} command A command with a toBin method that can be written to a connection\n * @param {AuthWriteCallback} callback Callback called when command response is received\n */\n\n/**\n * A callback for a specific auth command\n * @callback AuthWriteCallback\n * @param {Error} err If command failed, an error from the server\n * @param {object} r The response from the server\n */\n\n/**\n * This is a result from an authentication strategy\n *\n * @callback authResultCallback\n * @param {error} error An error object. Set to null if no error present\n * @param {boolean} result The result of the authentication process\n */\n\n\nmodule.exports = {\n  AuthProvider: AuthProvider\n};","map":{"version":3,"sources":["/Users/S/Desktop/nodeprotake2/node_modules/mongodb/lib/core/auth/auth_provider.js"],"names":["MongoError","require","AuthProvider","bson","authStore","sendAuthCommand","connections","credentials","callback","count","length","numberOfValidConnections","errorObject","execute","connection","_authenticateSingleConnection","err","r","$err","errmsg","addCredentials","mechanism","executeInNextTick","_connection","process","nextTick","shift","Error","found","some","cred","equals","push","slice","i","auth","source","filter","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst MongoError = require('../error').MongoError;\n\n/**\n * Creates a new AuthProvider, which dictates how to authenticate for a given\n * mechanism.\n * @class\n */\nclass AuthProvider {\n  constructor(bson) {\n    this.bson = bson;\n    this.authStore = [];\n  }\n\n  /**\n   * Authenticate\n   * @method\n   * @param {SendAuthCommand} sendAuthCommand Writes an auth command directly to a specific connection\n   * @param {Connection[]} connections Connections to authenticate using this authenticator\n   * @param {MongoCredentials} credentials Authentication credentials\n   * @param {authResultCallback} callback The callback to return the result from the authentication\n   */\n  auth(sendAuthCommand, connections, credentials, callback) {\n    // Total connections\n    let count = connections.length;\n\n    if (count === 0) {\n      callback(null, null);\n      return;\n    }\n\n    // Valid connections\n    let numberOfValidConnections = 0;\n    let errorObject = null;\n\n    const execute = connection => {\n      this._authenticateSingleConnection(sendAuthCommand, connection, credentials, (err, r) => {\n        // Adjust count\n        count = count - 1;\n\n        // If we have an error\n        if (err) {\n          errorObject = new MongoError(err);\n        } else if (r && (r.$err || r.errmsg)) {\n          errorObject = new MongoError(r);\n        } else {\n          numberOfValidConnections = numberOfValidConnections + 1;\n        }\n\n        // Still authenticating against other connections.\n        if (count !== 0) {\n          return;\n        }\n\n        // We have authenticated all connections\n        if (numberOfValidConnections > 0) {\n          // Store the auth details\n          this.addCredentials(credentials);\n          // Return correct authentication\n          callback(null, true);\n        } else {\n          if (errorObject == null) {\n            errorObject = new MongoError(`failed to authenticate using ${credentials.mechanism}`);\n          }\n          callback(errorObject, false);\n        }\n      });\n    };\n\n    const executeInNextTick = _connection => process.nextTick(() => execute(_connection));\n\n    // For each connection we need to authenticate\n    while (connections.length > 0) {\n      executeInNextTick(connections.shift());\n    }\n  }\n\n  /**\n   * Implementation of a single connection authenticating. Is meant to be overridden.\n   * Will error if called directly\n   * @ignore\n   */\n  _authenticateSingleConnection(/*sendAuthCommand, connection, credentials, callback*/) {\n    throw new Error('_authenticateSingleConnection must be overridden');\n  }\n\n  /**\n   * Adds credentials to store only if it does not exist\n   * @param {MongoCredentials} credentials credentials to add to store\n   */\n  addCredentials(credentials) {\n    const found = this.authStore.some(cred => cred.equals(credentials));\n\n    if (!found) {\n      this.authStore.push(credentials);\n    }\n  }\n\n  /**\n   * Re authenticate pool\n   * @method\n   * @param {SendAuthCommand} sendAuthCommand Writes an auth command directly to a specific connection\n   * @param {Connection[]} connections Connections to authenticate using this authenticator\n   * @param {authResultCallback} callback The callback to return the result from the authentication\n   */\n  reauthenticate(sendAuthCommand, connections, callback) {\n    const authStore = this.authStore.slice(0);\n    let count = authStore.length;\n    if (count === 0) {\n      return callback(null, null);\n    }\n\n    for (let i = 0; i < authStore.length; i++) {\n      this.auth(sendAuthCommand, connections, authStore[i], function(err) {\n        count = count - 1;\n        if (count === 0) {\n          callback(err, null);\n        }\n      });\n    }\n  }\n\n  /**\n   * Remove credentials that have been previously stored in the auth provider\n   * @method\n   * @param {string} source Name of database we are removing authStore details about\n   * @return {object}\n   */\n  logout(source) {\n    this.authStore = this.authStore.filter(credentials => credentials.source !== source);\n  }\n}\n\n/**\n * A function that writes authentication commands to a specific connection\n * @callback SendAuthCommand\n * @param {Connection} connection The connection to write to\n * @param {Command} command A command with a toBin method that can be written to a connection\n * @param {AuthWriteCallback} callback Callback called when command response is received\n */\n\n/**\n * A callback for a specific auth command\n * @callback AuthWriteCallback\n * @param {Error} err If command failed, an error from the server\n * @param {object} r The response from the server\n */\n\n/**\n * This is a result from an authentication strategy\n *\n * @callback authResultCallback\n * @param {error} error An error object. Set to null if no error present\n * @param {boolean} result The result of the authentication process\n */\n\nmodule.exports = { AuthProvider };\n"]},"metadata":{},"sourceType":"script"}