{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar applyRetryableWrites = require('../utils').applyRetryableWrites;\n\nvar applyWriteConcern = require('../utils').applyWriteConcern;\n\nvar MongoError = require('../core').MongoError;\n\nvar OperationBase = require('./operation').OperationBase;\n\nvar BulkWriteOperation = /*#__PURE__*/function (_OperationBase) {\n  _inherits(BulkWriteOperation, _OperationBase);\n\n  var _super = _createSuper(BulkWriteOperation);\n\n  function BulkWriteOperation(collection, operations, options) {\n    var _this;\n\n    _classCallCheck(this, BulkWriteOperation);\n\n    _this = _super.call(this, options);\n    _this.collection = collection;\n    _this.operations = operations;\n    return _this;\n  }\n\n  _createClass(BulkWriteOperation, [{\n    key: \"execute\",\n    value: function execute(callback) {\n      var coll = this.collection;\n      var operations = this.operations;\n      var options = this.options; // Add ignoreUndfined\n\n      if (coll.s.options.ignoreUndefined) {\n        options = Object.assign({}, options);\n        options.ignoreUndefined = coll.s.options.ignoreUndefined;\n      } // Create the bulk operation\n\n\n      var bulk = options.ordered === true || options.ordered == null ? coll.initializeOrderedBulkOp(options) : coll.initializeUnorderedBulkOp(options); // Do we have a collation\n\n      var collation = false; // for each op go through and add to the bulk\n\n      try {\n        for (var i = 0; i < operations.length; i++) {\n          // Get the operation type\n          var key = Object.keys(operations[i])[0]; // Check if we have a collation\n\n          if (operations[i][key].collation) {\n            collation = true;\n          } // Pass to the raw bulk\n\n\n          bulk.raw(operations[i]);\n        }\n      } catch (err) {\n        return callback(err, null);\n      } // Final options for retryable writes and write concern\n\n\n      var finalOptions = Object.assign({}, options);\n      finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n      finalOptions = applyWriteConcern(finalOptions, {\n        db: coll.s.db,\n        collection: coll\n      }, options);\n      var writeCon = finalOptions.writeConcern ? finalOptions.writeConcern : {};\n      var capabilities = coll.s.topology.capabilities(); // Did the user pass in a collation, check if our write server supports it\n\n      if (collation && capabilities && !capabilities.commandsTakeCollation) {\n        return callback(new MongoError('server/primary/mongos does not support collation'));\n      } // Execute the bulk\n\n\n      bulk.execute(writeCon, finalOptions, function (err, r) {\n        // We have connection level error\n        if (!r && err) {\n          return callback(err, null);\n        }\n\n        r.insertedCount = r.nInserted;\n        r.matchedCount = r.nMatched;\n        r.modifiedCount = r.nModified || 0;\n        r.deletedCount = r.nRemoved;\n        r.upsertedCount = r.getUpsertedIds().length;\n        r.upsertedIds = {};\n        r.insertedIds = {}; // Update the n\n\n        r.n = r.insertedCount; // Inserted documents\n\n        var inserted = r.getInsertedIds(); // Map inserted ids\n\n        for (var _i = 0; _i < inserted.length; _i++) {\n          r.insertedIds[inserted[_i].index] = inserted[_i]._id;\n        } // Upserted documents\n\n\n        var upserted = r.getUpsertedIds(); // Map upserted ids\n\n        for (var _i2 = 0; _i2 < upserted.length; _i2++) {\n          r.upsertedIds[upserted[_i2].index] = upserted[_i2]._id;\n        } // Return the results\n\n\n        callback(null, r);\n      });\n    }\n  }]);\n\n  return BulkWriteOperation;\n}(OperationBase);\n\nmodule.exports = BulkWriteOperation;","map":{"version":3,"sources":["/Users/S/Desktop/nodeprotake2/node_modules/mongodb/lib/operations/bulk_write.js"],"names":["applyRetryableWrites","require","applyWriteConcern","MongoError","OperationBase","BulkWriteOperation","collection","operations","options","callback","coll","s","ignoreUndefined","Object","assign","bulk","ordered","initializeOrderedBulkOp","initializeUnorderedBulkOp","collation","i","length","key","keys","raw","err","finalOptions","db","writeCon","writeConcern","capabilities","topology","commandsTakeCollation","execute","r","insertedCount","nInserted","matchedCount","nMatched","modifiedCount","nModified","deletedCount","nRemoved","upsertedCount","getUpsertedIds","upsertedIds","insertedIds","n","inserted","getInsertedIds","index","_id","upserted","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst applyRetryableWrites = require('../utils').applyRetryableWrites;\nconst applyWriteConcern = require('../utils').applyWriteConcern;\nconst MongoError = require('../core').MongoError;\nconst OperationBase = require('./operation').OperationBase;\n\nclass BulkWriteOperation extends OperationBase {\n  constructor(collection, operations, options) {\n    super(options);\n\n    this.collection = collection;\n    this.operations = operations;\n  }\n\n  execute(callback) {\n    const coll = this.collection;\n    const operations = this.operations;\n    let options = this.options;\n\n    // Add ignoreUndfined\n    if (coll.s.options.ignoreUndefined) {\n      options = Object.assign({}, options);\n      options.ignoreUndefined = coll.s.options.ignoreUndefined;\n    }\n\n    // Create the bulk operation\n    const bulk =\n      options.ordered === true || options.ordered == null\n        ? coll.initializeOrderedBulkOp(options)\n        : coll.initializeUnorderedBulkOp(options);\n\n    // Do we have a collation\n    let collation = false;\n\n    // for each op go through and add to the bulk\n    try {\n      for (let i = 0; i < operations.length; i++) {\n        // Get the operation type\n        const key = Object.keys(operations[i])[0];\n        // Check if we have a collation\n        if (operations[i][key].collation) {\n          collation = true;\n        }\n\n        // Pass to the raw bulk\n        bulk.raw(operations[i]);\n      }\n    } catch (err) {\n      return callback(err, null);\n    }\n\n    // Final options for retryable writes and write concern\n    let finalOptions = Object.assign({}, options);\n    finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n    finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);\n\n    const writeCon = finalOptions.writeConcern ? finalOptions.writeConcern : {};\n    const capabilities = coll.s.topology.capabilities();\n\n    // Did the user pass in a collation, check if our write server supports it\n    if (collation && capabilities && !capabilities.commandsTakeCollation) {\n      return callback(new MongoError('server/primary/mongos does not support collation'));\n    }\n\n    // Execute the bulk\n    bulk.execute(writeCon, finalOptions, (err, r) => {\n      // We have connection level error\n      if (!r && err) {\n        return callback(err, null);\n      }\n\n      r.insertedCount = r.nInserted;\n      r.matchedCount = r.nMatched;\n      r.modifiedCount = r.nModified || 0;\n      r.deletedCount = r.nRemoved;\n      r.upsertedCount = r.getUpsertedIds().length;\n      r.upsertedIds = {};\n      r.insertedIds = {};\n\n      // Update the n\n      r.n = r.insertedCount;\n\n      // Inserted documents\n      const inserted = r.getInsertedIds();\n      // Map inserted ids\n      for (let i = 0; i < inserted.length; i++) {\n        r.insertedIds[inserted[i].index] = inserted[i]._id;\n      }\n\n      // Upserted documents\n      const upserted = r.getUpsertedIds();\n      // Map upserted ids\n      for (let i = 0; i < upserted.length; i++) {\n        r.upsertedIds[upserted[i].index] = upserted[i]._id;\n      }\n\n      // Return the results\n      callback(null, r);\n    });\n  }\n}\n\nmodule.exports = BulkWriteOperation;\n"]},"metadata":{},"sourceType":"script"}