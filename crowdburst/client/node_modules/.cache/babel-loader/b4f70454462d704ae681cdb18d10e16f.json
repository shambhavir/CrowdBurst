{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Duplex = require('stream').Duplex;\n\nvar BufferList = require('bl');\n\nvar MongoParseError = require('../core/error').MongoParseError;\n\nvar decompress = require('../core/wireprotocol/compression').decompress;\n\nvar Response = require('../core/connection/commands').Response;\n\nvar BinMsg = require('../core/connection/msg').BinMsg;\n\nvar MongoError = require('../core/error').MongoError;\n\nvar OP_COMPRESSED = require('../core/wireprotocol/shared').opcodes.OP_COMPRESSED;\n\nvar OP_MSG = require('../core/wireprotocol/shared').opcodes.OP_MSG;\n\nvar MESSAGE_HEADER_SIZE = require('../core/wireprotocol/shared').MESSAGE_HEADER_SIZE;\n\nvar COMPRESSION_DETAILS_SIZE = require('../core/wireprotocol/shared').COMPRESSION_DETAILS_SIZE;\n\nvar opcodes = require('../core/wireprotocol/shared').opcodes;\n\nvar compress = require('../core/wireprotocol/compression').compress;\n\nvar compressorIDs = require('../core/wireprotocol/compression').compressorIDs;\n\nvar uncompressibleCommands = require('../core/wireprotocol/compression').uncompressibleCommands;\n\nvar Msg = require('../core/connection/msg').Msg;\n\nvar kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;\nvar kBuffer = Symbol('buffer');\n/**\n * A duplex stream that is capable of reading and writing raw wire protocol messages, with\n * support for optional compression\n */\n\nvar MessageStream = /*#__PURE__*/function (_Duplex) {\n  _inherits(MessageStream, _Duplex);\n\n  var _super = _createSuper(MessageStream);\n\n  function MessageStream(options) {\n    var _this;\n\n    _classCallCheck(this, MessageStream);\n\n    options = options || {};\n    _this = _super.call(this, options);\n    _this.bson = options.bson;\n    _this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;\n    _this[kBuffer] = new BufferList();\n    return _this;\n  }\n\n  _createClass(MessageStream, [{\n    key: \"_write\",\n    value: function _write(chunk, _, callback) {\n      var buffer = this[kBuffer];\n      buffer.append(chunk);\n      processIncomingData(this, callback);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read()\n    /* size */\n    {\n      // NOTE: This implementation is empty because we explicitly push data to be read\n      //       when `writeMessage` is called.\n      return;\n    }\n  }, {\n    key: \"writeCommand\",\n    value: function writeCommand(command, operationDescription) {\n      var _this2 = this;\n\n      // TODO: agreed compressor should live in `StreamDescription`\n      var shouldCompress = operationDescription && !!operationDescription.agreedCompressor;\n\n      if (!shouldCompress || !canCompress(command)) {\n        var data = command.toBin();\n        this.push(Array.isArray(data) ? Buffer.concat(data) : data);\n        return;\n      } // otherwise, compress the message\n\n\n      var concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());\n      var messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE); // Extract information needed for OP_COMPRESSED from the uncompressed message\n\n      var originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12); // Compress the message body\n\n      compress({\n        options: operationDescription\n      }, messageToBeCompressed, function (err, compressedMessage) {\n        if (err) {\n          operationDescription.cb(err, null);\n          return;\n        } // Create the msgHeader of OP_COMPRESSED\n\n\n        var msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n        msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0); // messageLength\n\n        msgHeader.writeInt32LE(command.requestId, 4); // requestID\n\n        msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n\n        msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12); // opCode\n        // Create the compression details of OP_COMPRESSED\n\n        var compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n        compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n\n        compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n\n        compressionDetails.writeUInt8(compressorIDs[operationDescription.agreedCompressor], 8); // compressorID\n\n        _this2.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));\n      });\n    }\n  }]);\n\n  return MessageStream;\n}(Duplex); // Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\n\n\nfunction canCompress(command) {\n  var commandDoc = command instanceof Msg ? command.command : command.query;\n  var commandName = Object.keys(commandDoc)[0];\n  return !uncompressibleCommands.has(commandName);\n}\n\nfunction processIncomingData(stream, callback) {\n  var buffer = stream[kBuffer];\n\n  if (buffer.length < 4) {\n    callback();\n    return;\n  }\n\n  var sizeOfMessage = buffer.readInt32LE(0);\n\n  if (sizeOfMessage < 0) {\n    callback(new MongoParseError(\"Invalid message size: \".concat(sizeOfMessage)));\n    return;\n  }\n\n  if (sizeOfMessage > stream.maxBsonMessageSize) {\n    callback(new MongoParseError(\"Invalid message size: \".concat(sizeOfMessage, \", max allowed: \").concat(stream.maxBsonMessageSize)));\n    return;\n  }\n\n  if (sizeOfMessage > buffer.length) {\n    callback();\n    return;\n  }\n\n  var message = buffer.slice(0, sizeOfMessage);\n  buffer.consume(sizeOfMessage);\n  var messageHeader = {\n    length: message.readInt32LE(0),\n    requestId: message.readInt32LE(4),\n    responseTo: message.readInt32LE(8),\n    opCode: message.readInt32LE(12)\n  };\n  var ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;\n  var responseOptions = stream.responseOptions;\n\n  if (messageHeader.opCode !== OP_COMPRESSED) {\n    var messageBody = message.slice(MESSAGE_HEADER_SIZE);\n    stream.emit('message', new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions));\n\n    if (buffer.length >= 4) {\n      processIncomingData(stream, callback);\n    } else {\n      callback();\n    }\n\n    return;\n  }\n\n  messageHeader.fromCompressed = true;\n  messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);\n  messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);\n  var compressorID = message[MESSAGE_HEADER_SIZE + 8];\n  var compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9); // recalculate based on wrapped opcode\n\n  ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;\n  decompress(compressorID, compressedBuffer, function (err, messageBody) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (messageBody.length !== messageHeader.length) {\n      callback(new MongoError('Decompressing a compressed message from the server failed. The message is corrupt.'));\n      return;\n    }\n\n    stream.emit('message', new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions));\n\n    if (buffer.length >= 4) {\n      processIncomingData(stream, callback);\n    } else {\n      callback();\n    }\n  });\n}\n\nmodule.exports = MessageStream;","map":{"version":3,"sources":["/Users/S/Desktop/nodeprotake2/node_modules/mongodb/lib/cmap/message_stream.js"],"names":["Duplex","require","BufferList","MongoParseError","decompress","Response","BinMsg","MongoError","OP_COMPRESSED","opcodes","OP_MSG","MESSAGE_HEADER_SIZE","COMPRESSION_DETAILS_SIZE","compress","compressorIDs","uncompressibleCommands","Msg","kDefaultMaxBsonMessageSize","kBuffer","Symbol","MessageStream","options","bson","maxBsonMessageSize","chunk","_","callback","buffer","append","processIncomingData","command","operationDescription","shouldCompress","agreedCompressor","canCompress","data","toBin","push","Array","isArray","Buffer","concat","concatenatedOriginalCommandBuffer","messageToBeCompressed","slice","originalCommandOpCode","readInt32LE","err","compressedMessage","cb","msgHeader","alloc","writeInt32LE","length","requestId","compressionDetails","writeUInt8","commandDoc","query","commandName","Object","keys","has","stream","sizeOfMessage","message","consume","messageHeader","responseTo","opCode","ResponseType","responseOptions","messageBody","emit","fromCompressed","compressorID","compressedBuffer","module","exports"],"mappings":"AAAA;;;;;;;;;;AAEA,IAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAP,CAAkBD,MAAjC;;AACA,IAAME,UAAU,GAAGD,OAAO,CAAC,IAAD,CAA1B;;AACA,IAAME,eAAe,GAAGF,OAAO,CAAC,eAAD,CAAP,CAAyBE,eAAjD;;AACA,IAAMC,UAAU,GAAGH,OAAO,CAAC,kCAAD,CAAP,CAA4CG,UAA/D;;AACA,IAAMC,QAAQ,GAAGJ,OAAO,CAAC,6BAAD,CAAP,CAAuCI,QAAxD;;AACA,IAAMC,MAAM,GAAGL,OAAO,CAAC,wBAAD,CAAP,CAAkCK,MAAjD;;AACA,IAAMC,UAAU,GAAGN,OAAO,CAAC,eAAD,CAAP,CAAyBM,UAA5C;;AACA,IAAMC,aAAa,GAAGP,OAAO,CAAC,6BAAD,CAAP,CAAuCQ,OAAvC,CAA+CD,aAArE;;AACA,IAAME,MAAM,GAAGT,OAAO,CAAC,6BAAD,CAAP,CAAuCQ,OAAvC,CAA+CC,MAA9D;;AACA,IAAMC,mBAAmB,GAAGV,OAAO,CAAC,6BAAD,CAAP,CAAuCU,mBAAnE;;AACA,IAAMC,wBAAwB,GAAGX,OAAO,CAAC,6BAAD,CAAP,CAAuCW,wBAAxE;;AACA,IAAMH,OAAO,GAAGR,OAAO,CAAC,6BAAD,CAAP,CAAuCQ,OAAvD;;AACA,IAAMI,QAAQ,GAAGZ,OAAO,CAAC,kCAAD,CAAP,CAA4CY,QAA7D;;AACA,IAAMC,aAAa,GAAGb,OAAO,CAAC,kCAAD,CAAP,CAA4Ca,aAAlE;;AACA,IAAMC,sBAAsB,GAAGd,OAAO,CAAC,kCAAD,CAAP,CAA4Cc,sBAA3E;;AACA,IAAMC,GAAG,GAAGf,OAAO,CAAC,wBAAD,CAAP,CAAkCe,GAA9C;;AAEA,IAAMC,0BAA0B,GAAG,OAAO,IAAP,GAAc,EAAd,GAAmB,CAAtD;AACA,IAAMC,OAAO,GAAGC,MAAM,CAAC,QAAD,CAAtB;AAEA;;;;;IAIMC,a;;;;;AACJ,yBAAYC,OAAZ,EAAqB;AAAA;;AAAA;;AACnBA,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACA,8BAAMA,OAAN;AAEA,UAAKC,IAAL,GAAYD,OAAO,CAACC,IAApB;AACA,UAAKC,kBAAL,GAA0BF,OAAO,CAACE,kBAAR,IAA8BN,0BAAxD;AAEA,UAAKC,OAAL,IAAgB,IAAIhB,UAAJ,EAAhB;AAPmB;AAQpB;;;;2BAEMsB,K,EAAOC,C,EAAGC,Q,EAAU;AACzB,UAAMC,MAAM,GAAG,KAAKT,OAAL,CAAf;AACAS,MAAAA,MAAM,CAACC,MAAP,CAAcJ,KAAd;AAEAK,MAAAA,mBAAmB,CAAC,IAAD,EAAOH,QAAP,CAAnB;AACD;;;;AAEK;AAAY;AAChB;AACA;AACA;AACD;;;iCAEYI,O,EAASC,oB,EAAsB;AAAA;;AAC1C;AACA,UAAMC,cAAc,GAAGD,oBAAoB,IAAI,CAAC,CAACA,oBAAoB,CAACE,gBAAtE;;AACA,UAAI,CAACD,cAAD,IAAmB,CAACE,WAAW,CAACJ,OAAD,CAAnC,EAA8C;AAC5C,YAAMK,IAAI,GAAGL,OAAO,CAACM,KAAR,EAAb;AACA,aAAKC,IAAL,CAAUC,KAAK,CAACC,OAAN,CAAcJ,IAAd,IAAsBK,MAAM,CAACC,MAAP,CAAcN,IAAd,CAAtB,GAA4CA,IAAtD;AACA;AACD,OAPyC,CAS1C;;;AACA,UAAMO,iCAAiC,GAAGF,MAAM,CAACC,MAAP,CAAcX,OAAO,CAACM,KAAR,EAAd,CAA1C;AACA,UAAMO,qBAAqB,GAAGD,iCAAiC,CAACE,KAAlC,CAAwCjC,mBAAxC,CAA9B,CAX0C,CAa1C;;AACA,UAAMkC,qBAAqB,GAAGH,iCAAiC,CAACI,WAAlC,CAA8C,EAA9C,CAA9B,CAd0C,CAgB1C;;AACAjC,MAAAA,QAAQ,CAAC;AAAEQ,QAAAA,OAAO,EAAEU;AAAX,OAAD,EAAoCY,qBAApC,EAA2D,UAACI,GAAD,EAAMC,iBAAN,EAA4B;AAC7F,YAAID,GAAJ,EAAS;AACPhB,UAAAA,oBAAoB,CAACkB,EAArB,CAAwBF,GAAxB,EAA6B,IAA7B;AACA;AACD,SAJ4F,CAM7F;;;AACA,YAAMG,SAAS,GAAGV,MAAM,CAACW,KAAP,CAAaxC,mBAAb,CAAlB;AACAuC,QAAAA,SAAS,CAACE,YAAV,CACEzC,mBAAmB,GAAGC,wBAAtB,GAAiDoC,iBAAiB,CAACK,MADrE,EAEE,CAFF,EAR6F,CAW1F;;AACHH,QAAAA,SAAS,CAACE,YAAV,CAAuBtB,OAAO,CAACwB,SAA/B,EAA0C,CAA1C,EAZ6F,CAY/C;;AAC9CJ,QAAAA,SAAS,CAACE,YAAV,CAAuB,CAAvB,EAA0B,CAA1B,EAb6F,CAa/D;;AAC9BF,QAAAA,SAAS,CAACE,YAAV,CAAuB3C,OAAO,CAACD,aAA/B,EAA8C,EAA9C,EAd6F,CAc1C;AAEnD;;AACA,YAAM+C,kBAAkB,GAAGf,MAAM,CAACW,KAAP,CAAavC,wBAAb,CAA3B;AACA2C,QAAAA,kBAAkB,CAACH,YAAnB,CAAgCP,qBAAhC,EAAuD,CAAvD,EAlB6F,CAkBlC;;AAC3DU,QAAAA,kBAAkB,CAACH,YAAnB,CAAgCT,qBAAqB,CAACU,MAAtD,EAA8D,CAA9D,EAnB6F,CAmB3B;;AAClEE,QAAAA,kBAAkB,CAACC,UAAnB,CAA8B1C,aAAa,CAACiB,oBAAoB,CAACE,gBAAtB,CAA3C,EAAoF,CAApF,EApB6F,CAoBL;;AAExF,QAAA,MAAI,CAACI,IAAL,CAAUG,MAAM,CAACC,MAAP,CAAc,CAACS,SAAD,EAAYK,kBAAZ,EAAgCP,iBAAhC,CAAd,CAAV;AACD,OAvBO,CAAR;AAwBD;;;;EAjEyBhD,M,GAoE5B;AACA;;;AACA,SAASkC,WAAT,CAAqBJ,OAArB,EAA8B;AAC5B,MAAM2B,UAAU,GAAG3B,OAAO,YAAYd,GAAnB,GAAyBc,OAAO,CAACA,OAAjC,GAA2CA,OAAO,CAAC4B,KAAtE;AACA,MAAMC,WAAW,GAAGC,MAAM,CAACC,IAAP,CAAYJ,UAAZ,EAAwB,CAAxB,CAApB;AACA,SAAO,CAAC1C,sBAAsB,CAAC+C,GAAvB,CAA2BH,WAA3B,CAAR;AACD;;AAED,SAAS9B,mBAAT,CAA6BkC,MAA7B,EAAqCrC,QAArC,EAA+C;AAC7C,MAAMC,MAAM,GAAGoC,MAAM,CAAC7C,OAAD,CAArB;;AACA,MAAIS,MAAM,CAAC0B,MAAP,GAAgB,CAApB,EAAuB;AACrB3B,IAAAA,QAAQ;AACR;AACD;;AAED,MAAMsC,aAAa,GAAGrC,MAAM,CAACmB,WAAP,CAAmB,CAAnB,CAAtB;;AACA,MAAIkB,aAAa,GAAG,CAApB,EAAuB;AACrBtC,IAAAA,QAAQ,CAAC,IAAIvB,eAAJ,iCAA6C6D,aAA7C,EAAD,CAAR;AACA;AACD;;AAED,MAAIA,aAAa,GAAGD,MAAM,CAACxC,kBAA3B,EAA+C;AAC7CG,IAAAA,QAAQ,CACN,IAAIvB,eAAJ,iCAC2B6D,aAD3B,4BAC0DD,MAAM,CAACxC,kBADjE,EADM,CAAR;AAKA;AACD;;AAED,MAAIyC,aAAa,GAAGrC,MAAM,CAAC0B,MAA3B,EAAmC;AACjC3B,IAAAA,QAAQ;AACR;AACD;;AAED,MAAMuC,OAAO,GAAGtC,MAAM,CAACiB,KAAP,CAAa,CAAb,EAAgBoB,aAAhB,CAAhB;AACArC,EAAAA,MAAM,CAACuC,OAAP,CAAeF,aAAf;AAEA,MAAMG,aAAa,GAAG;AACpBd,IAAAA,MAAM,EAAEY,OAAO,CAACnB,WAAR,CAAoB,CAApB,CADY;AAEpBQ,IAAAA,SAAS,EAAEW,OAAO,CAACnB,WAAR,CAAoB,CAApB,CAFS;AAGpBsB,IAAAA,UAAU,EAAEH,OAAO,CAACnB,WAAR,CAAoB,CAApB,CAHQ;AAIpBuB,IAAAA,MAAM,EAAEJ,OAAO,CAACnB,WAAR,CAAoB,EAApB;AAJY,GAAtB;AAOA,MAAIwB,YAAY,GAAGH,aAAa,CAACE,MAAd,KAAyB3D,MAAzB,GAAkCJ,MAAlC,GAA2CD,QAA9D;AACA,MAAMkE,eAAe,GAAGR,MAAM,CAACQ,eAA/B;;AACA,MAAIJ,aAAa,CAACE,MAAd,KAAyB7D,aAA7B,EAA4C;AAC1C,QAAMgE,WAAW,GAAGP,OAAO,CAACrB,KAAR,CAAcjC,mBAAd,CAApB;AACAoD,IAAAA,MAAM,CAACU,IAAP,CACE,SADF,EAEE,IAAIH,YAAJ,CAAiBP,MAAM,CAACzC,IAAxB,EAA8B2C,OAA9B,EAAuCE,aAAvC,EAAsDK,WAAtD,EAAmED,eAAnE,CAFF;;AAKA,QAAI5C,MAAM,CAAC0B,MAAP,IAAiB,CAArB,EAAwB;AACtBxB,MAAAA,mBAAmB,CAACkC,MAAD,EAASrC,QAAT,CAAnB;AACD,KAFD,MAEO;AACLA,MAAAA,QAAQ;AACT;;AAED;AACD;;AAEDyC,EAAAA,aAAa,CAACO,cAAd,GAA+B,IAA/B;AACAP,EAAAA,aAAa,CAACE,MAAd,GAAuBJ,OAAO,CAACnB,WAAR,CAAoBnC,mBAApB,CAAvB;AACAwD,EAAAA,aAAa,CAACd,MAAd,GAAuBY,OAAO,CAACnB,WAAR,CAAoBnC,mBAAmB,GAAG,CAA1C,CAAvB;AACA,MAAMgE,YAAY,GAAGV,OAAO,CAACtD,mBAAmB,GAAG,CAAvB,CAA5B;AACA,MAAMiE,gBAAgB,GAAGX,OAAO,CAACrB,KAAR,CAAcjC,mBAAmB,GAAG,CAApC,CAAzB,CA3D6C,CA6D7C;;AACA2D,EAAAA,YAAY,GAAGH,aAAa,CAACE,MAAd,KAAyB3D,MAAzB,GAAkCJ,MAAlC,GAA2CD,QAA1D;AAEAD,EAAAA,UAAU,CAACuE,YAAD,EAAeC,gBAAf,EAAiC,UAAC7B,GAAD,EAAMyB,WAAN,EAAsB;AAC/D,QAAIzB,GAAJ,EAAS;AACPrB,MAAAA,QAAQ,CAACqB,GAAD,CAAR;AACA;AACD;;AAED,QAAIyB,WAAW,CAACnB,MAAZ,KAAuBc,aAAa,CAACd,MAAzC,EAAiD;AAC/C3B,MAAAA,QAAQ,CACN,IAAInB,UAAJ,CACE,oFADF,CADM,CAAR;AAMA;AACD;;AAEDwD,IAAAA,MAAM,CAACU,IAAP,CACE,SADF,EAEE,IAAIH,YAAJ,CAAiBP,MAAM,CAACzC,IAAxB,EAA8B2C,OAA9B,EAAuCE,aAAvC,EAAsDK,WAAtD,EAAmED,eAAnE,CAFF;;AAKA,QAAI5C,MAAM,CAAC0B,MAAP,IAAiB,CAArB,EAAwB;AACtBxB,MAAAA,mBAAmB,CAACkC,MAAD,EAASrC,QAAT,CAAnB;AACD,KAFD,MAEO;AACLA,MAAAA,QAAQ;AACT;AACF,GA1BS,CAAV;AA2BD;;AAEDmD,MAAM,CAACC,OAAP,GAAiB1D,aAAjB","sourcesContent":["'use strict';\n\nconst Duplex = require('stream').Duplex;\nconst BufferList = require('bl');\nconst MongoParseError = require('../core/error').MongoParseError;\nconst decompress = require('../core/wireprotocol/compression').decompress;\nconst Response = require('../core/connection/commands').Response;\nconst BinMsg = require('../core/connection/msg').BinMsg;\nconst MongoError = require('../core/error').MongoError;\nconst OP_COMPRESSED = require('../core/wireprotocol/shared').opcodes.OP_COMPRESSED;\nconst OP_MSG = require('../core/wireprotocol/shared').opcodes.OP_MSG;\nconst MESSAGE_HEADER_SIZE = require('../core/wireprotocol/shared').MESSAGE_HEADER_SIZE;\nconst COMPRESSION_DETAILS_SIZE = require('../core/wireprotocol/shared').COMPRESSION_DETAILS_SIZE;\nconst opcodes = require('../core/wireprotocol/shared').opcodes;\nconst compress = require('../core/wireprotocol/compression').compress;\nconst compressorIDs = require('../core/wireprotocol/compression').compressorIDs;\nconst uncompressibleCommands = require('../core/wireprotocol/compression').uncompressibleCommands;\nconst Msg = require('../core/connection/msg').Msg;\n\nconst kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;\nconst kBuffer = Symbol('buffer');\n\n/**\n * A duplex stream that is capable of reading and writing raw wire protocol messages, with\n * support for optional compression\n */\nclass MessageStream extends Duplex {\n  constructor(options) {\n    options = options || {};\n    super(options);\n\n    this.bson = options.bson;\n    this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;\n\n    this[kBuffer] = new BufferList();\n  }\n\n  _write(chunk, _, callback) {\n    const buffer = this[kBuffer];\n    buffer.append(chunk);\n\n    processIncomingData(this, callback);\n  }\n\n  _read(/* size */) {\n    // NOTE: This implementation is empty because we explicitly push data to be read\n    //       when `writeMessage` is called.\n    return;\n  }\n\n  writeCommand(command, operationDescription) {\n    // TODO: agreed compressor should live in `StreamDescription`\n    const shouldCompress = operationDescription && !!operationDescription.agreedCompressor;\n    if (!shouldCompress || !canCompress(command)) {\n      const data = command.toBin();\n      this.push(Array.isArray(data) ? Buffer.concat(data) : data);\n      return;\n    }\n\n    // otherwise, compress the message\n    const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());\n    const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);\n\n    // Extract information needed for OP_COMPRESSED from the uncompressed message\n    const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);\n\n    // Compress the message body\n    compress({ options: operationDescription }, messageToBeCompressed, (err, compressedMessage) => {\n      if (err) {\n        operationDescription.cb(err, null);\n        return;\n      }\n\n      // Create the msgHeader of OP_COMPRESSED\n      const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n      msgHeader.writeInt32LE(\n        MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length,\n        0\n      ); // messageLength\n      msgHeader.writeInt32LE(command.requestId, 4); // requestID\n      msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n      msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12); // opCode\n\n      // Create the compression details of OP_COMPRESSED\n      const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n      compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n      compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n      compressionDetails.writeUInt8(compressorIDs[operationDescription.agreedCompressor], 8); // compressorID\n\n      this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));\n    });\n  }\n}\n\n// Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\nfunction canCompress(command) {\n  const commandDoc = command instanceof Msg ? command.command : command.query;\n  const commandName = Object.keys(commandDoc)[0];\n  return !uncompressibleCommands.has(commandName);\n}\n\nfunction processIncomingData(stream, callback) {\n  const buffer = stream[kBuffer];\n  if (buffer.length < 4) {\n    callback();\n    return;\n  }\n\n  const sizeOfMessage = buffer.readInt32LE(0);\n  if (sizeOfMessage < 0) {\n    callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}`));\n    return;\n  }\n\n  if (sizeOfMessage > stream.maxBsonMessageSize) {\n    callback(\n      new MongoParseError(\n        `Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`\n      )\n    );\n    return;\n  }\n\n  if (sizeOfMessage > buffer.length) {\n    callback();\n    return;\n  }\n\n  const message = buffer.slice(0, sizeOfMessage);\n  buffer.consume(sizeOfMessage);\n\n  const messageHeader = {\n    length: message.readInt32LE(0),\n    requestId: message.readInt32LE(4),\n    responseTo: message.readInt32LE(8),\n    opCode: message.readInt32LE(12)\n  };\n\n  let ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;\n  const responseOptions = stream.responseOptions;\n  if (messageHeader.opCode !== OP_COMPRESSED) {\n    const messageBody = message.slice(MESSAGE_HEADER_SIZE);\n    stream.emit(\n      'message',\n      new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions)\n    );\n\n    if (buffer.length >= 4) {\n      processIncomingData(stream, callback);\n    } else {\n      callback();\n    }\n\n    return;\n  }\n\n  messageHeader.fromCompressed = true;\n  messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);\n  messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);\n  const compressorID = message[MESSAGE_HEADER_SIZE + 8];\n  const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);\n\n  // recalculate based on wrapped opcode\n  ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;\n\n  decompress(compressorID, compressedBuffer, (err, messageBody) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (messageBody.length !== messageHeader.length) {\n      callback(\n        new MongoError(\n          'Decompressing a compressed message from the server failed. The message is corrupt.'\n        )\n      );\n\n      return;\n    }\n\n    stream.emit(\n      'message',\n      new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions)\n    );\n\n    if (buffer.length >= 4) {\n      processIncomingData(stream, callback);\n    } else {\n      callback();\n    }\n  });\n}\n\nmodule.exports = MessageStream;\n"]},"metadata":{},"sourceType":"script"}