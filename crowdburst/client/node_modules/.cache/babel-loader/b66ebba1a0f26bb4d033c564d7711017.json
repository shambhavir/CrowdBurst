{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar crypto = require('crypto');\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar retrieveBSON = require('../connection/utils').retrieveBSON;\n\nvar MongoError = require('../error').MongoError;\n\nvar AuthProvider = require('./auth_provider').AuthProvider;\n\nvar BSON = retrieveBSON();\nvar Binary = BSON.Binary;\nvar saslprep;\n\ntry {\n  saslprep = require('saslprep');\n} catch (e) {// don't do anything;\n}\n\nvar parsePayload = function parsePayload(payload) {\n  var dict = {};\n  var parts = payload.split(',');\n\n  for (var i = 0; i < parts.length; i++) {\n    var valueParts = parts[i].split('=');\n    dict[valueParts[0]] = valueParts[1];\n  }\n\n  return dict;\n};\n\nvar passwordDigest = function passwordDigest(username, password) {\n  if (typeof username !== 'string') throw new MongoError('username must be a string');\n  if (typeof password !== 'string') throw new MongoError('password must be a string');\n  if (password.length === 0) throw new MongoError('password cannot be empty'); // Use node md5 generator\n\n  var md5 = crypto.createHash('md5'); // Generate keys used for authentication\n\n  md5.update(username + ':mongo:' + password, 'utf8');\n  return md5.digest('hex');\n}; // XOR two buffers\n\n\nfunction xor(a, b) {\n  if (!Buffer.isBuffer(a)) a = Buffer.from(a);\n  if (!Buffer.isBuffer(b)) b = Buffer.from(b);\n  var length = Math.max(a.length, b.length);\n  var res = [];\n\n  for (var i = 0; i < length; i += 1) {\n    res.push(a[i] ^ b[i]);\n  }\n\n  return Buffer.from(res).toString('base64');\n}\n\nfunction H(method, text) {\n  return crypto.createHash(method).update(text).digest();\n}\n\nfunction HMAC(method, key, text) {\n  return crypto.createHmac(method, key).update(text).digest();\n}\n\nvar _hiCache = {};\nvar _hiCacheCount = 0;\n\nvar _hiCachePurge = function _hiCachePurge() {\n  _hiCache = {};\n  _hiCacheCount = 0;\n};\n\nvar hiLengthMap = {\n  sha256: 32,\n  sha1: 20\n};\n\nfunction HI(data, salt, iterations, cryptoMethod) {\n  // omit the work if already generated\n  var key = [data, salt.toString('base64'), iterations].join('_');\n\n  if (_hiCache[key] !== undefined) {\n    return _hiCache[key];\n  } // generate the salt\n\n\n  var saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod); // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n}\n\nfunction compareDigest(lhs, rhs) {\n  if (lhs.length !== rhs.length) {\n    return false;\n  }\n\n  if (typeof crypto.timingSafeEqual === 'function') {\n    return crypto.timingSafeEqual(lhs, rhs);\n  }\n\n  var result = 0;\n\n  for (var i = 0; i < lhs.length; i++) {\n    result |= lhs[i] ^ rhs[i];\n  }\n\n  return result === 0;\n}\n/**\n * Creates a new ScramSHA authentication mechanism\n * @class\n * @extends AuthProvider\n */\n\n\nvar ScramSHA = /*#__PURE__*/function (_AuthProvider) {\n  _inherits(ScramSHA, _AuthProvider);\n\n  var _super = _createSuper(ScramSHA);\n\n  function ScramSHA(bson, cryptoMethod) {\n    var _this;\n\n    _classCallCheck(this, ScramSHA);\n\n    _this = _super.call(this, bson);\n    _this.cryptoMethod = cryptoMethod || 'sha1';\n    return _this;\n  }\n\n  _createClass(ScramSHA, [{\n    key: \"_executeScram\",\n\n    /**\n     * @ignore\n     */\n    value: function _executeScram(sendAuthCommand, connection, credentials, nonce, callback) {\n      var username = credentials.username;\n      var password = credentials.password;\n      var db = credentials.source;\n      var cryptoMethod = this.cryptoMethod;\n      var mechanism = 'SCRAM-SHA-1';\n      var processedPassword;\n\n      if (cryptoMethod === 'sha256') {\n        mechanism = 'SCRAM-SHA-256';\n        processedPassword = saslprep ? saslprep(password) : password;\n      } else {\n        try {\n          processedPassword = passwordDigest(username, password);\n        } catch (e) {\n          return callback(e);\n        }\n      } // Clean up the user\n\n\n      username = username.replace('=', '=3D').replace(',', '=2C'); // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n      // Since the username is not sasl-prep-d, we need to do this here.\n\n      var firstBare = Buffer.concat([Buffer.from('n=', 'utf8'), Buffer.from(username, 'utf8'), Buffer.from(',r=', 'utf8'), Buffer.from(nonce, 'utf8')]); // Build command structure\n\n      var saslStartCmd = {\n        saslStart: 1,\n        mechanism: mechanism,\n        payload: new Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), firstBare])),\n        autoAuthorize: 1\n      }; // Write the commmand on the connection\n\n      sendAuthCommand(connection, \"\".concat(db, \".$cmd\"), saslStartCmd, function (err, r) {\n        var tmpError = ScramSHA._getError(err, r);\n\n        if (tmpError) {\n          return callback(tmpError, null);\n        }\n\n        var payload = Buffer.isBuffer(r.payload) ? new Binary(r.payload) : r.payload;\n        var dict = parsePayload(payload.value());\n        var iterations = parseInt(dict.i, 10);\n\n        if (iterations && iterations < 4096) {\n          callback(new MongoError(\"Server returned an invalid iteration count \".concat(iterations)), false);\n          return;\n        }\n\n        var salt = dict.s;\n        var rnonce = dict.r;\n\n        if (rnonce.startsWith('nonce')) {\n          callback(new MongoError(\"Server returned an invalid nonce: \".concat(rnonce)), false);\n          return;\n        } // Set up start of proof\n\n\n        var withoutProof = \"c=biws,r=\".concat(rnonce);\n        var saltedPassword = HI(processedPassword, Buffer.from(salt, 'base64'), iterations, cryptoMethod);\n        var clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n        var serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n        var storedKey = H(cryptoMethod, clientKey);\n        var authMessage = [firstBare, payload.value().toString('base64'), withoutProof].join(',');\n        var clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n        var clientProof = \"p=\".concat(xor(clientKey, clientSignature));\n        var clientFinal = [withoutProof, clientProof].join(',');\n        var serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n        var saslContinueCmd = {\n          saslContinue: 1,\n          conversationId: r.conversationId,\n          payload: new Binary(Buffer.from(clientFinal))\n        };\n        sendAuthCommand(connection, \"\".concat(db, \".$cmd\"), saslContinueCmd, function (err, r) {\n          if (err || r && typeof r.ok === 'number' && r.ok === 0) {\n            callback(err, r);\n            return;\n          }\n\n          var parsedResponse = parsePayload(r.payload.value());\n\n          if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n            callback(new MongoError('Server returned an invalid signature'));\n            return;\n          }\n\n          if (!r || r.done !== false) {\n            return callback(err, r);\n          }\n\n          var retrySaslContinueCmd = {\n            saslContinue: 1,\n            conversationId: r.conversationId,\n            payload: Buffer.alloc(0)\n          };\n          sendAuthCommand(connection, \"\".concat(db, \".$cmd\"), retrySaslContinueCmd, callback);\n        });\n      });\n    }\n    /**\n     * Implementation of authentication for a single connection\n     * @override\n     */\n\n  }, {\n    key: \"_authenticateSingleConnection\",\n    value: function _authenticateSingleConnection(sendAuthCommand, connection, credentials, callback) {\n      var _this2 = this;\n\n      // Create a random nonce\n      crypto.randomBytes(24, function (err, buff) {\n        if (err) {\n          return callback(err, null);\n        }\n\n        return _this2._executeScram(sendAuthCommand, connection, credentials, buff.toString('base64'), callback);\n      });\n    }\n    /**\n     * Authenticate\n     * @override\n     * @method\n     */\n\n  }, {\n    key: \"auth\",\n    value: function auth(sendAuthCommand, connections, credentials, callback) {\n      this._checkSaslprep();\n\n      _get(_getPrototypeOf(ScramSHA.prototype), \"auth\", this).call(this, sendAuthCommand, connections, credentials, callback);\n    }\n  }, {\n    key: \"_checkSaslprep\",\n    value: function _checkSaslprep() {\n      var cryptoMethod = this.cryptoMethod;\n\n      if (cryptoMethod === 'sha256') {\n        if (!saslprep) {\n          console.warn('Warning: no saslprep library specified. Passwords will not be sanitized');\n        }\n      }\n    }\n  }], [{\n    key: \"_getError\",\n    value: function _getError(err, r) {\n      if (err) {\n        return err;\n      }\n\n      if (r.$err || r.errmsg) {\n        return new MongoError(r);\n      }\n    }\n  }]);\n\n  return ScramSHA;\n}(AuthProvider);\n/**\n * Creates a new ScramSHA1 authentication mechanism\n * @class\n * @extends ScramSHA\n */\n\n\nvar ScramSHA1 = /*#__PURE__*/function (_ScramSHA) {\n  _inherits(ScramSHA1, _ScramSHA);\n\n  var _super2 = _createSuper(ScramSHA1);\n\n  function ScramSHA1(bson) {\n    _classCallCheck(this, ScramSHA1);\n\n    return _super2.call(this, bson, 'sha1');\n  }\n\n  return ScramSHA1;\n}(ScramSHA);\n/**\n * Creates a new ScramSHA256 authentication mechanism\n * @class\n * @extends ScramSHA\n */\n\n\nvar ScramSHA256 = /*#__PURE__*/function (_ScramSHA2) {\n  _inherits(ScramSHA256, _ScramSHA2);\n\n  var _super3 = _createSuper(ScramSHA256);\n\n  function ScramSHA256(bson) {\n    _classCallCheck(this, ScramSHA256);\n\n    return _super3.call(this, bson, 'sha256');\n  }\n\n  return ScramSHA256;\n}(ScramSHA);\n\nmodule.exports = {\n  ScramSHA1: ScramSHA1,\n  ScramSHA256: ScramSHA256\n};","map":{"version":3,"sources":["/Users/S/Desktop/nodeprotake2/node_modules/mongodb/lib/core/auth/scram.js"],"names":["crypto","require","Buffer","retrieveBSON","MongoError","AuthProvider","BSON","Binary","saslprep","e","parsePayload","payload","dict","parts","split","i","length","valueParts","passwordDigest","username","password","md5","createHash","update","digest","xor","a","b","isBuffer","from","Math","max","res","push","toString","H","method","text","HMAC","key","createHmac","_hiCache","_hiCacheCount","_hiCachePurge","hiLengthMap","sha256","sha1","HI","data","salt","iterations","cryptoMethod","join","undefined","saltedData","pbkdf2Sync","compareDigest","lhs","rhs","timingSafeEqual","result","ScramSHA","bson","sendAuthCommand","connection","credentials","nonce","callback","db","source","mechanism","processedPassword","replace","firstBare","concat","saslStartCmd","saslStart","autoAuthorize","err","r","tmpError","_getError","value","parseInt","s","rnonce","startsWith","withoutProof","saltedPassword","clientKey","serverKey","storedKey","authMessage","clientSignature","clientProof","clientFinal","serverSignature","saslContinueCmd","saslContinue","conversationId","ok","parsedResponse","v","done","retrySaslContinueCmd","alloc","randomBytes","buff","_executeScram","connections","_checkSaslprep","console","warn","$err","errmsg","ScramSHA1","ScramSHA256","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst crypto = require('crypto');\nconst Buffer = require('safe-buffer').Buffer;\nconst retrieveBSON = require('../connection/utils').retrieveBSON;\nconst MongoError = require('../error').MongoError;\nconst AuthProvider = require('./auth_provider').AuthProvider;\n\nconst BSON = retrieveBSON();\nconst Binary = BSON.Binary;\n\nlet saslprep;\ntry {\n  saslprep = require('saslprep');\n} catch (e) {\n  // don't do anything;\n}\n\nvar parsePayload = function(payload) {\n  var dict = {};\n  var parts = payload.split(',');\n  for (var i = 0; i < parts.length; i++) {\n    var valueParts = parts[i].split('=');\n    dict[valueParts[0]] = valueParts[1];\n  }\n\n  return dict;\n};\n\nvar passwordDigest = function(username, password) {\n  if (typeof username !== 'string') throw new MongoError('username must be a string');\n  if (typeof password !== 'string') throw new MongoError('password must be a string');\n  if (password.length === 0) throw new MongoError('password cannot be empty');\n  // Use node md5 generator\n  var md5 = crypto.createHash('md5');\n  // Generate keys used for authentication\n  md5.update(username + ':mongo:' + password, 'utf8');\n  return md5.digest('hex');\n};\n\n// XOR two buffers\nfunction xor(a, b) {\n  if (!Buffer.isBuffer(a)) a = Buffer.from(a);\n  if (!Buffer.isBuffer(b)) b = Buffer.from(b);\n  const length = Math.max(a.length, b.length);\n  const res = [];\n\n  for (let i = 0; i < length; i += 1) {\n    res.push(a[i] ^ b[i]);\n  }\n\n  return Buffer.from(res).toString('base64');\n}\n\nfunction H(method, text) {\n  return crypto\n    .createHash(method)\n    .update(text)\n    .digest();\n}\n\nfunction HMAC(method, key, text) {\n  return crypto\n    .createHmac(method, key)\n    .update(text)\n    .digest();\n}\n\nvar _hiCache = {};\nvar _hiCacheCount = 0;\nvar _hiCachePurge = function() {\n  _hiCache = {};\n  _hiCacheCount = 0;\n};\n\nconst hiLengthMap = {\n  sha256: 32,\n  sha1: 20\n};\n\nfunction HI(data, salt, iterations, cryptoMethod) {\n  // omit the work if already generated\n  const key = [data, salt.toString('base64'), iterations].join('_');\n  if (_hiCache[key] !== undefined) {\n    return _hiCache[key];\n  }\n\n  // generate the salt\n  const saltedData = crypto.pbkdf2Sync(\n    data,\n    salt,\n    iterations,\n    hiLengthMap[cryptoMethod],\n    cryptoMethod\n  );\n\n  // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n}\n\nfunction compareDigest(lhs, rhs) {\n  if (lhs.length !== rhs.length) {\n    return false;\n  }\n\n  if (typeof crypto.timingSafeEqual === 'function') {\n    return crypto.timingSafeEqual(lhs, rhs);\n  }\n\n  let result = 0;\n  for (let i = 0; i < lhs.length; i++) {\n    result |= lhs[i] ^ rhs[i];\n  }\n\n  return result === 0;\n}\n\n/**\n * Creates a new ScramSHA authentication mechanism\n * @class\n * @extends AuthProvider\n */\nclass ScramSHA extends AuthProvider {\n  constructor(bson, cryptoMethod) {\n    super(bson);\n    this.cryptoMethod = cryptoMethod || 'sha1';\n  }\n\n  static _getError(err, r) {\n    if (err) {\n      return err;\n    }\n\n    if (r.$err || r.errmsg) {\n      return new MongoError(r);\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  _executeScram(sendAuthCommand, connection, credentials, nonce, callback) {\n    let username = credentials.username;\n    const password = credentials.password;\n    const db = credentials.source;\n\n    const cryptoMethod = this.cryptoMethod;\n    let mechanism = 'SCRAM-SHA-1';\n    let processedPassword;\n\n    if (cryptoMethod === 'sha256') {\n      mechanism = 'SCRAM-SHA-256';\n\n      processedPassword = saslprep ? saslprep(password) : password;\n    } else {\n      try {\n        processedPassword = passwordDigest(username, password);\n      } catch (e) {\n        return callback(e);\n      }\n    }\n\n    // Clean up the user\n    username = username.replace('=', '=3D').replace(',', '=2C');\n\n    // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n    // Since the username is not sasl-prep-d, we need to do this here.\n    const firstBare = Buffer.concat([\n      Buffer.from('n=', 'utf8'),\n      Buffer.from(username, 'utf8'),\n      Buffer.from(',r=', 'utf8'),\n      Buffer.from(nonce, 'utf8')\n    ]);\n\n    // Build command structure\n    const saslStartCmd = {\n      saslStart: 1,\n      mechanism,\n      payload: new Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), firstBare])),\n      autoAuthorize: 1\n    };\n\n    // Write the commmand on the connection\n    sendAuthCommand(connection, `${db}.$cmd`, saslStartCmd, (err, r) => {\n      let tmpError = ScramSHA._getError(err, r);\n      if (tmpError) {\n        return callback(tmpError, null);\n      }\n\n      const payload = Buffer.isBuffer(r.payload) ? new Binary(r.payload) : r.payload;\n      const dict = parsePayload(payload.value());\n\n      const iterations = parseInt(dict.i, 10);\n      if (iterations && iterations < 4096) {\n        callback(new MongoError(`Server returned an invalid iteration count ${iterations}`), false);\n        return;\n      }\n\n      const salt = dict.s;\n      const rnonce = dict.r;\n      if (rnonce.startsWith('nonce')) {\n        callback(new MongoError(`Server returned an invalid nonce: ${rnonce}`), false);\n        return;\n      }\n\n      // Set up start of proof\n      const withoutProof = `c=biws,r=${rnonce}`;\n      const saltedPassword = HI(\n        processedPassword,\n        Buffer.from(salt, 'base64'),\n        iterations,\n        cryptoMethod\n      );\n\n      const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n      const serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n      const storedKey = H(cryptoMethod, clientKey);\n      const authMessage = [firstBare, payload.value().toString('base64'), withoutProof].join(',');\n\n      const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n      const clientProof = `p=${xor(clientKey, clientSignature)}`;\n      const clientFinal = [withoutProof, clientProof].join(',');\n\n      const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n\n      const saslContinueCmd = {\n        saslContinue: 1,\n        conversationId: r.conversationId,\n        payload: new Binary(Buffer.from(clientFinal))\n      };\n\n      sendAuthCommand(connection, `${db}.$cmd`, saslContinueCmd, (err, r) => {\n        if (err || (r && typeof r.ok === 'number' && r.ok === 0)) {\n          callback(err, r);\n          return;\n        }\n\n        const parsedResponse = parsePayload(r.payload.value());\n        if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n          callback(new MongoError('Server returned an invalid signature'));\n          return;\n        }\n\n        if (!r || r.done !== false) {\n          return callback(err, r);\n        }\n\n        const retrySaslContinueCmd = {\n          saslContinue: 1,\n          conversationId: r.conversationId,\n          payload: Buffer.alloc(0)\n        };\n\n        sendAuthCommand(connection, `${db}.$cmd`, retrySaslContinueCmd, callback);\n      });\n    });\n  }\n\n  /**\n   * Implementation of authentication for a single connection\n   * @override\n   */\n  _authenticateSingleConnection(sendAuthCommand, connection, credentials, callback) {\n    // Create a random nonce\n    crypto.randomBytes(24, (err, buff) => {\n      if (err) {\n        return callback(err, null);\n      }\n\n      return this._executeScram(\n        sendAuthCommand,\n        connection,\n        credentials,\n        buff.toString('base64'),\n        callback\n      );\n    });\n  }\n\n  /**\n   * Authenticate\n   * @override\n   * @method\n   */\n  auth(sendAuthCommand, connections, credentials, callback) {\n    this._checkSaslprep();\n    super.auth(sendAuthCommand, connections, credentials, callback);\n  }\n\n  _checkSaslprep() {\n    const cryptoMethod = this.cryptoMethod;\n\n    if (cryptoMethod === 'sha256') {\n      if (!saslprep) {\n        console.warn('Warning: no saslprep library specified. Passwords will not be sanitized');\n      }\n    }\n  }\n}\n\n/**\n * Creates a new ScramSHA1 authentication mechanism\n * @class\n * @extends ScramSHA\n */\nclass ScramSHA1 extends ScramSHA {\n  constructor(bson) {\n    super(bson, 'sha1');\n  }\n}\n\n/**\n * Creates a new ScramSHA256 authentication mechanism\n * @class\n * @extends ScramSHA\n */\nclass ScramSHA256 extends ScramSHA {\n  constructor(bson) {\n    super(bson, 'sha256');\n  }\n}\n\nmodule.exports = { ScramSHA1, ScramSHA256 };\n"]},"metadata":{},"sourceType":"script"}