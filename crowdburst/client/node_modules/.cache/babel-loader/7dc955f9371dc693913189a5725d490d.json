{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar crypto = require('crypto');\n\nvar debugOptions = require('./utils').debugOptions;\n\nvar parseHeader = require('../wireprotocol/shared').parseHeader;\n\nvar decompress = require('../wireprotocol/compression').decompress;\n\nvar Response = require('./commands').Response;\n\nvar BinMsg = require('./msg').BinMsg;\n\nvar MongoNetworkError = require('../error').MongoNetworkError;\n\nvar MongoError = require('../error').MongoError;\n\nvar Logger = require('./logger');\n\nvar OP_COMPRESSED = require('../wireprotocol/shared').opcodes.OP_COMPRESSED;\n\nvar OP_MSG = require('../wireprotocol/shared').opcodes.OP_MSG;\n\nvar MESSAGE_HEADER_SIZE = require('../wireprotocol/shared').MESSAGE_HEADER_SIZE;\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar _id = 0;\nvar DEFAULT_MAX_BSON_MESSAGE_SIZE = 1024 * 1024 * 16 * 4;\nvar DEBUG_FIELDS = ['host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectionTimeout', 'socketTimeout', 'ssl', 'ca', 'crl', 'cert', 'rejectUnauthorized', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'checkServerIdentity'];\nvar connectionAccountingSpy = undefined;\nvar connectionAccounting = false;\nvar _connections = {};\n/**\n * A class representing a single connection to a MongoDB server\n *\n * @fires Connection#connect\n * @fires Connection#close\n * @fires Connection#error\n * @fires Connection#timeout\n * @fires Connection#parseError\n * @fires Connection#message\n */\n\nvar Connection = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Connection, _EventEmitter);\n\n  var _super = _createSuper(Connection);\n\n  /**\n   * Creates a new Connection instance\n   *\n   * **NOTE**: Internal class, do not instantiate directly\n   *\n   * @param {Socket} socket The socket this connection wraps\n   * @param {Object} options Various settings\n   * @param {object} options.bson An implementation of bson serialize and deserialize\n   * @param {string} [options.host='localhost'] The host the socket is connected to\n   * @param {number} [options.port=27017] The port used for the socket connection\n   * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n   * @param {number} [options.keepAliveInitialDelay=300000] Initial delay before TCP keep alive enabled\n   * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\n   * @param {number} [options.socketTimeout=360000] TCP Socket timeout setting\n   * @param {boolean} [options.promoteLongs] Convert Long values from the db into Numbers if they fit into 53 bits\n   * @param {boolean} [options.promoteValues] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n   * @param {boolean} [options.promoteBuffers] Promotes Binary BSON values to native Node Buffers.\n   * @param {number} [options.maxBsonMessageSize=0x4000000] Largest possible size of a BSON message (for legacy purposes)\n   */\n  function Connection(socket, options) {\n    var _this;\n\n    _classCallCheck(this, Connection);\n\n    _this = _super.call(this);\n    options = options || {};\n\n    if (!options.bson) {\n      throw new TypeError('must pass in valid bson parser');\n    }\n\n    _this.id = _id++;\n    _this.options = options;\n    _this.logger = Logger('Connection', options);\n    _this.bson = options.bson;\n    _this.tag = options.tag;\n    _this.maxBsonMessageSize = options.maxBsonMessageSize || DEFAULT_MAX_BSON_MESSAGE_SIZE;\n    _this.port = options.port || 27017;\n    _this.host = options.host || 'localhost';\n    _this.socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 360000; // These values are inspected directly in tests, but maybe not necessary to keep around\n\n    _this.keepAlive = typeof options.keepAlive === 'boolean' ? options.keepAlive : true;\n    _this.keepAliveInitialDelay = typeof options.keepAliveInitialDelay === 'number' ? options.keepAliveInitialDelay : 300000;\n    _this.connectionTimeout = typeof options.connectionTimeout === 'number' ? options.connectionTimeout : 30000;\n\n    if (_this.keepAliveInitialDelay > _this.socketTimeout) {\n      _this.keepAliveInitialDelay = Math.round(_this.socketTimeout / 2);\n    } // Debug information\n\n\n    if (_this.logger.isDebug()) {\n      _this.logger.debug(\"creating connection \".concat(_this.id, \" with options [\").concat(JSON.stringify(debugOptions(DEBUG_FIELDS, options)), \"]\"));\n    } // Response options\n\n\n    _this.responseOptions = {\n      promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n      promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n      promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false\n    }; // Flushing\n\n    _this.flushing = false;\n    _this.queue = []; // Internal state\n\n    _this.writeStream = null;\n    _this.destroyed = false;\n    _this.timedOut = false; // Create hash method\n\n    var hash = crypto.createHash('sha1');\n    hash.update(_this.address);\n    _this.hashedName = hash.digest('hex'); // All operations in flight on the connection\n\n    _this.workItems = []; // setup socket\n\n    _this.socket = socket;\n\n    _this.socket.once('error', errorHandler(_assertThisInitialized(_this)));\n\n    _this.socket.once('timeout', timeoutHandler(_assertThisInitialized(_this)));\n\n    _this.socket.once('close', closeHandler(_assertThisInitialized(_this)));\n\n    _this.socket.on('data', dataHandler(_assertThisInitialized(_this)));\n\n    if (connectionAccounting) {\n      addConnection(_this.id, _assertThisInitialized(_this));\n    }\n\n    return _this;\n  }\n\n  _createClass(Connection, [{\n    key: \"setSocketTimeout\",\n    value: function setSocketTimeout(value) {\n      if (this.socket) {\n        this.socket.setTimeout(value);\n      }\n    }\n  }, {\n    key: \"resetSocketTimeout\",\n    value: function resetSocketTimeout() {\n      if (this.socket) {\n        this.socket.setTimeout(this.socketTimeout);\n      }\n    }\n  }, {\n    key: \"unref\",\n\n    /**\n     * Unref this connection\n     * @method\n     * @return {boolean}\n     */\n    value: function unref() {\n      var _this2 = this;\n\n      if (this.socket == null) {\n        this.once('connect', function () {\n          return _this2.socket.unref();\n        });\n        return;\n      }\n\n      this.socket.unref();\n    }\n    /**\n     * Flush all work Items on this connection\n     *\n     * @param {*} err The error to propagate to the flushed work items\n     */\n\n  }, {\n    key: \"flush\",\n    value: function flush(err) {\n      while (this.workItems.length > 0) {\n        var workItem = this.workItems.shift();\n\n        if (workItem.cb) {\n          workItem.cb(err);\n        }\n      }\n    }\n    /**\n     * Destroy connection\n     * @method\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy(options, callback) {\n      var _this3 = this;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = Object.assign({\n        force: false\n      }, options);\n\n      if (connectionAccounting) {\n        deleteConnection(this.id);\n      }\n\n      if (this.socket == null) {\n        this.destroyed = true;\n        return;\n      }\n\n      if (options.force || this.timedOut) {\n        this.socket.destroy();\n        this.destroyed = true;\n        if (typeof callback === 'function') callback(null, null);\n        return;\n      }\n\n      this.socket.end(function (err) {\n        _this3.destroyed = true;\n        if (typeof callback === 'function') callback(err, null);\n      });\n    }\n    /**\n     * Write to connection\n     * @method\n     * @param {Command} command Command to write out need to implement toBin and toBinUnified\n     */\n\n  }, {\n    key: \"write\",\n    value: function write(buffer) {\n      // Debug Log\n      if (this.logger.isDebug()) {\n        if (!Array.isArray(buffer)) {\n          this.logger.debug(\"writing buffer [\".concat(buffer.toString('hex'), \"] to \").concat(this.address));\n        } else {\n          for (var i = 0; i < buffer.length; i++) {\n            this.logger.debug(\"writing buffer [\".concat(buffer[i].toString('hex'), \"] to \").concat(this.address));\n          }\n        }\n      } // Double check that the connection is not destroyed\n\n\n      if (this.socket.destroyed === false) {\n        // Write out the command\n        if (!Array.isArray(buffer)) {\n          this.socket.write(buffer, 'binary');\n          return true;\n        } // Iterate over all buffers and write them in order to the socket\n\n\n        for (var _i = 0; _i < buffer.length; _i++) {\n          this.socket.write(buffer[_i], 'binary');\n        }\n\n        return true;\n      } // Connection is destroyed return write failed\n\n\n      return false;\n    }\n    /**\n     * Return id of connection as a string\n     * @method\n     * @return {string}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return '' + this.id;\n    }\n    /**\n     * Return json object of connection\n     * @method\n     * @return {object}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        id: this.id,\n        host: this.host,\n        port: this.port\n      };\n    }\n    /**\n     * Is the connection connected\n     * @method\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      if (this.destroyed) return false;\n      return !this.socket.destroyed && this.socket.writable;\n    }\n  }, {\n    key: \"address\",\n    get: function get() {\n      return \"\".concat(this.host, \":\").concat(this.port);\n    }\n  }], [{\n    key: \"enableConnectionAccounting\",\n    value: function enableConnectionAccounting(spy) {\n      if (spy) {\n        connectionAccountingSpy = spy;\n      }\n\n      connectionAccounting = true;\n      _connections = {};\n    }\n  }, {\n    key: \"disableConnectionAccounting\",\n    value: function disableConnectionAccounting() {\n      connectionAccounting = false;\n      connectionAccountingSpy = undefined;\n    }\n  }, {\n    key: \"connections\",\n    value: function connections() {\n      return _connections;\n    }\n  }]);\n\n  return Connection;\n}(EventEmitter);\n\nfunction deleteConnection(id) {\n  // console.log(\"=== deleted connection \" + id + \" :: \" + (connections[id] ? connections[id].port : ''))\n  delete _connections[id];\n\n  if (connectionAccountingSpy) {\n    connectionAccountingSpy.deleteConnection(id);\n  }\n}\n\nfunction addConnection(id, connection) {\n  // console.log(\"=== added connection \" + id + \" :: \" + connection.port)\n  _connections[id] = connection;\n\n  if (connectionAccountingSpy) {\n    connectionAccountingSpy.addConnection(id, connection);\n  }\n} //\n// Connection handlers\n\n\nfunction errorHandler(conn) {\n  return function (err) {\n    if (connectionAccounting) deleteConnection(conn.id); // Debug information\n\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(\"connection \".concat(conn.id, \" for [\").concat(conn.address, \"] errored out with [\").concat(JSON.stringify(err), \"]\"));\n    }\n\n    conn.emit('error', new MongoNetworkError(err), conn);\n  };\n}\n\nfunction timeoutHandler(conn) {\n  return function () {\n    if (connectionAccounting) deleteConnection(conn.id);\n\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(\"connection \".concat(conn.id, \" for [\").concat(conn.address, \"] timed out\"));\n    }\n\n    conn.timedOut = true;\n    conn.emit('timeout', new MongoNetworkError(\"connection \".concat(conn.id, \" to \").concat(conn.address, \" timed out\")), conn);\n  };\n}\n\nfunction closeHandler(conn) {\n  return function (hadError) {\n    if (connectionAccounting) deleteConnection(conn.id);\n\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(\"connection \".concat(conn.id, \" with for [\").concat(conn.address, \"] closed\"));\n    }\n\n    if (!hadError) {\n      conn.emit('close', new MongoNetworkError(\"connection \".concat(conn.id, \" to \").concat(conn.address, \" closed\")), conn);\n    }\n  };\n} // Handle a message once it is received\n\n\nfunction processMessage(conn, message) {\n  var msgHeader = parseHeader(message);\n\n  if (msgHeader.opCode !== OP_COMPRESSED) {\n    var ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;\n    conn.emit('message', new ResponseConstructor(conn.bson, message, msgHeader, message.slice(MESSAGE_HEADER_SIZE), conn.responseOptions), conn);\n    return;\n  }\n\n  msgHeader.fromCompressed = true;\n  var index = MESSAGE_HEADER_SIZE;\n  msgHeader.opCode = message.readInt32LE(index);\n  index += 4;\n  msgHeader.length = message.readInt32LE(index);\n  index += 4;\n  var compressorID = message[index];\n  index++;\n  decompress(compressorID, message.slice(index), function (err, decompressedMsgBody) {\n    if (err) {\n      conn.emit('error', err);\n      return;\n    }\n\n    if (decompressedMsgBody.length !== msgHeader.length) {\n      conn.emit('error', new MongoError('Decompressing a compressed message from the server failed. The message is corrupt.'));\n      return;\n    }\n\n    var ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;\n    conn.emit('message', new ResponseConstructor(conn.bson, message, msgHeader, decompressedMsgBody, conn.responseOptions), conn);\n  });\n}\n\nfunction dataHandler(conn) {\n  return function (data) {\n    // Parse until we are done with the data\n    while (data.length > 0) {\n      // If we still have bytes to read on the current message\n      if (conn.bytesRead > 0 && conn.sizeOfMessage > 0) {\n        // Calculate the amount of remaining bytes\n        var remainingBytesToRead = conn.sizeOfMessage - conn.bytesRead; // Check if the current chunk contains the rest of the message\n\n        if (remainingBytesToRead > data.length) {\n          // Copy the new data into the exiting buffer (should have been allocated when we know the message size)\n          data.copy(conn.buffer, conn.bytesRead); // Adjust the number of bytes read so it point to the correct index in the buffer\n\n          conn.bytesRead = conn.bytesRead + data.length; // Reset state of buffer\n\n          data = Buffer.alloc(0);\n        } else {\n          // Copy the missing part of the data into our current buffer\n          data.copy(conn.buffer, conn.bytesRead, 0, remainingBytesToRead); // Slice the overflow into a new buffer that we will then re-parse\n\n          data = data.slice(remainingBytesToRead); // Emit current complete message\n\n          var emitBuffer = conn.buffer; // Reset state of buffer\n\n          conn.buffer = null;\n          conn.sizeOfMessage = 0;\n          conn.bytesRead = 0;\n          conn.stubBuffer = null;\n          processMessage(conn, emitBuffer);\n        }\n      } else {\n        // Stub buffer is kept in case we don't get enough bytes to determine the\n        // size of the message (< 4 bytes)\n        if (conn.stubBuffer != null && conn.stubBuffer.length > 0) {\n          // If we have enough bytes to determine the message size let's do it\n          if (conn.stubBuffer.length + data.length > 4) {\n            // Prepad the data\n            var newData = Buffer.alloc(conn.stubBuffer.length + data.length);\n            conn.stubBuffer.copy(newData, 0);\n            data.copy(newData, conn.stubBuffer.length); // Reassign for parsing\n\n            data = newData; // Reset state of buffer\n\n            conn.buffer = null;\n            conn.sizeOfMessage = 0;\n            conn.bytesRead = 0;\n            conn.stubBuffer = null;\n          } else {\n            // Add the the bytes to the stub buffer\n            var newStubBuffer = Buffer.alloc(conn.stubBuffer.length + data.length); // Copy existing stub buffer\n\n            conn.stubBuffer.copy(newStubBuffer, 0); // Copy missing part of the data\n\n            data.copy(newStubBuffer, conn.stubBuffer.length); // Exit parsing loop\n\n            data = Buffer.alloc(0);\n          }\n        } else {\n          if (data.length > 4) {\n            // Retrieve the message size\n            var sizeOfMessage = data[0] | data[1] << 8 | data[2] << 16 | data[3] << 24; // If we have a negative sizeOfMessage emit error and return\n\n            if (sizeOfMessage < 0 || sizeOfMessage > conn.maxBsonMessageSize) {\n              var errorObject = {\n                err: 'socketHandler',\n                trace: '',\n                bin: conn.buffer,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: conn.bytesRead,\n                  stubBuffer: conn.stubBuffer\n                }\n              }; // We got a parse Error fire it off then keep going\n\n              conn.emit('parseError', errorObject, conn);\n              return;\n            } // Ensure that the size of message is larger than 0 and less than the max allowed\n\n\n            if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage > data.length) {\n              conn.buffer = Buffer.alloc(sizeOfMessage); // Copy all the data into the buffer\n\n              data.copy(conn.buffer, 0); // Update bytes read\n\n              conn.bytesRead = data.length; // Update sizeOfMessage\n\n              conn.sizeOfMessage = sizeOfMessage; // Ensure stub buffer is null\n\n              conn.stubBuffer = null; // Exit parsing loop\n\n              data = Buffer.alloc(0);\n            } else if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage === data.length) {\n              var _emitBuffer = data; // Reset state of buffer\n\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null; // Exit parsing loop\n\n              data = Buffer.alloc(0); // Emit the message\n\n              processMessage(conn, _emitBuffer);\n            } else if (sizeOfMessage <= 4 || sizeOfMessage > conn.maxBsonMessageSize) {\n              var _errorObject = {\n                err: 'socketHandler',\n                trace: null,\n                bin: data,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: 0,\n                  buffer: null,\n                  stubBuffer: null\n                }\n              }; // We got a parse Error fire it off then keep going\n\n              conn.emit('parseError', _errorObject, conn); // Clear out the state of the parser\n\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null; // Exit parsing loop\n\n              data = Buffer.alloc(0);\n            } else {\n              var _emitBuffer2 = data.slice(0, sizeOfMessage); // Reset state of buffer\n\n\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null; // Copy rest of message\n\n              data = data.slice(sizeOfMessage); // Emit the message\n\n              processMessage(conn, _emitBuffer2);\n            }\n          } else {\n            // Create a buffer that contains the space for the non-complete message\n            conn.stubBuffer = Buffer.alloc(data.length); // Copy the data to the stub buffer\n\n            data.copy(conn.stubBuffer, 0); // Exit parsing loop\n\n            data = Buffer.alloc(0);\n          }\n        }\n      }\n    }\n  };\n}\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Connection#connect\n * @type {Connection}\n */\n\n/**\n * The server connection closed, all pool connections closed\n *\n * @event Connection#close\n * @type {Connection}\n */\n\n/**\n * The server connection caused an error, all pool connections closed\n *\n * @event Connection#error\n * @type {Connection}\n */\n\n/**\n * The server connection timed out, all pool connections closed\n *\n * @event Connection#timeout\n * @type {Connection}\n */\n\n/**\n * The driver experienced an invalid message, all pool connections closed\n *\n * @event Connection#parseError\n * @type {Connection}\n */\n\n/**\n * An event emitted each time the connection receives a parsed message from the wire\n *\n * @event Connection#message\n * @type {Connection}\n */\n\n\nmodule.exports = Connection;","map":{"version":3,"sources":["/Users/S/Desktop/nodeprotake2/node_modules/mongodb/lib/core/connection/connection.js"],"names":["EventEmitter","require","crypto","debugOptions","parseHeader","decompress","Response","BinMsg","MongoNetworkError","MongoError","Logger","OP_COMPRESSED","opcodes","OP_MSG","MESSAGE_HEADER_SIZE","Buffer","_id","DEFAULT_MAX_BSON_MESSAGE_SIZE","DEBUG_FIELDS","connectionAccountingSpy","undefined","connectionAccounting","connections","Connection","socket","options","bson","TypeError","id","logger","tag","maxBsonMessageSize","port","host","socketTimeout","keepAlive","keepAliveInitialDelay","connectionTimeout","Math","round","isDebug","debug","JSON","stringify","responseOptions","promoteLongs","promoteValues","promoteBuffers","flushing","queue","writeStream","destroyed","timedOut","hash","createHash","update","address","hashedName","digest","workItems","once","errorHandler","timeoutHandler","closeHandler","on","dataHandler","addConnection","value","setTimeout","unref","err","length","workItem","shift","cb","callback","Object","assign","force","deleteConnection","destroy","end","buffer","Array","isArray","toString","i","write","writable","spy","connection","conn","emit","hadError","processMessage","message","msgHeader","opCode","ResponseConstructor","slice","fromCompressed","index","readInt32LE","compressorID","decompressedMsgBody","data","bytesRead","sizeOfMessage","remainingBytesToRead","copy","alloc","emitBuffer","stubBuffer","newData","newStubBuffer","errorObject","trace","bin","parseState","module","exports"],"mappings":"AAAA;;;;;;;;;;;;AAEA,IAAMA,YAAY,GAAGC,OAAO,CAAC,QAAD,CAAP,CAAkBD,YAAvC;;AACA,IAAME,MAAM,GAAGD,OAAO,CAAC,QAAD,CAAtB;;AACA,IAAME,YAAY,GAAGF,OAAO,CAAC,SAAD,CAAP,CAAmBE,YAAxC;;AACA,IAAMC,WAAW,GAAGH,OAAO,CAAC,wBAAD,CAAP,CAAkCG,WAAtD;;AACA,IAAMC,UAAU,GAAGJ,OAAO,CAAC,6BAAD,CAAP,CAAuCI,UAA1D;;AACA,IAAMC,QAAQ,GAAGL,OAAO,CAAC,YAAD,CAAP,CAAsBK,QAAvC;;AACA,IAAMC,MAAM,GAAGN,OAAO,CAAC,OAAD,CAAP,CAAiBM,MAAhC;;AACA,IAAMC,iBAAiB,GAAGP,OAAO,CAAC,UAAD,CAAP,CAAoBO,iBAA9C;;AACA,IAAMC,UAAU,GAAGR,OAAO,CAAC,UAAD,CAAP,CAAoBQ,UAAvC;;AACA,IAAMC,MAAM,GAAGT,OAAO,CAAC,UAAD,CAAtB;;AACA,IAAMU,aAAa,GAAGV,OAAO,CAAC,wBAAD,CAAP,CAAkCW,OAAlC,CAA0CD,aAAhE;;AACA,IAAME,MAAM,GAAGZ,OAAO,CAAC,wBAAD,CAAP,CAAkCW,OAAlC,CAA0CC,MAAzD;;AACA,IAAMC,mBAAmB,GAAGb,OAAO,CAAC,wBAAD,CAAP,CAAkCa,mBAA9D;;AACA,IAAMC,MAAM,GAAGd,OAAO,CAAC,aAAD,CAAP,CAAuBc,MAAtC;;AAEA,IAAIC,GAAG,GAAG,CAAV;AAEA,IAAMC,6BAA6B,GAAG,OAAO,IAAP,GAAc,EAAd,GAAmB,CAAzD;AACA,IAAMC,YAAY,GAAG,CACnB,MADmB,EAEnB,MAFmB,EAGnB,MAHmB,EAInB,WAJmB,EAKnB,uBALmB,EAMnB,SANmB,EAOnB,mBAPmB,EAQnB,eARmB,EASnB,KATmB,EAUnB,IAVmB,EAWnB,KAXmB,EAYnB,MAZmB,EAanB,oBAbmB,EAcnB,cAdmB,EAenB,eAfmB,EAgBnB,gBAhBmB,EAiBnB,qBAjBmB,CAArB;AAoBA,IAAIC,uBAAuB,GAAGC,SAA9B;AACA,IAAIC,oBAAoB,GAAG,KAA3B;AACA,IAAIC,YAAW,GAAG,EAAlB;AAEA;;;;;;;;;;;IAUMC,U;;;;;AACJ;;;;;;;;;;;;;;;;;;;AAmBA,sBAAYC,MAAZ,EAAoBC,OAApB,EAA6B;AAAA;;AAAA;;AAC3B;AAEAA,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;;AACA,QAAI,CAACA,OAAO,CAACC,IAAb,EAAmB;AACjB,YAAM,IAAIC,SAAJ,CAAc,gCAAd,CAAN;AACD;;AAED,UAAKC,EAAL,GAAUZ,GAAG,EAAb;AACA,UAAKS,OAAL,GAAeA,OAAf;AACA,UAAKI,MAAL,GAAcnB,MAAM,CAAC,YAAD,EAAee,OAAf,CAApB;AACA,UAAKC,IAAL,GAAYD,OAAO,CAACC,IAApB;AACA,UAAKI,GAAL,GAAWL,OAAO,CAACK,GAAnB;AACA,UAAKC,kBAAL,GAA0BN,OAAO,CAACM,kBAAR,IAA8Bd,6BAAxD;AAEA,UAAKe,IAAL,GAAYP,OAAO,CAACO,IAAR,IAAgB,KAA5B;AACA,UAAKC,IAAL,GAAYR,OAAO,CAACQ,IAAR,IAAgB,WAA5B;AACA,UAAKC,aAAL,GAAqB,OAAOT,OAAO,CAACS,aAAf,KAAiC,QAAjC,GAA4CT,OAAO,CAACS,aAApD,GAAoE,MAAzF,CAjB2B,CAmB3B;;AACA,UAAKC,SAAL,GAAiB,OAAOV,OAAO,CAACU,SAAf,KAA6B,SAA7B,GAAyCV,OAAO,CAACU,SAAjD,GAA6D,IAA9E;AACA,UAAKC,qBAAL,GACE,OAAOX,OAAO,CAACW,qBAAf,KAAyC,QAAzC,GAAoDX,OAAO,CAACW,qBAA5D,GAAoF,MADtF;AAEA,UAAKC,iBAAL,GACE,OAAOZ,OAAO,CAACY,iBAAf,KAAqC,QAArC,GAAgDZ,OAAO,CAACY,iBAAxD,GAA4E,KAD9E;;AAEA,QAAI,MAAKD,qBAAL,GAA6B,MAAKF,aAAtC,EAAqD;AACnD,YAAKE,qBAAL,GAA6BE,IAAI,CAACC,KAAL,CAAW,MAAKL,aAAL,GAAqB,CAAhC,CAA7B;AACD,KA3B0B,CA6B3B;;;AACA,QAAI,MAAKL,MAAL,CAAYW,OAAZ,EAAJ,EAA2B;AACzB,YAAKX,MAAL,CAAYY,KAAZ,+BACyB,MAAKb,EAD9B,4BACkDc,IAAI,CAACC,SAAL,CAC9CxC,YAAY,CAACe,YAAD,EAAeO,OAAf,CADkC,CADlD;AAKD,KApC0B,CAsC3B;;;AACA,UAAKmB,eAAL,GAAuB;AACrBC,MAAAA,YAAY,EAAE,OAAOpB,OAAO,CAACoB,YAAf,KAAgC,SAAhC,GAA4CpB,OAAO,CAACoB,YAApD,GAAmE,IAD5D;AAErBC,MAAAA,aAAa,EAAE,OAAOrB,OAAO,CAACqB,aAAf,KAAiC,SAAjC,GAA6CrB,OAAO,CAACqB,aAArD,GAAqE,IAF/D;AAGrBC,MAAAA,cAAc,EAAE,OAAOtB,OAAO,CAACsB,cAAf,KAAkC,SAAlC,GAA8CtB,OAAO,CAACsB,cAAtD,GAAuE;AAHlE,KAAvB,CAvC2B,CA6C3B;;AACA,UAAKC,QAAL,GAAgB,KAAhB;AACA,UAAKC,KAAL,GAAa,EAAb,CA/C2B,CAiD3B;;AACA,UAAKC,WAAL,GAAmB,IAAnB;AACA,UAAKC,SAAL,GAAiB,KAAjB;AACA,UAAKC,QAAL,GAAgB,KAAhB,CApD2B,CAsD3B;;AACA,QAAMC,IAAI,GAAGnD,MAAM,CAACoD,UAAP,CAAkB,MAAlB,CAAb;AACAD,IAAAA,IAAI,CAACE,MAAL,CAAY,MAAKC,OAAjB;AACA,UAAKC,UAAL,GAAkBJ,IAAI,CAACK,MAAL,CAAY,KAAZ,CAAlB,CAzD2B,CA2D3B;;AACA,UAAKC,SAAL,GAAiB,EAAjB,CA5D2B,CA8D3B;;AACA,UAAKnC,MAAL,GAAcA,MAAd;;AACA,UAAKA,MAAL,CAAYoC,IAAZ,CAAiB,OAAjB,EAA0BC,YAAY,+BAAtC;;AACA,UAAKrC,MAAL,CAAYoC,IAAZ,CAAiB,SAAjB,EAA4BE,cAAc,+BAA1C;;AACA,UAAKtC,MAAL,CAAYoC,IAAZ,CAAiB,OAAjB,EAA0BG,YAAY,+BAAtC;;AACA,UAAKvC,MAAL,CAAYwC,EAAZ,CAAe,MAAf,EAAuBC,WAAW,+BAAlC;;AAEA,QAAI5C,oBAAJ,EAA0B;AACxB6C,MAAAA,aAAa,CAAC,MAAKtC,EAAN,gCAAb;AACD;;AAvE0B;AAwE5B;;;;qCAEgBuC,K,EAAO;AACtB,UAAI,KAAK3C,MAAT,EAAiB;AACf,aAAKA,MAAL,CAAY4C,UAAZ,CAAuBD,KAAvB;AACD;AACF;;;yCAEoB;AACnB,UAAI,KAAK3C,MAAT,EAAiB;AACf,aAAKA,MAAL,CAAY4C,UAAZ,CAAuB,KAAKlC,aAA5B;AACD;AACF;;;;AAwBD;;;;;4BAKQ;AAAA;;AACN,UAAI,KAAKV,MAAL,IAAe,IAAnB,EAAyB;AACvB,aAAKoC,IAAL,CAAU,SAAV,EAAqB;AAAA,iBAAM,MAAI,CAACpC,MAAL,CAAY6C,KAAZ,EAAN;AAAA,SAArB;AACA;AACD;;AAED,WAAK7C,MAAL,CAAY6C,KAAZ;AACD;AAED;;;;;;;;0BAKMC,G,EAAK;AACT,aAAO,KAAKX,SAAL,CAAeY,MAAf,GAAwB,CAA/B,EAAkC;AAChC,YAAMC,QAAQ,GAAG,KAAKb,SAAL,CAAec,KAAf,EAAjB;;AACA,YAAID,QAAQ,CAACE,EAAb,EAAiB;AACfF,UAAAA,QAAQ,CAACE,EAAT,CAAYJ,GAAZ;AACD;AACF;AACF;AAED;;;;;;;4BAIQ7C,O,EAASkD,Q,EAAU;AAAA;;AACzB,UAAI,OAAOlD,OAAP,KAAmB,UAAvB,EAAmC;AACjCkD,QAAAA,QAAQ,GAAGlD,OAAX;AACAA,QAAAA,OAAO,GAAG,EAAV;AACD;;AAEDA,MAAAA,OAAO,GAAGmD,MAAM,CAACC,MAAP,CAAc;AAAEC,QAAAA,KAAK,EAAE;AAAT,OAAd,EAAgCrD,OAAhC,CAAV;;AAEA,UAAIJ,oBAAJ,EAA0B;AACxB0D,QAAAA,gBAAgB,CAAC,KAAKnD,EAAN,CAAhB;AACD;;AAED,UAAI,KAAKJ,MAAL,IAAe,IAAnB,EAAyB;AACvB,aAAK2B,SAAL,GAAiB,IAAjB;AACA;AACD;;AAED,UAAI1B,OAAO,CAACqD,KAAR,IAAiB,KAAK1B,QAA1B,EAAoC;AAClC,aAAK5B,MAAL,CAAYwD,OAAZ;AACA,aAAK7B,SAAL,GAAiB,IAAjB;AACA,YAAI,OAAOwB,QAAP,KAAoB,UAAxB,EAAoCA,QAAQ,CAAC,IAAD,EAAO,IAAP,CAAR;AACpC;AACD;;AAED,WAAKnD,MAAL,CAAYyD,GAAZ,CAAgB,UAAAX,GAAG,EAAI;AACrB,QAAA,MAAI,CAACnB,SAAL,GAAiB,IAAjB;AACA,YAAI,OAAOwB,QAAP,KAAoB,UAAxB,EAAoCA,QAAQ,CAACL,GAAD,EAAM,IAAN,CAAR;AACrC,OAHD;AAID;AAED;;;;;;;;0BAKMY,M,EAAQ;AACZ;AACA,UAAI,KAAKrD,MAAL,CAAYW,OAAZ,EAAJ,EAA2B;AACzB,YAAI,CAAC2C,KAAK,CAACC,OAAN,CAAcF,MAAd,CAAL,EAA4B;AAC1B,eAAKrD,MAAL,CAAYY,KAAZ,2BAAqCyC,MAAM,CAACG,QAAP,CAAgB,KAAhB,CAArC,kBAAmE,KAAK7B,OAAxE;AACD,SAFD,MAEO;AACL,eAAK,IAAI8B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,MAAM,CAACX,MAA3B,EAAmCe,CAAC,EAApC;AACE,iBAAKzD,MAAL,CAAYY,KAAZ,2BAAqCyC,MAAM,CAACI,CAAD,CAAN,CAAUD,QAAV,CAAmB,KAAnB,CAArC,kBAAsE,KAAK7B,OAA3E;AADF;AAED;AACF,OATW,CAWZ;;;AACA,UAAI,KAAKhC,MAAL,CAAY2B,SAAZ,KAA0B,KAA9B,EAAqC;AACnC;AACA,YAAI,CAACgC,KAAK,CAACC,OAAN,CAAcF,MAAd,CAAL,EAA4B;AAC1B,eAAK1D,MAAL,CAAY+D,KAAZ,CAAkBL,MAAlB,EAA0B,QAA1B;AACA,iBAAO,IAAP;AACD,SALkC,CAOnC;;;AACA,aAAK,IAAII,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAGJ,MAAM,CAACX,MAA3B,EAAmCe,EAAC,EAApC,EAAwC;AACtC,eAAK9D,MAAL,CAAY+D,KAAZ,CAAkBL,MAAM,CAACI,EAAD,CAAxB,EAA6B,QAA7B;AACD;;AAED,eAAO,IAAP;AACD,OAzBW,CA2BZ;;;AACA,aAAO,KAAP;AACD;AAED;;;;;;;;+BAKW;AACT,aAAO,KAAK,KAAK1D,EAAjB;AACD;AAED;;;;;;;;6BAKS;AACP,aAAO;AAAEA,QAAAA,EAAE,EAAE,KAAKA,EAAX;AAAeK,QAAAA,IAAI,EAAE,KAAKA,IAA1B;AAAgCD,QAAAA,IAAI,EAAE,KAAKA;AAA3C,OAAP;AACD;AAED;;;;;;;;kCAKc;AACZ,UAAI,KAAKmB,SAAT,EAAoB,OAAO,KAAP;AACpB,aAAO,CAAC,KAAK3B,MAAL,CAAY2B,SAAb,IAA0B,KAAK3B,MAAL,CAAYgE,QAA7C;AACD;;;wBAhIa;AACZ,uBAAU,KAAKvD,IAAf,cAAuB,KAAKD,IAA5B;AACD;;;+CApBiCyD,G,EAAK;AACrC,UAAIA,GAAJ,EAAS;AACPtE,QAAAA,uBAAuB,GAAGsE,GAA1B;AACD;;AAEDpE,MAAAA,oBAAoB,GAAG,IAAvB;AACAC,MAAAA,YAAW,GAAG,EAAd;AACD;;;kDAEoC;AACnCD,MAAAA,oBAAoB,GAAG,KAAvB;AACAF,MAAAA,uBAAuB,GAAGC,SAA1B;AACD;;;kCAEoB;AACnB,aAAOE,YAAP;AACD;;;;EA1HsBtB,Y;;AA+PzB,SAAS+E,gBAAT,CAA0BnD,EAA1B,EAA8B;AAC5B;AACA,SAAON,YAAW,CAACM,EAAD,CAAlB;;AAEA,MAAIT,uBAAJ,EAA6B;AAC3BA,IAAAA,uBAAuB,CAAC4D,gBAAxB,CAAyCnD,EAAzC;AACD;AACF;;AAED,SAASsC,aAAT,CAAuBtC,EAAvB,EAA2B8D,UAA3B,EAAuC;AACrC;AACApE,EAAAA,YAAW,CAACM,EAAD,CAAX,GAAkB8D,UAAlB;;AAEA,MAAIvE,uBAAJ,EAA6B;AAC3BA,IAAAA,uBAAuB,CAAC+C,aAAxB,CAAsCtC,EAAtC,EAA0C8D,UAA1C;AACD;AACF,C,CAED;AACA;;;AACA,SAAS7B,YAAT,CAAsB8B,IAAtB,EAA4B;AAC1B,SAAO,UAASrB,GAAT,EAAc;AACnB,QAAIjD,oBAAJ,EAA0B0D,gBAAgB,CAACY,IAAI,CAAC/D,EAAN,CAAhB,CADP,CAEnB;;AACA,QAAI+D,IAAI,CAAC9D,MAAL,CAAYW,OAAZ,EAAJ,EAA2B;AACzBmD,MAAAA,IAAI,CAAC9D,MAAL,CAAYY,KAAZ,sBACgBkD,IAAI,CAAC/D,EADrB,mBACgC+D,IAAI,CAACnC,OADrC,iCACmEd,IAAI,CAACC,SAAL,CAAe2B,GAAf,CADnE;AAGD;;AAEDqB,IAAAA,IAAI,CAACC,IAAL,CAAU,OAAV,EAAmB,IAAIpF,iBAAJ,CAAsB8D,GAAtB,CAAnB,EAA+CqB,IAA/C;AACD,GAVD;AAWD;;AAED,SAAS7B,cAAT,CAAwB6B,IAAxB,EAA8B;AAC5B,SAAO,YAAW;AAChB,QAAItE,oBAAJ,EAA0B0D,gBAAgB,CAACY,IAAI,CAAC/D,EAAN,CAAhB;;AAE1B,QAAI+D,IAAI,CAAC9D,MAAL,CAAYW,OAAZ,EAAJ,EAA2B;AACzBmD,MAAAA,IAAI,CAAC9D,MAAL,CAAYY,KAAZ,sBAAgCkD,IAAI,CAAC/D,EAArC,mBAAgD+D,IAAI,CAACnC,OAArD;AACD;;AAEDmC,IAAAA,IAAI,CAACvC,QAAL,GAAgB,IAAhB;AACAuC,IAAAA,IAAI,CAACC,IAAL,CACE,SADF,EAEE,IAAIpF,iBAAJ,sBAAoCmF,IAAI,CAAC/D,EAAzC,iBAAkD+D,IAAI,CAACnC,OAAvD,gBAFF,EAGEmC,IAHF;AAKD,GAbD;AAcD;;AAED,SAAS5B,YAAT,CAAsB4B,IAAtB,EAA4B;AAC1B,SAAO,UAASE,QAAT,EAAmB;AACxB,QAAIxE,oBAAJ,EAA0B0D,gBAAgB,CAACY,IAAI,CAAC/D,EAAN,CAAhB;;AAE1B,QAAI+D,IAAI,CAAC9D,MAAL,CAAYW,OAAZ,EAAJ,EAA2B;AACzBmD,MAAAA,IAAI,CAAC9D,MAAL,CAAYY,KAAZ,sBAAgCkD,IAAI,CAAC/D,EAArC,wBAAqD+D,IAAI,CAACnC,OAA1D;AACD;;AAED,QAAI,CAACqC,QAAL,EAAe;AACbF,MAAAA,IAAI,CAACC,IAAL,CACE,OADF,EAEE,IAAIpF,iBAAJ,sBAAoCmF,IAAI,CAAC/D,EAAzC,iBAAkD+D,IAAI,CAACnC,OAAvD,aAFF,EAGEmC,IAHF;AAKD;AACF,GAdD;AAeD,C,CAED;;;AACA,SAASG,cAAT,CAAwBH,IAAxB,EAA8BI,OAA9B,EAAuC;AACrC,MAAMC,SAAS,GAAG5F,WAAW,CAAC2F,OAAD,CAA7B;;AACA,MAAIC,SAAS,CAACC,MAAV,KAAqBtF,aAAzB,EAAwC;AACtC,QAAMuF,mBAAmB,GAAGF,SAAS,CAACC,MAAV,KAAqBpF,MAArB,GAA8BN,MAA9B,GAAuCD,QAAnE;AACAqF,IAAAA,IAAI,CAACC,IAAL,CACE,SADF,EAEE,IAAIM,mBAAJ,CACEP,IAAI,CAACjE,IADP,EAEEqE,OAFF,EAGEC,SAHF,EAIED,OAAO,CAACI,KAAR,CAAcrF,mBAAd,CAJF,EAKE6E,IAAI,CAAC/C,eALP,CAFF,EASE+C,IATF;AAYA;AACD;;AAEDK,EAAAA,SAAS,CAACI,cAAV,GAA2B,IAA3B;AACA,MAAIC,KAAK,GAAGvF,mBAAZ;AACAkF,EAAAA,SAAS,CAACC,MAAV,GAAmBF,OAAO,CAACO,WAAR,CAAoBD,KAApB,CAAnB;AACAA,EAAAA,KAAK,IAAI,CAAT;AACAL,EAAAA,SAAS,CAACzB,MAAV,GAAmBwB,OAAO,CAACO,WAAR,CAAoBD,KAApB,CAAnB;AACAA,EAAAA,KAAK,IAAI,CAAT;AACA,MAAME,YAAY,GAAGR,OAAO,CAACM,KAAD,CAA5B;AACAA,EAAAA,KAAK;AAELhG,EAAAA,UAAU,CAACkG,YAAD,EAAeR,OAAO,CAACI,KAAR,CAAcE,KAAd,CAAf,EAAqC,UAAC/B,GAAD,EAAMkC,mBAAN,EAA8B;AAC3E,QAAIlC,GAAJ,EAAS;AACPqB,MAAAA,IAAI,CAACC,IAAL,CAAU,OAAV,EAAmBtB,GAAnB;AACA;AACD;;AAED,QAAIkC,mBAAmB,CAACjC,MAApB,KAA+ByB,SAAS,CAACzB,MAA7C,EAAqD;AACnDoB,MAAAA,IAAI,CAACC,IAAL,CACE,OADF,EAEE,IAAInF,UAAJ,CACE,oFADF,CAFF;AAOA;AACD;;AAED,QAAMyF,mBAAmB,GAAGF,SAAS,CAACC,MAAV,KAAqBpF,MAArB,GAA8BN,MAA9B,GAAuCD,QAAnE;AACAqF,IAAAA,IAAI,CAACC,IAAL,CACE,SADF,EAEE,IAAIM,mBAAJ,CACEP,IAAI,CAACjE,IADP,EAEEqE,OAFF,EAGEC,SAHF,EAIEQ,mBAJF,EAKEb,IAAI,CAAC/C,eALP,CAFF,EASE+C,IATF;AAWD,GA7BS,CAAV;AA8BD;;AAED,SAAS1B,WAAT,CAAqB0B,IAArB,EAA2B;AACzB,SAAO,UAASc,IAAT,EAAe;AACpB;AACA,WAAOA,IAAI,CAAClC,MAAL,GAAc,CAArB,EAAwB;AACtB;AACA,UAAIoB,IAAI,CAACe,SAAL,GAAiB,CAAjB,IAAsBf,IAAI,CAACgB,aAAL,GAAqB,CAA/C,EAAkD;AAChD;AACA,YAAMC,oBAAoB,GAAGjB,IAAI,CAACgB,aAAL,GAAqBhB,IAAI,CAACe,SAAvD,CAFgD,CAGhD;;AACA,YAAIE,oBAAoB,GAAGH,IAAI,CAAClC,MAAhC,EAAwC;AACtC;AACAkC,UAAAA,IAAI,CAACI,IAAL,CAAUlB,IAAI,CAACT,MAAf,EAAuBS,IAAI,CAACe,SAA5B,EAFsC,CAGtC;;AACAf,UAAAA,IAAI,CAACe,SAAL,GAAiBf,IAAI,CAACe,SAAL,GAAiBD,IAAI,CAAClC,MAAvC,CAJsC,CAMtC;;AACAkC,UAAAA,IAAI,GAAG1F,MAAM,CAAC+F,KAAP,CAAa,CAAb,CAAP;AACD,SARD,MAQO;AACL;AACAL,UAAAA,IAAI,CAACI,IAAL,CAAUlB,IAAI,CAACT,MAAf,EAAuBS,IAAI,CAACe,SAA5B,EAAuC,CAAvC,EAA0CE,oBAA1C,EAFK,CAGL;;AACAH,UAAAA,IAAI,GAAGA,IAAI,CAACN,KAAL,CAAWS,oBAAX,CAAP,CAJK,CAML;;AACA,cAAMG,UAAU,GAAGpB,IAAI,CAACT,MAAxB,CAPK,CAQL;;AACAS,UAAAA,IAAI,CAACT,MAAL,GAAc,IAAd;AACAS,UAAAA,IAAI,CAACgB,aAAL,GAAqB,CAArB;AACAhB,UAAAA,IAAI,CAACe,SAAL,GAAiB,CAAjB;AACAf,UAAAA,IAAI,CAACqB,UAAL,GAAkB,IAAlB;AAEAlB,UAAAA,cAAc,CAACH,IAAD,EAAOoB,UAAP,CAAd;AACD;AACF,OA5BD,MA4BO;AACL;AACA;AACA,YAAIpB,IAAI,CAACqB,UAAL,IAAmB,IAAnB,IAA2BrB,IAAI,CAACqB,UAAL,CAAgBzC,MAAhB,GAAyB,CAAxD,EAA2D;AACzD;AACA,cAAIoB,IAAI,CAACqB,UAAL,CAAgBzC,MAAhB,GAAyBkC,IAAI,CAAClC,MAA9B,GAAuC,CAA3C,EAA8C;AAC5C;AACA,gBAAM0C,OAAO,GAAGlG,MAAM,CAAC+F,KAAP,CAAanB,IAAI,CAACqB,UAAL,CAAgBzC,MAAhB,GAAyBkC,IAAI,CAAClC,MAA3C,CAAhB;AACAoB,YAAAA,IAAI,CAACqB,UAAL,CAAgBH,IAAhB,CAAqBI,OAArB,EAA8B,CAA9B;AACAR,YAAAA,IAAI,CAACI,IAAL,CAAUI,OAAV,EAAmBtB,IAAI,CAACqB,UAAL,CAAgBzC,MAAnC,EAJ4C,CAK5C;;AACAkC,YAAAA,IAAI,GAAGQ,OAAP,CAN4C,CAQ5C;;AACAtB,YAAAA,IAAI,CAACT,MAAL,GAAc,IAAd;AACAS,YAAAA,IAAI,CAACgB,aAAL,GAAqB,CAArB;AACAhB,YAAAA,IAAI,CAACe,SAAL,GAAiB,CAAjB;AACAf,YAAAA,IAAI,CAACqB,UAAL,GAAkB,IAAlB;AACD,WAbD,MAaO;AACL;AACA,gBAAME,aAAa,GAAGnG,MAAM,CAAC+F,KAAP,CAAanB,IAAI,CAACqB,UAAL,CAAgBzC,MAAhB,GAAyBkC,IAAI,CAAClC,MAA3C,CAAtB,CAFK,CAGL;;AACAoB,YAAAA,IAAI,CAACqB,UAAL,CAAgBH,IAAhB,CAAqBK,aAArB,EAAoC,CAApC,EAJK,CAKL;;AACAT,YAAAA,IAAI,CAACI,IAAL,CAAUK,aAAV,EAAyBvB,IAAI,CAACqB,UAAL,CAAgBzC,MAAzC,EANK,CAOL;;AACAkC,YAAAA,IAAI,GAAG1F,MAAM,CAAC+F,KAAP,CAAa,CAAb,CAAP;AACD;AACF,SAzBD,MAyBO;AACL,cAAIL,IAAI,CAAClC,MAAL,GAAc,CAAlB,EAAqB;AACnB;AACA,gBAAMoC,aAAa,GAAGF,IAAI,CAAC,CAAD,CAAJ,GAAWA,IAAI,CAAC,CAAD,CAAJ,IAAW,CAAtB,GAA4BA,IAAI,CAAC,CAAD,CAAJ,IAAW,EAAvC,GAA8CA,IAAI,CAAC,CAAD,CAAJ,IAAW,EAA/E,CAFmB,CAGnB;;AACA,gBAAIE,aAAa,GAAG,CAAhB,IAAqBA,aAAa,GAAGhB,IAAI,CAAC5D,kBAA9C,EAAkE;AAChE,kBAAMoF,WAAW,GAAG;AAClB7C,gBAAAA,GAAG,EAAE,eADa;AAElB8C,gBAAAA,KAAK,EAAE,EAFW;AAGlBC,gBAAAA,GAAG,EAAE1B,IAAI,CAACT,MAHQ;AAIlBoC,gBAAAA,UAAU,EAAE;AACVX,kBAAAA,aAAa,EAAEA,aADL;AAEVD,kBAAAA,SAAS,EAAEf,IAAI,CAACe,SAFN;AAGVM,kBAAAA,UAAU,EAAErB,IAAI,CAACqB;AAHP;AAJM,eAApB,CADgE,CAWhE;;AACArB,cAAAA,IAAI,CAACC,IAAL,CAAU,YAAV,EAAwBuB,WAAxB,EAAqCxB,IAArC;AACA;AACD,aAlBkB,CAoBnB;;;AACA,gBACEgB,aAAa,GAAG,CAAhB,IACAA,aAAa,GAAGhB,IAAI,CAAC5D,kBADrB,IAEA4E,aAAa,GAAGF,IAAI,CAAClC,MAHvB,EAIE;AACAoB,cAAAA,IAAI,CAACT,MAAL,GAAcnE,MAAM,CAAC+F,KAAP,CAAaH,aAAb,CAAd,CADA,CAEA;;AACAF,cAAAA,IAAI,CAACI,IAAL,CAAUlB,IAAI,CAACT,MAAf,EAAuB,CAAvB,EAHA,CAIA;;AACAS,cAAAA,IAAI,CAACe,SAAL,GAAiBD,IAAI,CAAClC,MAAtB,CALA,CAMA;;AACAoB,cAAAA,IAAI,CAACgB,aAAL,GAAqBA,aAArB,CAPA,CAQA;;AACAhB,cAAAA,IAAI,CAACqB,UAAL,GAAkB,IAAlB,CATA,CAUA;;AACAP,cAAAA,IAAI,GAAG1F,MAAM,CAAC+F,KAAP,CAAa,CAAb,CAAP;AACD,aAhBD,MAgBO,IACLH,aAAa,GAAG,CAAhB,IACAA,aAAa,GAAGhB,IAAI,CAAC5D,kBADrB,IAEA4E,aAAa,KAAKF,IAAI,CAAClC,MAHlB,EAIL;AACA,kBAAMwC,WAAU,GAAGN,IAAnB,CADA,CAEA;;AACAd,cAAAA,IAAI,CAACT,MAAL,GAAc,IAAd;AACAS,cAAAA,IAAI,CAACgB,aAAL,GAAqB,CAArB;AACAhB,cAAAA,IAAI,CAACe,SAAL,GAAiB,CAAjB;AACAf,cAAAA,IAAI,CAACqB,UAAL,GAAkB,IAAlB,CANA,CAOA;;AACAP,cAAAA,IAAI,GAAG1F,MAAM,CAAC+F,KAAP,CAAa,CAAb,CAAP,CARA,CASA;;AACAhB,cAAAA,cAAc,CAACH,IAAD,EAAOoB,WAAP,CAAd;AACD,aAfM,MAeA,IAAIJ,aAAa,IAAI,CAAjB,IAAsBA,aAAa,GAAGhB,IAAI,CAAC5D,kBAA/C,EAAmE;AACxE,kBAAMoF,YAAW,GAAG;AAClB7C,gBAAAA,GAAG,EAAE,eADa;AAElB8C,gBAAAA,KAAK,EAAE,IAFW;AAGlBC,gBAAAA,GAAG,EAAEZ,IAHa;AAIlBa,gBAAAA,UAAU,EAAE;AACVX,kBAAAA,aAAa,EAAEA,aADL;AAEVD,kBAAAA,SAAS,EAAE,CAFD;AAGVxB,kBAAAA,MAAM,EAAE,IAHE;AAIV8B,kBAAAA,UAAU,EAAE;AAJF;AAJM,eAApB,CADwE,CAYxE;;AACArB,cAAAA,IAAI,CAACC,IAAL,CAAU,YAAV,EAAwBuB,YAAxB,EAAqCxB,IAArC,EAbwE,CAexE;;AACAA,cAAAA,IAAI,CAACT,MAAL,GAAc,IAAd;AACAS,cAAAA,IAAI,CAACgB,aAAL,GAAqB,CAArB;AACAhB,cAAAA,IAAI,CAACe,SAAL,GAAiB,CAAjB;AACAf,cAAAA,IAAI,CAACqB,UAAL,GAAkB,IAAlB,CAnBwE,CAoBxE;;AACAP,cAAAA,IAAI,GAAG1F,MAAM,CAAC+F,KAAP,CAAa,CAAb,CAAP;AACD,aAtBM,MAsBA;AACL,kBAAMC,YAAU,GAAGN,IAAI,CAACN,KAAL,CAAW,CAAX,EAAcQ,aAAd,CAAnB,CADK,CAEL;;;AACAhB,cAAAA,IAAI,CAACT,MAAL,GAAc,IAAd;AACAS,cAAAA,IAAI,CAACgB,aAAL,GAAqB,CAArB;AACAhB,cAAAA,IAAI,CAACe,SAAL,GAAiB,CAAjB;AACAf,cAAAA,IAAI,CAACqB,UAAL,GAAkB,IAAlB,CANK,CAOL;;AACAP,cAAAA,IAAI,GAAGA,IAAI,CAACN,KAAL,CAAWQ,aAAX,CAAP,CARK,CASL;;AACAb,cAAAA,cAAc,CAACH,IAAD,EAAOoB,YAAP,CAAd;AACD;AACF,WAtFD,MAsFO;AACL;AACApB,YAAAA,IAAI,CAACqB,UAAL,GAAkBjG,MAAM,CAAC+F,KAAP,CAAaL,IAAI,CAAClC,MAAlB,CAAlB,CAFK,CAGL;;AACAkC,YAAAA,IAAI,CAACI,IAAL,CAAUlB,IAAI,CAACqB,UAAf,EAA2B,CAA3B,EAJK,CAKL;;AACAP,YAAAA,IAAI,GAAG1F,MAAM,CAAC+F,KAAP,CAAa,CAAb,CAAP;AACD;AACF;AACF;AACF;AACF,GA9JD;AA+JD;AAED;;;;;;;AAOA;;;;;;;AAOA;;;;;;;AAOA;;;;;;;AAOA;;;;;;;AAOA;;;;;;;;AAOAS,MAAM,CAACC,OAAP,GAAiBjG,UAAjB","sourcesContent":["'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\nconst crypto = require('crypto');\nconst debugOptions = require('./utils').debugOptions;\nconst parseHeader = require('../wireprotocol/shared').parseHeader;\nconst decompress = require('../wireprotocol/compression').decompress;\nconst Response = require('./commands').Response;\nconst BinMsg = require('./msg').BinMsg;\nconst MongoNetworkError = require('../error').MongoNetworkError;\nconst MongoError = require('../error').MongoError;\nconst Logger = require('./logger');\nconst OP_COMPRESSED = require('../wireprotocol/shared').opcodes.OP_COMPRESSED;\nconst OP_MSG = require('../wireprotocol/shared').opcodes.OP_MSG;\nconst MESSAGE_HEADER_SIZE = require('../wireprotocol/shared').MESSAGE_HEADER_SIZE;\nconst Buffer = require('safe-buffer').Buffer;\n\nlet _id = 0;\n\nconst DEFAULT_MAX_BSON_MESSAGE_SIZE = 1024 * 1024 * 16 * 4;\nconst DEBUG_FIELDS = [\n  'host',\n  'port',\n  'size',\n  'keepAlive',\n  'keepAliveInitialDelay',\n  'noDelay',\n  'connectionTimeout',\n  'socketTimeout',\n  'ssl',\n  'ca',\n  'crl',\n  'cert',\n  'rejectUnauthorized',\n  'promoteLongs',\n  'promoteValues',\n  'promoteBuffers',\n  'checkServerIdentity'\n];\n\nlet connectionAccountingSpy = undefined;\nlet connectionAccounting = false;\nlet connections = {};\n\n/**\n * A class representing a single connection to a MongoDB server\n *\n * @fires Connection#connect\n * @fires Connection#close\n * @fires Connection#error\n * @fires Connection#timeout\n * @fires Connection#parseError\n * @fires Connection#message\n */\nclass Connection extends EventEmitter {\n  /**\n   * Creates a new Connection instance\n   *\n   * **NOTE**: Internal class, do not instantiate directly\n   *\n   * @param {Socket} socket The socket this connection wraps\n   * @param {Object} options Various settings\n   * @param {object} options.bson An implementation of bson serialize and deserialize\n   * @param {string} [options.host='localhost'] The host the socket is connected to\n   * @param {number} [options.port=27017] The port used for the socket connection\n   * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n   * @param {number} [options.keepAliveInitialDelay=300000] Initial delay before TCP keep alive enabled\n   * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\n   * @param {number} [options.socketTimeout=360000] TCP Socket timeout setting\n   * @param {boolean} [options.promoteLongs] Convert Long values from the db into Numbers if they fit into 53 bits\n   * @param {boolean} [options.promoteValues] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n   * @param {boolean} [options.promoteBuffers] Promotes Binary BSON values to native Node Buffers.\n   * @param {number} [options.maxBsonMessageSize=0x4000000] Largest possible size of a BSON message (for legacy purposes)\n   */\n  constructor(socket, options) {\n    super();\n\n    options = options || {};\n    if (!options.bson) {\n      throw new TypeError('must pass in valid bson parser');\n    }\n\n    this.id = _id++;\n    this.options = options;\n    this.logger = Logger('Connection', options);\n    this.bson = options.bson;\n    this.tag = options.tag;\n    this.maxBsonMessageSize = options.maxBsonMessageSize || DEFAULT_MAX_BSON_MESSAGE_SIZE;\n\n    this.port = options.port || 27017;\n    this.host = options.host || 'localhost';\n    this.socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 360000;\n\n    // These values are inspected directly in tests, but maybe not necessary to keep around\n    this.keepAlive = typeof options.keepAlive === 'boolean' ? options.keepAlive : true;\n    this.keepAliveInitialDelay =\n      typeof options.keepAliveInitialDelay === 'number' ? options.keepAliveInitialDelay : 300000;\n    this.connectionTimeout =\n      typeof options.connectionTimeout === 'number' ? options.connectionTimeout : 30000;\n    if (this.keepAliveInitialDelay > this.socketTimeout) {\n      this.keepAliveInitialDelay = Math.round(this.socketTimeout / 2);\n    }\n\n    // Debug information\n    if (this.logger.isDebug()) {\n      this.logger.debug(\n        `creating connection ${this.id} with options [${JSON.stringify(\n          debugOptions(DEBUG_FIELDS, options)\n        )}]`\n      );\n    }\n\n    // Response options\n    this.responseOptions = {\n      promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n      promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n      promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false\n    };\n\n    // Flushing\n    this.flushing = false;\n    this.queue = [];\n\n    // Internal state\n    this.writeStream = null;\n    this.destroyed = false;\n    this.timedOut = false;\n\n    // Create hash method\n    const hash = crypto.createHash('sha1');\n    hash.update(this.address);\n    this.hashedName = hash.digest('hex');\n\n    // All operations in flight on the connection\n    this.workItems = [];\n\n    // setup socket\n    this.socket = socket;\n    this.socket.once('error', errorHandler(this));\n    this.socket.once('timeout', timeoutHandler(this));\n    this.socket.once('close', closeHandler(this));\n    this.socket.on('data', dataHandler(this));\n\n    if (connectionAccounting) {\n      addConnection(this.id, this);\n    }\n  }\n\n  setSocketTimeout(value) {\n    if (this.socket) {\n      this.socket.setTimeout(value);\n    }\n  }\n\n  resetSocketTimeout() {\n    if (this.socket) {\n      this.socket.setTimeout(this.socketTimeout);\n    }\n  }\n\n  static enableConnectionAccounting(spy) {\n    if (spy) {\n      connectionAccountingSpy = spy;\n    }\n\n    connectionAccounting = true;\n    connections = {};\n  }\n\n  static disableConnectionAccounting() {\n    connectionAccounting = false;\n    connectionAccountingSpy = undefined;\n  }\n\n  static connections() {\n    return connections;\n  }\n\n  get address() {\n    return `${this.host}:${this.port}`;\n  }\n\n  /**\n   * Unref this connection\n   * @method\n   * @return {boolean}\n   */\n  unref() {\n    if (this.socket == null) {\n      this.once('connect', () => this.socket.unref());\n      return;\n    }\n\n    this.socket.unref();\n  }\n\n  /**\n   * Flush all work Items on this connection\n   *\n   * @param {*} err The error to propagate to the flushed work items\n   */\n  flush(err) {\n    while (this.workItems.length > 0) {\n      const workItem = this.workItems.shift();\n      if (workItem.cb) {\n        workItem.cb(err);\n      }\n    }\n  }\n\n  /**\n   * Destroy connection\n   * @method\n   */\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = Object.assign({ force: false }, options);\n\n    if (connectionAccounting) {\n      deleteConnection(this.id);\n    }\n\n    if (this.socket == null) {\n      this.destroyed = true;\n      return;\n    }\n\n    if (options.force || this.timedOut) {\n      this.socket.destroy();\n      this.destroyed = true;\n      if (typeof callback === 'function') callback(null, null);\n      return;\n    }\n\n    this.socket.end(err => {\n      this.destroyed = true;\n      if (typeof callback === 'function') callback(err, null);\n    });\n  }\n\n  /**\n   * Write to connection\n   * @method\n   * @param {Command} command Command to write out need to implement toBin and toBinUnified\n   */\n  write(buffer) {\n    // Debug Log\n    if (this.logger.isDebug()) {\n      if (!Array.isArray(buffer)) {\n        this.logger.debug(`writing buffer [${buffer.toString('hex')}] to ${this.address}`);\n      } else {\n        for (let i = 0; i < buffer.length; i++)\n          this.logger.debug(`writing buffer [${buffer[i].toString('hex')}] to ${this.address}`);\n      }\n    }\n\n    // Double check that the connection is not destroyed\n    if (this.socket.destroyed === false) {\n      // Write out the command\n      if (!Array.isArray(buffer)) {\n        this.socket.write(buffer, 'binary');\n        return true;\n      }\n\n      // Iterate over all buffers and write them in order to the socket\n      for (let i = 0; i < buffer.length; i++) {\n        this.socket.write(buffer[i], 'binary');\n      }\n\n      return true;\n    }\n\n    // Connection is destroyed return write failed\n    return false;\n  }\n\n  /**\n   * Return id of connection as a string\n   * @method\n   * @return {string}\n   */\n  toString() {\n    return '' + this.id;\n  }\n\n  /**\n   * Return json object of connection\n   * @method\n   * @return {object}\n   */\n  toJSON() {\n    return { id: this.id, host: this.host, port: this.port };\n  }\n\n  /**\n   * Is the connection connected\n   * @method\n   * @return {boolean}\n   */\n  isConnected() {\n    if (this.destroyed) return false;\n    return !this.socket.destroyed && this.socket.writable;\n  }\n}\n\nfunction deleteConnection(id) {\n  // console.log(\"=== deleted connection \" + id + \" :: \" + (connections[id] ? connections[id].port : ''))\n  delete connections[id];\n\n  if (connectionAccountingSpy) {\n    connectionAccountingSpy.deleteConnection(id);\n  }\n}\n\nfunction addConnection(id, connection) {\n  // console.log(\"=== added connection \" + id + \" :: \" + connection.port)\n  connections[id] = connection;\n\n  if (connectionAccountingSpy) {\n    connectionAccountingSpy.addConnection(id, connection);\n  }\n}\n\n//\n// Connection handlers\nfunction errorHandler(conn) {\n  return function(err) {\n    if (connectionAccounting) deleteConnection(conn.id);\n    // Debug information\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(\n        `connection ${conn.id} for [${conn.address}] errored out with [${JSON.stringify(err)}]`\n      );\n    }\n\n    conn.emit('error', new MongoNetworkError(err), conn);\n  };\n}\n\nfunction timeoutHandler(conn) {\n  return function() {\n    if (connectionAccounting) deleteConnection(conn.id);\n\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(`connection ${conn.id} for [${conn.address}] timed out`);\n    }\n\n    conn.timedOut = true;\n    conn.emit(\n      'timeout',\n      new MongoNetworkError(`connection ${conn.id} to ${conn.address} timed out`),\n      conn\n    );\n  };\n}\n\nfunction closeHandler(conn) {\n  return function(hadError) {\n    if (connectionAccounting) deleteConnection(conn.id);\n\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(`connection ${conn.id} with for [${conn.address}] closed`);\n    }\n\n    if (!hadError) {\n      conn.emit(\n        'close',\n        new MongoNetworkError(`connection ${conn.id} to ${conn.address} closed`),\n        conn\n      );\n    }\n  };\n}\n\n// Handle a message once it is received\nfunction processMessage(conn, message) {\n  const msgHeader = parseHeader(message);\n  if (msgHeader.opCode !== OP_COMPRESSED) {\n    const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;\n    conn.emit(\n      'message',\n      new ResponseConstructor(\n        conn.bson,\n        message,\n        msgHeader,\n        message.slice(MESSAGE_HEADER_SIZE),\n        conn.responseOptions\n      ),\n      conn\n    );\n\n    return;\n  }\n\n  msgHeader.fromCompressed = true;\n  let index = MESSAGE_HEADER_SIZE;\n  msgHeader.opCode = message.readInt32LE(index);\n  index += 4;\n  msgHeader.length = message.readInt32LE(index);\n  index += 4;\n  const compressorID = message[index];\n  index++;\n\n  decompress(compressorID, message.slice(index), (err, decompressedMsgBody) => {\n    if (err) {\n      conn.emit('error', err);\n      return;\n    }\n\n    if (decompressedMsgBody.length !== msgHeader.length) {\n      conn.emit(\n        'error',\n        new MongoError(\n          'Decompressing a compressed message from the server failed. The message is corrupt.'\n        )\n      );\n\n      return;\n    }\n\n    const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;\n    conn.emit(\n      'message',\n      new ResponseConstructor(\n        conn.bson,\n        message,\n        msgHeader,\n        decompressedMsgBody,\n        conn.responseOptions\n      ),\n      conn\n    );\n  });\n}\n\nfunction dataHandler(conn) {\n  return function(data) {\n    // Parse until we are done with the data\n    while (data.length > 0) {\n      // If we still have bytes to read on the current message\n      if (conn.bytesRead > 0 && conn.sizeOfMessage > 0) {\n        // Calculate the amount of remaining bytes\n        const remainingBytesToRead = conn.sizeOfMessage - conn.bytesRead;\n        // Check if the current chunk contains the rest of the message\n        if (remainingBytesToRead > data.length) {\n          // Copy the new data into the exiting buffer (should have been allocated when we know the message size)\n          data.copy(conn.buffer, conn.bytesRead);\n          // Adjust the number of bytes read so it point to the correct index in the buffer\n          conn.bytesRead = conn.bytesRead + data.length;\n\n          // Reset state of buffer\n          data = Buffer.alloc(0);\n        } else {\n          // Copy the missing part of the data into our current buffer\n          data.copy(conn.buffer, conn.bytesRead, 0, remainingBytesToRead);\n          // Slice the overflow into a new buffer that we will then re-parse\n          data = data.slice(remainingBytesToRead);\n\n          // Emit current complete message\n          const emitBuffer = conn.buffer;\n          // Reset state of buffer\n          conn.buffer = null;\n          conn.sizeOfMessage = 0;\n          conn.bytesRead = 0;\n          conn.stubBuffer = null;\n\n          processMessage(conn, emitBuffer);\n        }\n      } else {\n        // Stub buffer is kept in case we don't get enough bytes to determine the\n        // size of the message (< 4 bytes)\n        if (conn.stubBuffer != null && conn.stubBuffer.length > 0) {\n          // If we have enough bytes to determine the message size let's do it\n          if (conn.stubBuffer.length + data.length > 4) {\n            // Prepad the data\n            const newData = Buffer.alloc(conn.stubBuffer.length + data.length);\n            conn.stubBuffer.copy(newData, 0);\n            data.copy(newData, conn.stubBuffer.length);\n            // Reassign for parsing\n            data = newData;\n\n            // Reset state of buffer\n            conn.buffer = null;\n            conn.sizeOfMessage = 0;\n            conn.bytesRead = 0;\n            conn.stubBuffer = null;\n          } else {\n            // Add the the bytes to the stub buffer\n            const newStubBuffer = Buffer.alloc(conn.stubBuffer.length + data.length);\n            // Copy existing stub buffer\n            conn.stubBuffer.copy(newStubBuffer, 0);\n            // Copy missing part of the data\n            data.copy(newStubBuffer, conn.stubBuffer.length);\n            // Exit parsing loop\n            data = Buffer.alloc(0);\n          }\n        } else {\n          if (data.length > 4) {\n            // Retrieve the message size\n            const sizeOfMessage = data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24);\n            // If we have a negative sizeOfMessage emit error and return\n            if (sizeOfMessage < 0 || sizeOfMessage > conn.maxBsonMessageSize) {\n              const errorObject = {\n                err: 'socketHandler',\n                trace: '',\n                bin: conn.buffer,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: conn.bytesRead,\n                  stubBuffer: conn.stubBuffer\n                }\n              };\n              // We got a parse Error fire it off then keep going\n              conn.emit('parseError', errorObject, conn);\n              return;\n            }\n\n            // Ensure that the size of message is larger than 0 and less than the max allowed\n            if (\n              sizeOfMessage > 4 &&\n              sizeOfMessage < conn.maxBsonMessageSize &&\n              sizeOfMessage > data.length\n            ) {\n              conn.buffer = Buffer.alloc(sizeOfMessage);\n              // Copy all the data into the buffer\n              data.copy(conn.buffer, 0);\n              // Update bytes read\n              conn.bytesRead = data.length;\n              // Update sizeOfMessage\n              conn.sizeOfMessage = sizeOfMessage;\n              // Ensure stub buffer is null\n              conn.stubBuffer = null;\n              // Exit parsing loop\n              data = Buffer.alloc(0);\n            } else if (\n              sizeOfMessage > 4 &&\n              sizeOfMessage < conn.maxBsonMessageSize &&\n              sizeOfMessage === data.length\n            ) {\n              const emitBuffer = data;\n              // Reset state of buffer\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null;\n              // Exit parsing loop\n              data = Buffer.alloc(0);\n              // Emit the message\n              processMessage(conn, emitBuffer);\n            } else if (sizeOfMessage <= 4 || sizeOfMessage > conn.maxBsonMessageSize) {\n              const errorObject = {\n                err: 'socketHandler',\n                trace: null,\n                bin: data,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: 0,\n                  buffer: null,\n                  stubBuffer: null\n                }\n              };\n              // We got a parse Error fire it off then keep going\n              conn.emit('parseError', errorObject, conn);\n\n              // Clear out the state of the parser\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null;\n              // Exit parsing loop\n              data = Buffer.alloc(0);\n            } else {\n              const emitBuffer = data.slice(0, sizeOfMessage);\n              // Reset state of buffer\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null;\n              // Copy rest of message\n              data = data.slice(sizeOfMessage);\n              // Emit the message\n              processMessage(conn, emitBuffer);\n            }\n          } else {\n            // Create a buffer that contains the space for the non-complete message\n            conn.stubBuffer = Buffer.alloc(data.length);\n            // Copy the data to the stub buffer\n            data.copy(conn.stubBuffer, 0);\n            // Exit parsing loop\n            data = Buffer.alloc(0);\n          }\n        }\n      }\n    }\n  };\n}\n\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Connection#connect\n * @type {Connection}\n */\n\n/**\n * The server connection closed, all pool connections closed\n *\n * @event Connection#close\n * @type {Connection}\n */\n\n/**\n * The server connection caused an error, all pool connections closed\n *\n * @event Connection#error\n * @type {Connection}\n */\n\n/**\n * The server connection timed out, all pool connections closed\n *\n * @event Connection#timeout\n * @type {Connection}\n */\n\n/**\n * The driver experienced an invalid message, all pool connections closed\n *\n * @event Connection#parseError\n * @type {Connection}\n */\n\n/**\n * An event emitted each time the connection receives a parsed message from the wire\n *\n * @event Connection#message\n * @type {Connection}\n */\n\nmodule.exports = Connection;\n"]},"metadata":{},"sourceType":"script"}