{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar Msg = require('../connection/msg').Msg;\n\nvar KillCursor = require('../connection/commands').KillCursor;\n\nvar GetMore = require('../connection/commands').GetMore;\n\nvar calculateDurationInMs = require('../utils').calculateDurationInMs;\n/** Commands that we want to redact because of the sensitive nature of their contents */\n\n\nvar SENSITIVE_COMMANDS = new Set(['authenticate', 'saslStart', 'saslContinue', 'getnonce', 'createUser', 'updateUser', 'copydbgetnonce', 'copydbsaslstart', 'copydb']); // helper methods\n\nvar extractCommandName = function extractCommandName(commandDoc) {\n  return Object.keys(commandDoc)[0];\n};\n\nvar namespace = function namespace(command) {\n  return command.ns;\n};\n\nvar databaseName = function databaseName(command) {\n  return command.ns.split('.')[0];\n};\n\nvar collectionName = function collectionName(command) {\n  return command.ns.split('.')[1];\n};\n\nvar generateConnectionId = function generateConnectionId(pool) {\n  return pool.options ? \"\".concat(pool.options.host, \":\").concat(pool.options.port) : pool.address;\n};\n\nvar maybeRedact = function maybeRedact(commandName, result) {\n  return SENSITIVE_COMMANDS.has(commandName) ? {} : result;\n};\n\nvar isLegacyPool = function isLegacyPool(pool) {\n  return pool.s && pool.queue;\n};\n\nvar LEGACY_FIND_QUERY_MAP = {\n  $query: 'filter',\n  $orderby: 'sort',\n  $hint: 'hint',\n  $comment: 'comment',\n  $maxScan: 'maxScan',\n  $max: 'max',\n  $min: 'min',\n  $returnKey: 'returnKey',\n  $showDiskLoc: 'showRecordId',\n  $maxTimeMS: 'maxTimeMS',\n  $snapshot: 'snapshot'\n};\nvar LEGACY_FIND_OPTIONS_MAP = {\n  numberToSkip: 'skip',\n  numberToReturn: 'batchSize',\n  returnFieldsSelector: 'projection'\n};\nvar OP_QUERY_KEYS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial', 'exhaust'];\n/**\n * Extract the actual command from the query, possibly upconverting if it's a legacy\n * format\n *\n * @param {Object} command the command\n */\n\nvar extractCommand = function extractCommand(command) {\n  if (command instanceof GetMore) {\n    return {\n      getMore: command.cursorId,\n      collection: collectionName(command),\n      batchSize: command.numberToReturn\n    };\n  }\n\n  if (command instanceof KillCursor) {\n    return {\n      killCursors: collectionName(command),\n      cursors: command.cursorIds\n    };\n  }\n\n  if (command instanceof Msg) {\n    return command.command;\n  }\n\n  if (command.query && command.query.$query) {\n    var result;\n\n    if (command.ns === 'admin.$cmd') {\n      // upconvert legacy command\n      result = Object.assign({}, command.query.$query);\n    } else {\n      // upconvert legacy find command\n      result = {\n        find: collectionName(command)\n      };\n      Object.keys(LEGACY_FIND_QUERY_MAP).forEach(function (key) {\n        if (typeof command.query[key] !== 'undefined') result[LEGACY_FIND_QUERY_MAP[key]] = command.query[key];\n      });\n    }\n\n    Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach(function (key) {\n      if (typeof command[key] !== 'undefined') result[LEGACY_FIND_OPTIONS_MAP[key]] = command[key];\n    });\n    OP_QUERY_KEYS.forEach(function (key) {\n      if (command[key]) result[key] = command[key];\n    });\n\n    if (typeof command.pre32Limit !== 'undefined') {\n      result.limit = command.pre32Limit;\n    }\n\n    if (command.query.$explain) {\n      return {\n        explain: result\n      };\n    }\n\n    return result;\n  }\n\n  return command.query ? command.query : command;\n};\n\nvar extractReply = function extractReply(command, reply) {\n  if (command instanceof GetMore) {\n    return {\n      ok: 1,\n      cursor: {\n        id: reply.message.cursorId,\n        ns: namespace(command),\n        nextBatch: reply.message.documents\n      }\n    };\n  }\n\n  if (command instanceof KillCursor) {\n    return {\n      ok: 1,\n      cursorsUnknown: command.cursorIds\n    };\n  } // is this a legacy find command?\n\n\n  if (command.query && typeof command.query.$query !== 'undefined') {\n    return {\n      ok: 1,\n      cursor: {\n        id: reply.message.cursorId,\n        ns: namespace(command),\n        firstBatch: reply.message.documents\n      }\n    };\n  }\n\n  return reply && reply.result ? reply.result : reply;\n};\n\nvar extractConnectionDetails = function extractConnectionDetails(pool) {\n  if (isLegacyPool(pool)) {\n    return {\n      connectionId: generateConnectionId(pool)\n    };\n  } // APM in the modern pool is done at the `Connection` level, so we rename it here for\n  // readability.\n\n\n  var connection = pool;\n  return {\n    address: connection.address,\n    connectionId: connection.id\n  };\n};\n/** An event indicating the start of a given command */\n\n\nvar CommandStartedEvent =\n/**\n * Create a started event\n *\n * @param {Pool} pool the pool that originated the command\n * @param {Object} command the command\n */\nfunction CommandStartedEvent(pool, command) {\n  _classCallCheck(this, CommandStartedEvent);\n\n  var cmd = extractCommand(command);\n  var commandName = extractCommandName(cmd);\n  var connectionDetails = extractConnectionDetails(pool); // NOTE: remove in major revision, this is not spec behavior\n\n  if (SENSITIVE_COMMANDS.has(commandName)) {\n    this.commandObj = {};\n    this.commandObj[commandName] = true;\n  }\n\n  Object.assign(this, connectionDetails, {\n    requestId: command.requestId,\n    databaseName: databaseName(command),\n    commandName: commandName,\n    command: cmd\n  });\n};\n/** An event indicating the success of a given command */\n\n\nvar CommandSucceededEvent =\n/**\n * Create a succeeded event\n *\n * @param {Pool} pool the pool that originated the command\n * @param {Object} command the command\n * @param {Object} reply the reply for this command from the server\n * @param {Array} started a high resolution tuple timestamp of when the command was first sent, to calculate duration\n */\nfunction CommandSucceededEvent(pool, command, reply, started) {\n  _classCallCheck(this, CommandSucceededEvent);\n\n  var cmd = extractCommand(command);\n  var commandName = extractCommandName(cmd);\n  var connectionDetails = extractConnectionDetails(pool);\n  Object.assign(this, connectionDetails, {\n    requestId: command.requestId,\n    commandName: commandName,\n    duration: calculateDurationInMs(started),\n    reply: maybeRedact(commandName, extractReply(command, reply))\n  });\n};\n/** An event indicating the failure of a given command */\n\n\nvar CommandFailedEvent =\n/**\n * Create a failure event\n *\n * @param {Pool} pool the pool that originated the command\n * @param {Object} command the command\n * @param {MongoError|Object} error the generated error or a server error response\n * @param {Array} started a high resolution tuple timestamp of when the command was first sent, to calculate duration\n */\nfunction CommandFailedEvent(pool, command, error, started) {\n  _classCallCheck(this, CommandFailedEvent);\n\n  var cmd = extractCommand(command);\n  var commandName = extractCommandName(cmd);\n  var connectionDetails = extractConnectionDetails(pool);\n  Object.assign(this, connectionDetails, {\n    requestId: command.requestId,\n    commandName: commandName,\n    duration: calculateDurationInMs(started),\n    failure: maybeRedact(commandName, error)\n  });\n};\n\nmodule.exports = {\n  CommandStartedEvent: CommandStartedEvent,\n  CommandSucceededEvent: CommandSucceededEvent,\n  CommandFailedEvent: CommandFailedEvent\n};","map":{"version":3,"sources":["/Users/S/Desktop/nodeprotake2/node_modules/mongodb/lib/core/connection/apm.js"],"names":["Msg","require","KillCursor","GetMore","calculateDurationInMs","SENSITIVE_COMMANDS","Set","extractCommandName","commandDoc","Object","keys","namespace","command","ns","databaseName","split","collectionName","generateConnectionId","pool","options","host","port","address","maybeRedact","commandName","result","has","isLegacyPool","s","queue","LEGACY_FIND_QUERY_MAP","$query","$orderby","$hint","$comment","$maxScan","$max","$min","$returnKey","$showDiskLoc","$maxTimeMS","$snapshot","LEGACY_FIND_OPTIONS_MAP","numberToSkip","numberToReturn","returnFieldsSelector","OP_QUERY_KEYS","extractCommand","getMore","cursorId","collection","batchSize","killCursors","cursors","cursorIds","query","assign","find","forEach","key","pre32Limit","limit","$explain","explain","extractReply","reply","ok","cursor","id","message","nextBatch","documents","cursorsUnknown","firstBatch","extractConnectionDetails","connectionId","connection","CommandStartedEvent","cmd","connectionDetails","commandObj","requestId","CommandSucceededEvent","started","duration","CommandFailedEvent","error","failure","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst Msg = require('../connection/msg').Msg;\nconst KillCursor = require('../connection/commands').KillCursor;\nconst GetMore = require('../connection/commands').GetMore;\nconst calculateDurationInMs = require('../utils').calculateDurationInMs;\n\n/** Commands that we want to redact because of the sensitive nature of their contents */\nconst SENSITIVE_COMMANDS = new Set([\n  'authenticate',\n  'saslStart',\n  'saslContinue',\n  'getnonce',\n  'createUser',\n  'updateUser',\n  'copydbgetnonce',\n  'copydbsaslstart',\n  'copydb'\n]);\n\n// helper methods\nconst extractCommandName = commandDoc => Object.keys(commandDoc)[0];\nconst namespace = command => command.ns;\nconst databaseName = command => command.ns.split('.')[0];\nconst collectionName = command => command.ns.split('.')[1];\nconst generateConnectionId = pool =>\n  pool.options ? `${pool.options.host}:${pool.options.port}` : pool.address;\nconst maybeRedact = (commandName, result) => (SENSITIVE_COMMANDS.has(commandName) ? {} : result);\nconst isLegacyPool = pool => pool.s && pool.queue;\n\nconst LEGACY_FIND_QUERY_MAP = {\n  $query: 'filter',\n  $orderby: 'sort',\n  $hint: 'hint',\n  $comment: 'comment',\n  $maxScan: 'maxScan',\n  $max: 'max',\n  $min: 'min',\n  $returnKey: 'returnKey',\n  $showDiskLoc: 'showRecordId',\n  $maxTimeMS: 'maxTimeMS',\n  $snapshot: 'snapshot'\n};\n\nconst LEGACY_FIND_OPTIONS_MAP = {\n  numberToSkip: 'skip',\n  numberToReturn: 'batchSize',\n  returnFieldsSelector: 'projection'\n};\n\nconst OP_QUERY_KEYS = [\n  'tailable',\n  'oplogReplay',\n  'noCursorTimeout',\n  'awaitData',\n  'partial',\n  'exhaust'\n];\n\n/**\n * Extract the actual command from the query, possibly upconverting if it's a legacy\n * format\n *\n * @param {Object} command the command\n */\nconst extractCommand = command => {\n  if (command instanceof GetMore) {\n    return {\n      getMore: command.cursorId,\n      collection: collectionName(command),\n      batchSize: command.numberToReturn\n    };\n  }\n\n  if (command instanceof KillCursor) {\n    return {\n      killCursors: collectionName(command),\n      cursors: command.cursorIds\n    };\n  }\n\n  if (command instanceof Msg) {\n    return command.command;\n  }\n\n  if (command.query && command.query.$query) {\n    let result;\n    if (command.ns === 'admin.$cmd') {\n      // upconvert legacy command\n      result = Object.assign({}, command.query.$query);\n    } else {\n      // upconvert legacy find command\n      result = { find: collectionName(command) };\n      Object.keys(LEGACY_FIND_QUERY_MAP).forEach(key => {\n        if (typeof command.query[key] !== 'undefined')\n          result[LEGACY_FIND_QUERY_MAP[key]] = command.query[key];\n      });\n    }\n\n    Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach(key => {\n      if (typeof command[key] !== 'undefined') result[LEGACY_FIND_OPTIONS_MAP[key]] = command[key];\n    });\n\n    OP_QUERY_KEYS.forEach(key => {\n      if (command[key]) result[key] = command[key];\n    });\n\n    if (typeof command.pre32Limit !== 'undefined') {\n      result.limit = command.pre32Limit;\n    }\n\n    if (command.query.$explain) {\n      return { explain: result };\n    }\n\n    return result;\n  }\n\n  return command.query ? command.query : command;\n};\n\nconst extractReply = (command, reply) => {\n  if (command instanceof GetMore) {\n    return {\n      ok: 1,\n      cursor: {\n        id: reply.message.cursorId,\n        ns: namespace(command),\n        nextBatch: reply.message.documents\n      }\n    };\n  }\n\n  if (command instanceof KillCursor) {\n    return {\n      ok: 1,\n      cursorsUnknown: command.cursorIds\n    };\n  }\n\n  // is this a legacy find command?\n  if (command.query && typeof command.query.$query !== 'undefined') {\n    return {\n      ok: 1,\n      cursor: {\n        id: reply.message.cursorId,\n        ns: namespace(command),\n        firstBatch: reply.message.documents\n      }\n    };\n  }\n\n  return reply && reply.result ? reply.result : reply;\n};\n\nconst extractConnectionDetails = pool => {\n  if (isLegacyPool(pool)) {\n    return {\n      connectionId: generateConnectionId(pool)\n    };\n  }\n\n  // APM in the modern pool is done at the `Connection` level, so we rename it here for\n  // readability.\n  const connection = pool;\n  return {\n    address: connection.address,\n    connectionId: connection.id\n  };\n};\n\n/** An event indicating the start of a given command */\nclass CommandStartedEvent {\n  /**\n   * Create a started event\n   *\n   * @param {Pool} pool the pool that originated the command\n   * @param {Object} command the command\n   */\n  constructor(pool, command) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const connectionDetails = extractConnectionDetails(pool);\n\n    // NOTE: remove in major revision, this is not spec behavior\n    if (SENSITIVE_COMMANDS.has(commandName)) {\n      this.commandObj = {};\n      this.commandObj[commandName] = true;\n    }\n\n    Object.assign(this, connectionDetails, {\n      requestId: command.requestId,\n      databaseName: databaseName(command),\n      commandName,\n      command: cmd\n    });\n  }\n}\n\n/** An event indicating the success of a given command */\nclass CommandSucceededEvent {\n  /**\n   * Create a succeeded event\n   *\n   * @param {Pool} pool the pool that originated the command\n   * @param {Object} command the command\n   * @param {Object} reply the reply for this command from the server\n   * @param {Array} started a high resolution tuple timestamp of when the command was first sent, to calculate duration\n   */\n  constructor(pool, command, reply, started) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const connectionDetails = extractConnectionDetails(pool);\n\n    Object.assign(this, connectionDetails, {\n      requestId: command.requestId,\n      commandName,\n      duration: calculateDurationInMs(started),\n      reply: maybeRedact(commandName, extractReply(command, reply))\n    });\n  }\n}\n\n/** An event indicating the failure of a given command */\nclass CommandFailedEvent {\n  /**\n   * Create a failure event\n   *\n   * @param {Pool} pool the pool that originated the command\n   * @param {Object} command the command\n   * @param {MongoError|Object} error the generated error or a server error response\n   * @param {Array} started a high resolution tuple timestamp of when the command was first sent, to calculate duration\n   */\n  constructor(pool, command, error, started) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const connectionDetails = extractConnectionDetails(pool);\n\n    Object.assign(this, connectionDetails, {\n      requestId: command.requestId,\n      commandName,\n      duration: calculateDurationInMs(started),\n      failure: maybeRedact(commandName, error)\n    });\n  }\n}\n\nmodule.exports = {\n  CommandStartedEvent,\n  CommandSucceededEvent,\n  CommandFailedEvent\n};\n"]},"metadata":{},"sourceType":"script"}