{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar common = require('./common');\n\nvar BulkOperationBase = common.BulkOperationBase;\nvar Batch = common.Batch;\nvar bson = common.bson;\n\nvar utils = require('../utils');\n\nvar toError = utils.toError;\n/**\n * Add to internal list of Operations\n *\n * @ignore\n * @param {UnorderedBulkOperation} bulkOperation\n * @param {number} docType number indicating the document type\n * @param {object} document\n * @return {UnorderedBulkOperation}\n */\n\nfunction addToOperationsList(bulkOperation, docType, document) {\n  // Get the bsonSize\n  var bsonSize = bson.calculateObjectSize(document, {\n    checkKeys: false,\n    // Since we don't know what the user selected for BSON options here,\n    // err on the safe side, and check the size with ignoreUndefined: false.\n    ignoreUndefined: false\n  }); // Throw error if the doc is bigger than the max BSON size\n\n  if (bsonSize >= bulkOperation.s.maxBsonObjectSize) throw toError('document is larger than the maximum size ' + bulkOperation.s.maxBsonObjectSize); // Holds the current batch\n\n  bulkOperation.s.currentBatch = null; // Get the right type of batch\n\n  if (docType === common.INSERT) {\n    bulkOperation.s.currentBatch = bulkOperation.s.currentInsertBatch;\n  } else if (docType === common.UPDATE) {\n    bulkOperation.s.currentBatch = bulkOperation.s.currentUpdateBatch;\n  } else if (docType === common.REMOVE) {\n    bulkOperation.s.currentBatch = bulkOperation.s.currentRemoveBatch;\n  }\n\n  var maxKeySize = bulkOperation.s.maxKeySize; // Create a new batch object if we don't have a current one\n\n  if (bulkOperation.s.currentBatch == null) bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex); // Check if we need to create a new batch\n\n  if ( // New batch if we exceed the max batch op size\n  bulkOperation.s.currentBatch.size + 1 >= bulkOperation.s.maxWriteBatchSize || // New batch if we exceed the maxBatchSizeBytes. Only matters if batch already has a doc,\n  // since we can't sent an empty batch\n  bulkOperation.s.currentBatch.size > 0 && bulkOperation.s.currentBatch.sizeBytes + maxKeySize + bsonSize >= bulkOperation.s.maxBatchSizeBytes || // New batch if the new op does not have the same op type as the current batch\n  bulkOperation.s.currentBatch.batchType !== docType) {\n    // Save the batch to the execution stack\n    bulkOperation.s.batches.push(bulkOperation.s.currentBatch); // Create a new batch\n\n    bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);\n  } // We have an array of documents\n\n\n  if (Array.isArray(document)) {\n    throw toError('operation passed in cannot be an Array');\n  }\n\n  bulkOperation.s.currentBatch.operations.push(document);\n  bulkOperation.s.currentBatch.originalIndexes.push(bulkOperation.s.currentIndex);\n  bulkOperation.s.currentIndex = bulkOperation.s.currentIndex + 1; // Save back the current Batch to the right type\n\n  if (docType === common.INSERT) {\n    bulkOperation.s.currentInsertBatch = bulkOperation.s.currentBatch;\n    bulkOperation.s.bulkResult.insertedIds.push({\n      index: bulkOperation.s.bulkResult.insertedIds.length,\n      _id: document._id\n    });\n  } else if (docType === common.UPDATE) {\n    bulkOperation.s.currentUpdateBatch = bulkOperation.s.currentBatch;\n  } else if (docType === common.REMOVE) {\n    bulkOperation.s.currentRemoveBatch = bulkOperation.s.currentBatch;\n  } // Update current batch size\n\n\n  bulkOperation.s.currentBatch.size += 1;\n  bulkOperation.s.currentBatch.sizeBytes += maxKeySize + bsonSize; // Return bulkOperation\n\n  return bulkOperation;\n}\n/**\n * Create a new UnorderedBulkOperation instance (INTERNAL TYPE, do not instantiate directly)\n * @class\n * @extends BulkOperationBase\n * @property {number} length Get the number of operations in the bulk.\n * @return {UnorderedBulkOperation} a UnorderedBulkOperation instance.\n */\n\n\nvar UnorderedBulkOperation = /*#__PURE__*/function (_BulkOperationBase) {\n  _inherits(UnorderedBulkOperation, _BulkOperationBase);\n\n  var _super = _createSuper(UnorderedBulkOperation);\n\n  function UnorderedBulkOperation(topology, collection, options) {\n    _classCallCheck(this, UnorderedBulkOperation);\n\n    options = options || {};\n    options = Object.assign(options, {\n      addToOperationsList: addToOperationsList\n    });\n    return _super.call(this, topology, collection, options, false);\n  }\n\n  _createClass(UnorderedBulkOperation, [{\n    key: \"handleWriteError\",\n    value: function handleWriteError(callback, writeResult) {\n      if (this.s.batches.length) {\n        return false;\n      }\n\n      return _get(_getPrototypeOf(UnorderedBulkOperation.prototype), \"handleWriteError\", this).call(this, callback, writeResult);\n    }\n  }]);\n\n  return UnorderedBulkOperation;\n}(BulkOperationBase);\n/**\n * Returns an unordered batch object\n * @ignore\n */\n\n\nfunction initializeUnorderedBulkOp(topology, collection, options) {\n  return new UnorderedBulkOperation(topology, collection, options);\n}\n\ninitializeUnorderedBulkOp.UnorderedBulkOperation = UnorderedBulkOperation;\nmodule.exports = initializeUnorderedBulkOp;\nmodule.exports.Bulk = UnorderedBulkOperation;","map":{"version":3,"sources":["/Users/S/Desktop/nodeprotake2/node_modules/mongodb/lib/bulk/unordered.js"],"names":["common","require","BulkOperationBase","Batch","bson","utils","toError","addToOperationsList","bulkOperation","docType","document","bsonSize","calculateObjectSize","checkKeys","ignoreUndefined","s","maxBsonObjectSize","currentBatch","INSERT","currentInsertBatch","UPDATE","currentUpdateBatch","REMOVE","currentRemoveBatch","maxKeySize","currentIndex","size","maxWriteBatchSize","sizeBytes","maxBatchSizeBytes","batchType","batches","push","Array","isArray","operations","originalIndexes","bulkResult","insertedIds","index","length","_id","UnorderedBulkOperation","topology","collection","options","Object","assign","callback","writeResult","initializeUnorderedBulkOp","module","exports","Bulk"],"mappings":"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","sourcesContent":["'use strict';\n\nconst common = require('./common');\nconst BulkOperationBase = common.BulkOperationBase;\nconst Batch = common.Batch;\nconst bson = common.bson;\nconst utils = require('../utils');\nconst toError = utils.toError;\n\n/**\n * Add to internal list of Operations\n *\n * @ignore\n * @param {UnorderedBulkOperation} bulkOperation\n * @param {number} docType number indicating the document type\n * @param {object} document\n * @return {UnorderedBulkOperation}\n */\nfunction addToOperationsList(bulkOperation, docType, document) {\n  // Get the bsonSize\n  const bsonSize = bson.calculateObjectSize(document, {\n    checkKeys: false,\n\n    // Since we don't know what the user selected for BSON options here,\n    // err on the safe side, and check the size with ignoreUndefined: false.\n    ignoreUndefined: false\n  });\n  // Throw error if the doc is bigger than the max BSON size\n  if (bsonSize >= bulkOperation.s.maxBsonObjectSize)\n    throw toError('document is larger than the maximum size ' + bulkOperation.s.maxBsonObjectSize);\n  // Holds the current batch\n  bulkOperation.s.currentBatch = null;\n  // Get the right type of batch\n  if (docType === common.INSERT) {\n    bulkOperation.s.currentBatch = bulkOperation.s.currentInsertBatch;\n  } else if (docType === common.UPDATE) {\n    bulkOperation.s.currentBatch = bulkOperation.s.currentUpdateBatch;\n  } else if (docType === common.REMOVE) {\n    bulkOperation.s.currentBatch = bulkOperation.s.currentRemoveBatch;\n  }\n\n  const maxKeySize = bulkOperation.s.maxKeySize;\n\n  // Create a new batch object if we don't have a current one\n  if (bulkOperation.s.currentBatch == null)\n    bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);\n\n  // Check if we need to create a new batch\n  if (\n    // New batch if we exceed the max batch op size\n    bulkOperation.s.currentBatch.size + 1 >= bulkOperation.s.maxWriteBatchSize ||\n    // New batch if we exceed the maxBatchSizeBytes. Only matters if batch already has a doc,\n    // since we can't sent an empty batch\n    (bulkOperation.s.currentBatch.size > 0 &&\n      bulkOperation.s.currentBatch.sizeBytes + maxKeySize + bsonSize >=\n        bulkOperation.s.maxBatchSizeBytes) ||\n    // New batch if the new op does not have the same op type as the current batch\n    bulkOperation.s.currentBatch.batchType !== docType\n  ) {\n    // Save the batch to the execution stack\n    bulkOperation.s.batches.push(bulkOperation.s.currentBatch);\n\n    // Create a new batch\n    bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);\n  }\n\n  // We have an array of documents\n  if (Array.isArray(document)) {\n    throw toError('operation passed in cannot be an Array');\n  }\n\n  bulkOperation.s.currentBatch.operations.push(document);\n  bulkOperation.s.currentBatch.originalIndexes.push(bulkOperation.s.currentIndex);\n  bulkOperation.s.currentIndex = bulkOperation.s.currentIndex + 1;\n\n  // Save back the current Batch to the right type\n  if (docType === common.INSERT) {\n    bulkOperation.s.currentInsertBatch = bulkOperation.s.currentBatch;\n    bulkOperation.s.bulkResult.insertedIds.push({\n      index: bulkOperation.s.bulkResult.insertedIds.length,\n      _id: document._id\n    });\n  } else if (docType === common.UPDATE) {\n    bulkOperation.s.currentUpdateBatch = bulkOperation.s.currentBatch;\n  } else if (docType === common.REMOVE) {\n    bulkOperation.s.currentRemoveBatch = bulkOperation.s.currentBatch;\n  }\n\n  // Update current batch size\n  bulkOperation.s.currentBatch.size += 1;\n  bulkOperation.s.currentBatch.sizeBytes += maxKeySize + bsonSize;\n\n  // Return bulkOperation\n  return bulkOperation;\n}\n\n/**\n * Create a new UnorderedBulkOperation instance (INTERNAL TYPE, do not instantiate directly)\n * @class\n * @extends BulkOperationBase\n * @property {number} length Get the number of operations in the bulk.\n * @return {UnorderedBulkOperation} a UnorderedBulkOperation instance.\n */\nclass UnorderedBulkOperation extends BulkOperationBase {\n  constructor(topology, collection, options) {\n    options = options || {};\n    options = Object.assign(options, { addToOperationsList });\n\n    super(topology, collection, options, false);\n  }\n\n  handleWriteError(callback, writeResult) {\n    if (this.s.batches.length) {\n      return false;\n    }\n\n    return super.handleWriteError(callback, writeResult);\n  }\n}\n\n/**\n * Returns an unordered batch object\n * @ignore\n */\nfunction initializeUnorderedBulkOp(topology, collection, options) {\n  return new UnorderedBulkOperation(topology, collection, options);\n}\n\ninitializeUnorderedBulkOp.UnorderedBulkOperation = UnorderedBulkOperation;\nmodule.exports = initializeUnorderedBulkOp;\nmodule.exports.Bulk = UnorderedBulkOperation;\n"]},"metadata":{},"sourceType":"script"}