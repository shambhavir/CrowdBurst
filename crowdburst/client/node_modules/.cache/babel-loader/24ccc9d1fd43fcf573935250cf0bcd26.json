{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _defineProperty = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _makeStateMachine;\n\nvar EventEmitter = require('events');\n\nvar ConnectionPool = require('../../cmap/connection_pool').ConnectionPool;\n\nvar CMAP_EVENT_NAMES = require('../../cmap/events').CMAP_EVENT_NAMES;\n\nvar MongoError = require('../error').MongoError;\n\nvar relayEvents = require('../utils').relayEvents;\n\nvar BSON = require('../connection/utils').retrieveBSON();\n\nvar Logger = require('../connection/logger');\n\nvar ServerDescription = require('./server_description').ServerDescription;\n\nvar ReadPreference = require('../topologies/read_preference');\n\nvar Monitor = require('./monitor').Monitor;\n\nvar MongoNetworkError = require('../error').MongoNetworkError;\n\nvar collationNotSupported = require('../utils').collationNotSupported;\n\nvar debugOptions = require('../connection/utils').debugOptions;\n\nvar isSDAMUnrecoverableError = require('../error').isSDAMUnrecoverableError;\n\nvar isNetworkTimeoutError = require('../error').isNetworkTimeoutError;\n\nvar isNodeShuttingDownError = require('../error').isNodeShuttingDownError;\n\nvar maxWireVersion = require('../utils').maxWireVersion;\n\nvar makeStateMachine = require('../utils').makeStateMachine;\n\nvar common = require('./common'); // Used for filtering out fields for logging\n\n\nvar DEBUG_FIELDS = ['reconnect', 'reconnectTries', 'reconnectInterval', 'emitError', 'cursorFactory', 'host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectionTimeout', 'checkServerIdentity', 'socketTimeout', 'ssl', 'ca', 'crl', 'cert', 'key', 'rejectUnauthorized', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'servername'];\nvar STATE_CLOSING = common.STATE_CLOSING;\nvar STATE_CLOSED = common.STATE_CLOSED;\nvar STATE_CONNECTING = common.STATE_CONNECTING;\nvar STATE_CONNECTED = common.STATE_CONNECTED;\nvar stateTransition = makeStateMachine((_makeStateMachine = {}, _defineProperty(_makeStateMachine, STATE_CLOSED, [STATE_CLOSED, STATE_CONNECTING]), _defineProperty(_makeStateMachine, STATE_CONNECTING, [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED]), _defineProperty(_makeStateMachine, STATE_CONNECTED, [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED]), _defineProperty(_makeStateMachine, STATE_CLOSING, [STATE_CLOSING, STATE_CLOSED]), _makeStateMachine));\nvar kMonitor = Symbol('monitor');\n/**\n *\n * @fires Server#serverHeartbeatStarted\n * @fires Server#serverHeartbeatSucceeded\n * @fires Server#serverHeartbeatFailed\n */\n\nvar Server = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Server, _EventEmitter);\n\n  var _super = _createSuper(Server);\n\n  /**\n   * Create a server\n   *\n   * @param {ServerDescription} description\n   * @param {Object} options\n   */\n  function Server(description, options, topology) {\n    var _this;\n\n    _classCallCheck(this, Server);\n\n    _this = _super.call(this);\n    _this.s = {\n      // the server description\n      description: description,\n      // a saved copy of the incoming options\n      options: options,\n      // the server logger\n      logger: Logger('Server', options),\n      // the bson parser\n      bson: options.bson || new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128, BSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey, BSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp]),\n      // the server state\n      state: STATE_CLOSED,\n      credentials: options.credentials,\n      topology: topology\n    }; // create the connection pool\n    // NOTE: this used to happen in `connect`, we supported overriding pool options there\n\n    var addressParts = _this.description.address.split(':');\n\n    var poolOptions = Object.assign({\n      host: addressParts[0],\n      port: parseInt(addressParts[1], 10),\n      bson: _this.s.bson\n    }, options);\n    _this.s.pool = new ConnectionPool(poolOptions);\n    relayEvents(_this.s.pool, _assertThisInitialized(_this), ['commandStarted', 'commandSucceeded', 'commandFailed'].concat(CMAP_EVENT_NAMES));\n\n    _this.s.pool.on('clusterTimeReceived', function (clusterTime) {\n      _this.clusterTime = clusterTime;\n    }); // create the monitor\n\n\n    _this[kMonitor] = new Monitor(_assertThisInitialized(_this), _this.s.options);\n    relayEvents(_this[kMonitor], _assertThisInitialized(_this), ['serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHeartbeatFailed', // legacy events\n    'monitoring']);\n\n    _this[kMonitor].on('resetConnectionPool', function () {\n      _this.s.pool.clear();\n    });\n\n    _this[kMonitor].on('resetServer', function (error) {\n      return markServerUnknown(_assertThisInitialized(_this), error);\n    });\n\n    _this[kMonitor].on('serverHeartbeatSucceeded', function (event) {\n      _this.emit('descriptionReceived', new ServerDescription(_this.description.address, event.reply, {\n        roundTripTime: calculateRoundTripTime(_this.description.roundTripTime, event.duration)\n      }));\n\n      if (_this.s.state === STATE_CONNECTING) {\n        stateTransition(_assertThisInitialized(_this), STATE_CONNECTED);\n\n        _this.emit('connect', _assertThisInitialized(_this));\n      }\n    });\n\n    return _this;\n  }\n\n  _createClass(Server, [{\n    key: \"connect\",\n\n    /**\n     * Initiate server connect\n     */\n    value: function connect() {\n      if (this.s.state !== STATE_CLOSED) {\n        return;\n      }\n\n      stateTransition(this, STATE_CONNECTING);\n      this[kMonitor].connect();\n    }\n    /**\n     * Destroy the server connection\n     *\n     * @param {object} [options] Optional settings\n     * @param {Boolean} [options.force=false] Force destroy the pool\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy(options, callback) {\n      var _this2 = this;\n\n      if (typeof options === 'function') callback = options, options = {};\n      options = Object.assign({}, {\n        force: false\n      }, options);\n\n      if (this.s.state === STATE_CLOSED) {\n        if (typeof callback === 'function') {\n          callback();\n        }\n\n        return;\n      }\n\n      stateTransition(this, STATE_CLOSING);\n      this[kMonitor].close();\n      this.s.pool.close(options, function (err) {\n        stateTransition(_this2, STATE_CLOSED);\n\n        _this2.emit('closed');\n\n        if (typeof callback === 'function') {\n          callback(err);\n        }\n      });\n    }\n    /**\n     * Immediately schedule monitoring of this server. If there already an attempt being made\n     * this will be a no-op.\n     */\n\n  }, {\n    key: \"requestCheck\",\n    value: function requestCheck() {\n      this[kMonitor].requestCheck();\n    }\n    /**\n     * Execute a command\n     *\n     * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n     * @param {object} cmd The command hash\n     * @param {object} [options] Optional settings\n     * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n     * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n     * @param {Boolean} [options.checkKeys=false] Specify if the bson parser should validate keys.\n     * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n     * @param {Boolean} [options.fullResult=false] Return the full envelope instead of just the result document.\n     * @param {ClientSession} [options.session] Session to use for the operation\n     * @param {opResultCallback} callback A callback function\n     */\n\n  }, {\n    key: \"command\",\n    value: function command(ns, cmd, options, callback) {\n      var _this3 = this;\n\n      if (typeof options === 'function') {\n        callback = options, options = {}, options = options || {};\n      }\n\n      if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n        callback(new MongoError('server is closed'));\n        return;\n      }\n\n      var error = basicReadValidations(this, options);\n\n      if (error) {\n        return callback(error);\n      } // Clone the options\n\n\n      options = Object.assign({}, options, {\n        wireProtocolCommand: false\n      }); // Debug log\n\n      if (this.s.logger.isDebug()) {\n        this.s.logger.debug(\"executing command [\".concat(JSON.stringify({\n          ns: ns,\n          cmd: cmd,\n          options: debugOptions(DEBUG_FIELDS, options)\n        }), \"] against \").concat(this.name));\n      } // error if collation not supported\n\n\n      if (collationNotSupported(this, cmd)) {\n        callback(new MongoError(\"server \".concat(this.name, \" does not support collation\")));\n        return;\n      }\n\n      this.s.pool.withConnection(function (err, conn, cb) {\n        if (err) {\n          markServerUnknown(_this3, err);\n          return cb(err);\n        }\n\n        conn.command(ns, cmd, options, makeOperationHandler(_this3, options, cb));\n      }, callback);\n    }\n    /**\n     * Execute a query against the server\n     *\n     * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n     * @param {object} cmd The command document for the query\n     * @param {object} options Optional settings\n     * @param {function} callback\n     */\n\n  }, {\n    key: \"query\",\n    value: function query(ns, cmd, cursorState, options, callback) {\n      var _this4 = this;\n\n      if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n        callback(new MongoError('server is closed'));\n        return;\n      }\n\n      this.s.pool.withConnection(function (err, conn, cb) {\n        if (err) {\n          markServerUnknown(_this4, err);\n          return cb(err);\n        }\n\n        conn.query(ns, cmd, cursorState, options, makeOperationHandler(_this4, options, cb));\n      }, callback);\n    }\n    /**\n     * Execute a `getMore` against the server\n     *\n     * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n     * @param {object} cursorState State data associated with the cursor calling this method\n     * @param {object} options Optional settings\n     * @param {function} callback\n     */\n\n  }, {\n    key: \"getMore\",\n    value: function getMore(ns, cursorState, batchSize, options, callback) {\n      var _this5 = this;\n\n      if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n        callback(new MongoError('server is closed'));\n        return;\n      }\n\n      this.s.pool.withConnection(function (err, conn, cb) {\n        if (err) {\n          markServerUnknown(_this5, err);\n          return cb(err);\n        }\n\n        conn.getMore(ns, cursorState, batchSize, options, makeOperationHandler(_this5, options, cb));\n      }, callback);\n    }\n    /**\n     * Execute a `killCursors` command against the server\n     *\n     * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n     * @param {object} cursorState State data associated with the cursor calling this method\n     * @param {function} callback\n     */\n\n  }, {\n    key: \"killCursors\",\n    value: function killCursors(ns, cursorState, callback) {\n      var _this6 = this;\n\n      if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n        if (typeof callback === 'function') {\n          callback(new MongoError('server is closed'));\n        }\n\n        return;\n      }\n\n      this.s.pool.withConnection(function (err, conn, cb) {\n        if (err) {\n          markServerUnknown(_this6, err);\n          return cb(err);\n        }\n\n        conn.killCursors(ns, cursorState, makeOperationHandler(_this6, null, cb));\n      }, callback);\n    }\n    /**\n     * Insert one or more documents\n     * @method\n     * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n     * @param {array} ops An array of documents to insert\n     * @param {boolean} [options.ordered=true] Execute in order or out of order\n     * @param {object} [options.writeConcern={}] Write concern for the operation\n     * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n     * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n     * @param {ClientSession} [options.session] Session to use for the operation\n     * @param {opResultCallback} callback A callback function\n     */\n\n  }, {\n    key: \"insert\",\n    value: function insert(ns, ops, options, callback) {\n      executeWriteOperation({\n        server: this,\n        op: 'insert',\n        ns: ns,\n        ops: ops\n      }, options, callback);\n    }\n    /**\n     * Perform one or more update operations\n     * @method\n     * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n     * @param {array} ops An array of updates\n     * @param {boolean} [options.ordered=true] Execute in order or out of order\n     * @param {object} [options.writeConcern={}] Write concern for the operation\n     * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n     * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n     * @param {ClientSession} [options.session] Session to use for the operation\n     * @param {opResultCallback} callback A callback function\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(ns, ops, options, callback) {\n      executeWriteOperation({\n        server: this,\n        op: 'update',\n        ns: ns,\n        ops: ops\n      }, options, callback);\n    }\n    /**\n     * Perform one or more remove operations\n     * @method\n     * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n     * @param {array} ops An array of removes\n     * @param {boolean} [options.ordered=true] Execute in order or out of order\n     * @param {object} [options.writeConcern={}] Write concern for the operation\n     * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n     * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n     * @param {ClientSession} [options.session] Session to use for the operation\n     * @param {opResultCallback} callback A callback function\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(ns, ops, options, callback) {\n      executeWriteOperation({\n        server: this,\n        op: 'remove',\n        ns: ns,\n        ops: ops\n      }, options, callback);\n    }\n  }, {\n    key: \"description\",\n    get: function get() {\n      return this.s.description;\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return this.s.description.address;\n    }\n  }, {\n    key: \"autoEncrypter\",\n    get: function get() {\n      if (this.s.options && this.s.options.autoEncrypter) {\n        return this.s.options.autoEncrypter;\n      }\n\n      return null;\n    }\n  }]);\n\n  return Server;\n}(EventEmitter);\n\nObject.defineProperty(Server.prototype, 'clusterTime', {\n  get: function get() {\n    return this.s.topology.clusterTime;\n  },\n  set: function set(clusterTime) {\n    this.s.topology.clusterTime = clusterTime;\n  }\n});\n\nfunction calculateRoundTripTime(oldRtt, duration) {\n  var alpha = 0.2;\n  return alpha * duration + (1 - alpha) * oldRtt;\n}\n\nfunction basicReadValidations(server, options) {\n  if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {\n    return new MongoError('readPreference must be an instance of ReadPreference');\n  }\n}\n\nfunction executeWriteOperation(args, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {}; // TODO: once we drop Node 4, use destructuring either here or in arguments.\n\n  var server = args.server;\n  var op = args.op;\n  var ns = args.ns;\n  var ops = Array.isArray(args.ops) ? args.ops : [args.ops];\n\n  if (server.s.state === STATE_CLOSING || server.s.state === STATE_CLOSED) {\n    callback(new MongoError('server is closed'));\n    return;\n  }\n\n  if (collationNotSupported(server, options)) {\n    callback(new MongoError(\"server \".concat(server.name, \" does not support collation\")));\n    return;\n  }\n\n  server.s.pool.withConnection(function (err, conn, cb) {\n    if (err) {\n      markServerUnknown(server, err);\n      return cb(err);\n    }\n\n    conn[op](ns, ops, options, makeOperationHandler(server, options, cb));\n  }, callback);\n}\n\nfunction markServerUnknown(server, error) {\n  server.emit('descriptionReceived', new ServerDescription(server.description.address, null, {\n    error: error\n  }));\n}\n\nfunction makeOperationHandler(server, options, callback) {\n  var session = options && options.session;\n  return function handleOperationResult(err, result) {\n    if (err) {\n      if (err instanceof MongoNetworkError) {\n        if (session && !session.hasEnded) {\n          session.serverSession.isDirty = true;\n        }\n\n        if (!isNetworkTimeoutError(err)) {\n          markServerUnknown(server, err);\n          server.s.pool.clear();\n        }\n      } else if (isSDAMUnrecoverableError(err)) {\n        if (maxWireVersion(server) <= 7 || isNodeShuttingDownError(err)) {\n          server.s.pool.clear();\n        }\n\n        markServerUnknown(server, err);\n        process.nextTick(function () {\n          return server.requestCheck();\n        });\n      }\n    }\n\n    callback(err, result);\n  };\n}\n\nmodule.exports = {\n  Server: Server\n};","map":{"version":3,"sources":["/Users/S/Desktop/nodeprotake2/node_modules/mongodb/lib/core/sdam/server.js"],"names":["EventEmitter","require","ConnectionPool","CMAP_EVENT_NAMES","MongoError","relayEvents","BSON","retrieveBSON","Logger","ServerDescription","ReadPreference","Monitor","MongoNetworkError","collationNotSupported","debugOptions","isSDAMUnrecoverableError","isNetworkTimeoutError","isNodeShuttingDownError","maxWireVersion","makeStateMachine","common","DEBUG_FIELDS","STATE_CLOSING","STATE_CLOSED","STATE_CONNECTING","STATE_CONNECTED","stateTransition","kMonitor","Symbol","Server","description","options","topology","s","logger","bson","Binary","Code","DBRef","Decimal128","Double","Int32","Long","Map","MaxKey","MinKey","ObjectId","BSONRegExp","Timestamp","state","credentials","addressParts","address","split","poolOptions","Object","assign","host","port","parseInt","pool","concat","on","clusterTime","clear","error","markServerUnknown","event","emit","reply","roundTripTime","calculateRoundTripTime","duration","connect","callback","force","close","err","requestCheck","ns","cmd","basicReadValidations","wireProtocolCommand","isDebug","debug","JSON","stringify","name","withConnection","conn","cb","command","makeOperationHandler","cursorState","query","batchSize","getMore","killCursors","ops","executeWriteOperation","server","op","autoEncrypter","defineProperty","prototype","get","set","oldRtt","alpha","readPreference","args","Array","isArray","session","handleOperationResult","result","hasEnded","serverSession","isDirty","process","nextTick","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst EventEmitter = require('events');\nconst ConnectionPool = require('../../cmap/connection_pool').ConnectionPool;\nconst CMAP_EVENT_NAMES = require('../../cmap/events').CMAP_EVENT_NAMES;\nconst MongoError = require('../error').MongoError;\nconst relayEvents = require('../utils').relayEvents;\nconst BSON = require('../connection/utils').retrieveBSON();\nconst Logger = require('../connection/logger');\nconst ServerDescription = require('./server_description').ServerDescription;\nconst ReadPreference = require('../topologies/read_preference');\nconst Monitor = require('./monitor').Monitor;\nconst MongoNetworkError = require('../error').MongoNetworkError;\nconst collationNotSupported = require('../utils').collationNotSupported;\nconst debugOptions = require('../connection/utils').debugOptions;\nconst isSDAMUnrecoverableError = require('../error').isSDAMUnrecoverableError;\nconst isNetworkTimeoutError = require('../error').isNetworkTimeoutError;\nconst isNodeShuttingDownError = require('../error').isNodeShuttingDownError;\nconst maxWireVersion = require('../utils').maxWireVersion;\nconst makeStateMachine = require('../utils').makeStateMachine;\nconst common = require('./common');\n\n// Used for filtering out fields for logging\nconst DEBUG_FIELDS = [\n  'reconnect',\n  'reconnectTries',\n  'reconnectInterval',\n  'emitError',\n  'cursorFactory',\n  'host',\n  'port',\n  'size',\n  'keepAlive',\n  'keepAliveInitialDelay',\n  'noDelay',\n  'connectionTimeout',\n  'checkServerIdentity',\n  'socketTimeout',\n  'ssl',\n  'ca',\n  'crl',\n  'cert',\n  'key',\n  'rejectUnauthorized',\n  'promoteLongs',\n  'promoteValues',\n  'promoteBuffers',\n  'servername'\n];\n\nconst STATE_CLOSING = common.STATE_CLOSING;\nconst STATE_CLOSED = common.STATE_CLOSED;\nconst STATE_CONNECTING = common.STATE_CONNECTING;\nconst STATE_CONNECTED = common.STATE_CONNECTED;\nconst stateTransition = makeStateMachine({\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_CONNECTING],\n  [STATE_CONNECTING]: [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED],\n  [STATE_CONNECTED]: [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED],\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED]\n});\n\nconst kMonitor = Symbol('monitor');\n\n/**\n *\n * @fires Server#serverHeartbeatStarted\n * @fires Server#serverHeartbeatSucceeded\n * @fires Server#serverHeartbeatFailed\n */\nclass Server extends EventEmitter {\n  /**\n   * Create a server\n   *\n   * @param {ServerDescription} description\n   * @param {Object} options\n   */\n  constructor(description, options, topology) {\n    super();\n\n    this.s = {\n      // the server description\n      description,\n      // a saved copy of the incoming options\n      options,\n      // the server logger\n      logger: Logger('Server', options),\n      // the bson parser\n      bson:\n        options.bson ||\n        new BSON([\n          BSON.Binary,\n          BSON.Code,\n          BSON.DBRef,\n          BSON.Decimal128,\n          BSON.Double,\n          BSON.Int32,\n          BSON.Long,\n          BSON.Map,\n          BSON.MaxKey,\n          BSON.MinKey,\n          BSON.ObjectId,\n          BSON.BSONRegExp,\n          BSON.Symbol,\n          BSON.Timestamp\n        ]),\n      // the server state\n      state: STATE_CLOSED,\n      credentials: options.credentials,\n      topology\n    };\n\n    // create the connection pool\n    // NOTE: this used to happen in `connect`, we supported overriding pool options there\n    const addressParts = this.description.address.split(':');\n    const poolOptions = Object.assign(\n      { host: addressParts[0], port: parseInt(addressParts[1], 10), bson: this.s.bson },\n      options\n    );\n\n    this.s.pool = new ConnectionPool(poolOptions);\n    relayEvents(\n      this.s.pool,\n      this,\n      ['commandStarted', 'commandSucceeded', 'commandFailed'].concat(CMAP_EVENT_NAMES)\n    );\n\n    this.s.pool.on('clusterTimeReceived', clusterTime => {\n      this.clusterTime = clusterTime;\n    });\n\n    // create the monitor\n    this[kMonitor] = new Monitor(this, this.s.options);\n    relayEvents(this[kMonitor], this, [\n      'serverHeartbeatStarted',\n      'serverHeartbeatSucceeded',\n      'serverHeartbeatFailed',\n\n      // legacy events\n      'monitoring'\n    ]);\n\n    this[kMonitor].on('resetConnectionPool', () => {\n      this.s.pool.clear();\n    });\n\n    this[kMonitor].on('resetServer', error => markServerUnknown(this, error));\n    this[kMonitor].on('serverHeartbeatSucceeded', event => {\n      this.emit(\n        'descriptionReceived',\n        new ServerDescription(this.description.address, event.reply, {\n          roundTripTime: calculateRoundTripTime(this.description.roundTripTime, event.duration)\n        })\n      );\n\n      if (this.s.state === STATE_CONNECTING) {\n        stateTransition(this, STATE_CONNECTED);\n        this.emit('connect', this);\n      }\n    });\n  }\n\n  get description() {\n    return this.s.description;\n  }\n\n  get name() {\n    return this.s.description.address;\n  }\n\n  get autoEncrypter() {\n    if (this.s.options && this.s.options.autoEncrypter) {\n      return this.s.options.autoEncrypter;\n    }\n    return null;\n  }\n\n  /**\n   * Initiate server connect\n   */\n  connect() {\n    if (this.s.state !== STATE_CLOSED) {\n      return;\n    }\n\n    stateTransition(this, STATE_CONNECTING);\n    this[kMonitor].connect();\n  }\n\n  /**\n   * Destroy the server connection\n   *\n   * @param {object} [options] Optional settings\n   * @param {Boolean} [options.force=false] Force destroy the pool\n   */\n  destroy(options, callback) {\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = Object.assign({}, { force: false }, options);\n\n    if (this.s.state === STATE_CLOSED) {\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n\n    this[kMonitor].close();\n    this.s.pool.close(options, err => {\n      stateTransition(this, STATE_CLOSED);\n      this.emit('closed');\n      if (typeof callback === 'function') {\n        callback(err);\n      }\n    });\n  }\n\n  /**\n   * Immediately schedule monitoring of this server. If there already an attempt being made\n   * this will be a no-op.\n   */\n  requestCheck() {\n    this[kMonitor].requestCheck();\n  }\n\n  /**\n   * Execute a command\n   *\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {object} cmd The command hash\n   * @param {object} [options] Optional settings\n   * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.checkKeys=false] Specify if the bson parser should validate keys.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {Boolean} [options.fullResult=false] Return the full envelope instead of just the result document.\n   * @param {ClientSession} [options.session] Session to use for the operation\n   * @param {opResultCallback} callback A callback function\n   */\n  command(ns, cmd, options, callback) {\n    if (typeof options === 'function') {\n      (callback = options), (options = {}), (options = options || {});\n    }\n\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      callback(new MongoError('server is closed'));\n      return;\n    }\n\n    const error = basicReadValidations(this, options);\n    if (error) {\n      return callback(error);\n    }\n\n    // Clone the options\n    options = Object.assign({}, options, { wireProtocolCommand: false });\n\n    // Debug log\n    if (this.s.logger.isDebug()) {\n      this.s.logger.debug(\n        `executing command [${JSON.stringify({\n          ns,\n          cmd,\n          options: debugOptions(DEBUG_FIELDS, options)\n        })}] against ${this.name}`\n      );\n    }\n\n    // error if collation not supported\n    if (collationNotSupported(this, cmd)) {\n      callback(new MongoError(`server ${this.name} does not support collation`));\n      return;\n    }\n\n    this.s.pool.withConnection((err, conn, cb) => {\n      if (err) {\n        markServerUnknown(this, err);\n        return cb(err);\n      }\n\n      conn.command(ns, cmd, options, makeOperationHandler(this, options, cb));\n    }, callback);\n  }\n\n  /**\n   * Execute a query against the server\n   *\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {object} cmd The command document for the query\n   * @param {object} options Optional settings\n   * @param {function} callback\n   */\n  query(ns, cmd, cursorState, options, callback) {\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      callback(new MongoError('server is closed'));\n      return;\n    }\n\n    this.s.pool.withConnection((err, conn, cb) => {\n      if (err) {\n        markServerUnknown(this, err);\n        return cb(err);\n      }\n\n      conn.query(ns, cmd, cursorState, options, makeOperationHandler(this, options, cb));\n    }, callback);\n  }\n\n  /**\n   * Execute a `getMore` against the server\n   *\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {object} cursorState State data associated with the cursor calling this method\n   * @param {object} options Optional settings\n   * @param {function} callback\n   */\n  getMore(ns, cursorState, batchSize, options, callback) {\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      callback(new MongoError('server is closed'));\n      return;\n    }\n\n    this.s.pool.withConnection((err, conn, cb) => {\n      if (err) {\n        markServerUnknown(this, err);\n        return cb(err);\n      }\n\n      conn.getMore(ns, cursorState, batchSize, options, makeOperationHandler(this, options, cb));\n    }, callback);\n  }\n\n  /**\n   * Execute a `killCursors` command against the server\n   *\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {object} cursorState State data associated with the cursor calling this method\n   * @param {function} callback\n   */\n  killCursors(ns, cursorState, callback) {\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      if (typeof callback === 'function') {\n        callback(new MongoError('server is closed'));\n      }\n\n      return;\n    }\n\n    this.s.pool.withConnection((err, conn, cb) => {\n      if (err) {\n        markServerUnknown(this, err);\n        return cb(err);\n      }\n\n      conn.killCursors(ns, cursorState, makeOperationHandler(this, null, cb));\n    }, callback);\n  }\n\n  /**\n   * Insert one or more documents\n   * @method\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {array} ops An array of documents to insert\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\n   * @param {object} [options.writeConcern={}] Write concern for the operation\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {ClientSession} [options.session] Session to use for the operation\n   * @param {opResultCallback} callback A callback function\n   */\n  insert(ns, ops, options, callback) {\n    executeWriteOperation({ server: this, op: 'insert', ns, ops }, options, callback);\n  }\n\n  /**\n   * Perform one or more update operations\n   * @method\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {array} ops An array of updates\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\n   * @param {object} [options.writeConcern={}] Write concern for the operation\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {ClientSession} [options.session] Session to use for the operation\n   * @param {opResultCallback} callback A callback function\n   */\n  update(ns, ops, options, callback) {\n    executeWriteOperation({ server: this, op: 'update', ns, ops }, options, callback);\n  }\n\n  /**\n   * Perform one or more remove operations\n   * @method\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {array} ops An array of removes\n   * @param {boolean} [options.ordered=true] Execute in order or out of order\n   * @param {object} [options.writeConcern={}] Write concern for the operation\n   * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n   * @param {ClientSession} [options.session] Session to use for the operation\n   * @param {opResultCallback} callback A callback function\n   */\n  remove(ns, ops, options, callback) {\n    executeWriteOperation({ server: this, op: 'remove', ns, ops }, options, callback);\n  }\n}\n\nObject.defineProperty(Server.prototype, 'clusterTime', {\n  get: function() {\n    return this.s.topology.clusterTime;\n  },\n  set: function(clusterTime) {\n    this.s.topology.clusterTime = clusterTime;\n  }\n});\n\nfunction calculateRoundTripTime(oldRtt, duration) {\n  const alpha = 0.2;\n  return alpha * duration + (1 - alpha) * oldRtt;\n}\n\nfunction basicReadValidations(server, options) {\n  if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {\n    return new MongoError('readPreference must be an instance of ReadPreference');\n  }\n}\n\nfunction executeWriteOperation(args, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options || {};\n\n  // TODO: once we drop Node 4, use destructuring either here or in arguments.\n  const server = args.server;\n  const op = args.op;\n  const ns = args.ns;\n  const ops = Array.isArray(args.ops) ? args.ops : [args.ops];\n\n  if (server.s.state === STATE_CLOSING || server.s.state === STATE_CLOSED) {\n    callback(new MongoError('server is closed'));\n    return;\n  }\n\n  if (collationNotSupported(server, options)) {\n    callback(new MongoError(`server ${server.name} does not support collation`));\n    return;\n  }\n\n  server.s.pool.withConnection((err, conn, cb) => {\n    if (err) {\n      markServerUnknown(server, err);\n      return cb(err);\n    }\n\n    conn[op](ns, ops, options, makeOperationHandler(server, options, cb));\n  }, callback);\n}\n\nfunction markServerUnknown(server, error) {\n  server.emit(\n    'descriptionReceived',\n    new ServerDescription(server.description.address, null, { error })\n  );\n}\n\nfunction makeOperationHandler(server, options, callback) {\n  const session = options && options.session;\n\n  return function handleOperationResult(err, result) {\n    if (err) {\n      if (err instanceof MongoNetworkError) {\n        if (session && !session.hasEnded) {\n          session.serverSession.isDirty = true;\n        }\n\n        if (!isNetworkTimeoutError(err)) {\n          markServerUnknown(server, err);\n          server.s.pool.clear();\n        }\n      } else if (isSDAMUnrecoverableError(err)) {\n        if (maxWireVersion(server) <= 7 || isNodeShuttingDownError(err)) {\n          server.s.pool.clear();\n        }\n\n        markServerUnknown(server, err);\n        process.nextTick(() => server.requestCheck());\n      }\n    }\n\n    callback(err, result);\n  };\n}\n\nmodule.exports = {\n  Server\n};\n"]},"metadata":{},"sourceType":"script"}