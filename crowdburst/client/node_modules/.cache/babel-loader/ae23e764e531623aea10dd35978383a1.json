{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/S/Desktop/nodeprotake2/crowdburst/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar EventEmitter = require('events');\n\nvar MessageStream = require('./message_stream');\n\nvar MongoError = require('../core/error').MongoError;\n\nvar MongoNetworkError = require('../core/error').MongoNetworkError;\n\nvar MongoWriteConcernError = require('../core/error').MongoWriteConcernError;\n\nvar CommandResult = require('../core/connection/command_result');\n\nvar StreamDescription = require('./stream_description').StreamDescription;\n\nvar wp = require('../core/wireprotocol');\n\nvar apm = require('../core/connection/apm');\n\nvar updateSessionFromResponse = require('../core/sessions').updateSessionFromResponse;\n\nvar uuidV4 = require('../core/utils').uuidV4;\n\nvar kStream = Symbol('stream');\nvar kQueue = Symbol('queue');\nvar kMessageStream = Symbol('messageStream');\nvar kGeneration = Symbol('generation');\nvar kLastUseTime = Symbol('lastUseTime');\nvar kClusterTime = Symbol('clusterTime');\nvar kDescription = Symbol('description');\nvar kIsMaster = Symbol('ismaster');\nvar kAutoEncrypter = Symbol('autoEncrypter');\n\nvar Connection = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Connection, _EventEmitter);\n\n  var _super = _createSuper(Connection);\n\n  function Connection(stream, options) {\n    var _this;\n\n    _classCallCheck(this, Connection);\n\n    _this = _super.call(this, options);\n    _this.id = options.id;\n    _this.address = streamIdentifier(stream);\n    _this.bson = options.bson;\n    _this.socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 360000;\n    _this.monitorCommands = typeof options.monitorCommands === 'boolean' ? options.monitorCommands : false;\n    _this.closed = false;\n    _this.destroyed = false;\n    _this[kDescription] = new StreamDescription(_this.address, options);\n    _this[kGeneration] = options.generation;\n    _this[kLastUseTime] = Date.now(); // retain a reference to an `AutoEncrypter` if present\n\n    if (options.autoEncrypter) {\n      _this[kAutoEncrypter] = options.autoEncrypter;\n    } // setup parser stream and message handling\n\n\n    _this[kQueue] = new Map();\n    _this[kMessageStream] = new MessageStream(options);\n\n    _this[kMessageStream].on('message', messageHandler(_assertThisInitialized(_this)));\n\n    _this[kStream] = stream;\n    stream.on('error', function () {\n      /* ignore errors, listen to `close` instead */\n    });\n    stream.on('close', function () {\n      if (_this.closed) {\n        return;\n      }\n\n      _this.closed = true;\n\n      _this[kQueue].forEach(function (op) {\n        return op.cb(new MongoNetworkError(\"connection \".concat(_this.id, \" to \").concat(_this.address, \" closed\")));\n      });\n\n      _this[kQueue].clear();\n\n      _this.emit('close');\n    });\n    stream.on('timeout', function () {\n      if (_this.closed) {\n        return;\n      }\n\n      stream.destroy();\n      _this.closed = true;\n\n      _this[kQueue].forEach(function (op) {\n        return op.cb(new MongoNetworkError(\"connection \".concat(_this.id, \" to \").concat(_this.address, \" timed out\")));\n      });\n\n      _this[kQueue].clear();\n\n      _this.emit('close');\n    }); // hook the message stream up to the passed in stream\n\n    stream.pipe(_this[kMessageStream]);\n\n    _this[kMessageStream].pipe(stream);\n\n    return _this;\n  }\n\n  _createClass(Connection, [{\n    key: \"markAvailable\",\n    value: function markAvailable() {\n      this[kLastUseTime] = Date.now();\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(options, callback) {\n      var _this2 = this;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = Object.assign({\n        force: false\n      }, options);\n\n      if (this[kStream] == null || this.destroyed) {\n        this.destroyed = true;\n\n        if (typeof callback === 'function') {\n          callback();\n        }\n\n        return;\n      }\n\n      if (options.force) {\n        this[kStream].destroy();\n        this.destroyed = true;\n\n        if (typeof callback === 'function') {\n          callback();\n        }\n\n        return;\n      }\n\n      this[kStream].end(function (err) {\n        _this2.destroyed = true;\n\n        if (typeof callback === 'function') {\n          callback(err);\n        }\n      });\n    } // Wire protocol methods\n\n  }, {\n    key: \"command\",\n    value: function command(ns, cmd, options, callback) {\n      wp.command(makeServerTrampoline(this), ns, cmd, options, callback);\n    }\n  }, {\n    key: \"query\",\n    value: function query(ns, cmd, cursorState, options, callback) {\n      wp.query(makeServerTrampoline(this), ns, cmd, cursorState, options, callback);\n    }\n  }, {\n    key: \"getMore\",\n    value: function getMore(ns, cursorState, batchSize, options, callback) {\n      wp.getMore(makeServerTrampoline(this), ns, cursorState, batchSize, options, callback);\n    }\n  }, {\n    key: \"killCursors\",\n    value: function killCursors(ns, cursorState, callback) {\n      wp.killCursors(makeServerTrampoline(this), ns, cursorState, callback);\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(ns, ops, options, callback) {\n      wp.insert(makeServerTrampoline(this), ns, ops, options, callback);\n    }\n  }, {\n    key: \"update\",\n    value: function update(ns, ops, options, callback) {\n      wp.update(makeServerTrampoline(this), ns, ops, options, callback);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(ns, ops, options, callback) {\n      wp.remove(makeServerTrampoline(this), ns, ops, options, callback);\n    }\n  }, {\n    key: \"description\",\n    get: function get() {\n      return this[kDescription];\n    }\n  }, {\n    key: \"ismaster\",\n    get: function get() {\n      return this[kIsMaster];\n    } // the `connect` method stores the result of the handshake ismaster on the connection\n    ,\n    set: function set(response) {\n      this[kDescription].receiveResponse(response); // TODO: remove this, and only use the `StreamDescription` in the future\n\n      this[kIsMaster] = response;\n    }\n  }, {\n    key: \"generation\",\n    get: function get() {\n      return this[kGeneration] || 0;\n    }\n  }, {\n    key: \"idleTime\",\n    get: function get() {\n      return Date.now() - this[kLastUseTime];\n    }\n  }, {\n    key: \"clusterTime\",\n    get: function get() {\n      return this[kClusterTime];\n    }\n  }, {\n    key: \"stream\",\n    get: function get() {\n      return this[kStream];\n    }\n  }]);\n\n  return Connection;\n}(EventEmitter); /// This lets us emulate a legacy `Server` instance so we can work with the existing wire\n/// protocol methods. Eventually, the operation executor will return a `Connection` to execute\n/// against.\n\n\nfunction makeServerTrampoline(connection) {\n  var server = {\n    description: connection.description,\n    clusterTime: connection[kClusterTime],\n    s: {\n      bson: connection.bson,\n      pool: {\n        write: write.bind(connection),\n        isConnected: function isConnected() {\n          return true;\n        }\n      }\n    }\n  };\n\n  if (connection[kAutoEncrypter]) {\n    server.autoEncrypter = connection[kAutoEncrypter];\n  }\n\n  return server;\n}\n\nfunction messageHandler(conn) {\n  return function messageHandler(message) {\n    // always emit the message, in case we are streaming\n    conn.emit('message', message);\n\n    if (!conn[kQueue].has(message.responseTo)) {\n      return;\n    }\n\n    var operationDescription = conn[kQueue].get(message.responseTo); // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n\n    conn[kQueue].delete(message.responseTo);\n\n    if (message.moreToCome) {\n      // requeue the callback for next synthetic request\n      conn[kQueue].set(message.requestId, operationDescription);\n    }\n\n    var callback = operationDescription.cb;\n\n    if (operationDescription.socketTimeoutOverride) {\n      conn[kStream].setTimeout(conn.socketTimeout);\n    }\n\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      callback(new MongoError(err));\n      return;\n    }\n\n    if (message.documents[0]) {\n      var document = message.documents[0];\n      var session = operationDescription.session;\n\n      if (session) {\n        updateSessionFromResponse(session, document);\n      }\n\n      if (document.$clusterTime) {\n        conn[kClusterTime] = document.$clusterTime;\n        conn.emit('clusterTimeReceived', document.$clusterTime);\n      }\n\n      if (operationDescription.command) {\n        if (document.writeConcernError) {\n          callback(new MongoWriteConcernError(document.writeConcernError, document));\n          return;\n        }\n\n        if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n          callback(new MongoError(document));\n          return;\n        }\n      }\n    } // NODE-2382: reenable in our glorious non-leaky abstraction future\n    // callback(null, operationDescription.fullResult ? message : message.documents[0]);\n\n\n    callback(undefined, new CommandResult(operationDescription.fullResult ? message : message.documents[0], conn, message));\n  };\n}\n\nfunction streamIdentifier(stream) {\n  if (typeof stream.address === 'function') {\n    return \"\".concat(stream.remoteAddress, \":\").concat(stream.remotePort);\n  }\n\n  return uuidV4().toString('hex');\n} // Not meant to be called directly, the wire protocol methods call this assuming it is a `Pool` instance\n\n\nfunction write(command, options, callback) {\n  var _this3 = this;\n\n  if (typeof options === 'function') {\n    callback = options;\n  }\n\n  options = options || {};\n  var operationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    fullResult: typeof options.fullResult === 'boolean' ? options.fullResult : false,\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    command: !!options.command,\n    // for BSON parsing\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    raw: typeof options.raw === 'boolean' ? options.raw : false\n  };\n\n  if (this[kDescription] && this[kDescription].compressor) {\n    operationDescription.agreedCompressor = this[kDescription].compressor;\n\n    if (this[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = this[kDescription].zlibCompressionLevel;\n    }\n  }\n\n  if (typeof options.socketTimeout === 'number') {\n    operationDescription.socketTimeoutOverride = true;\n    this[kStream].setTimeout(options.socketTimeout);\n  } // if command monitoring is enabled we need to modify the callback here\n\n\n  if (this.monitorCommands) {\n    this.emit('commandStarted', new apm.CommandStartedEvent(this, command));\n    operationDescription.started = process.hrtime();\n\n    operationDescription.cb = function (err, reply) {\n      if (err) {\n        _this3.emit('commandFailed', new apm.CommandFailedEvent(_this3, command, err, operationDescription.started));\n      } else {\n        if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {\n          _this3.emit('commandFailed', new apm.CommandFailedEvent(_this3, command, reply.result, operationDescription.started));\n        } else {\n          _this3.emit('commandSucceeded', new apm.CommandSucceededEvent(_this3, command, reply, operationDescription.started));\n        }\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, reply);\n      }\n    };\n  }\n\n  if (!operationDescription.noResponse) {\n    this[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n\n  try {\n    this[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      this[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}\n\nmodule.exports = {\n  Connection: Connection\n};","map":{"version":3,"sources":["/Users/S/Desktop/nodeprotake2/node_modules/mongodb/lib/cmap/connection.js"],"names":["EventEmitter","require","MessageStream","MongoError","MongoNetworkError","MongoWriteConcernError","CommandResult","StreamDescription","wp","apm","updateSessionFromResponse","uuidV4","kStream","Symbol","kQueue","kMessageStream","kGeneration","kLastUseTime","kClusterTime","kDescription","kIsMaster","kAutoEncrypter","Connection","stream","options","id","address","streamIdentifier","bson","socketTimeout","monitorCommands","closed","destroyed","generation","Date","now","autoEncrypter","Map","on","messageHandler","forEach","op","cb","clear","emit","destroy","pipe","callback","Object","assign","force","end","err","ns","cmd","command","makeServerTrampoline","cursorState","query","batchSize","getMore","killCursors","ops","insert","update","remove","response","receiveResponse","connection","server","description","clusterTime","s","pool","write","bind","isConnected","conn","message","has","responseTo","operationDescription","get","delete","moreToCome","set","requestId","socketTimeoutOverride","setTimeout","parse","documents","document","session","$clusterTime","writeConcernError","ok","$err","errmsg","code","undefined","fullResult","remoteAddress","remotePort","toString","noResponse","documentsReturnedIn","promoteLongs","promoteValues","promoteBuffers","raw","compressor","agreedCompressor","zlibCompressionLevel","CommandStartedEvent","started","process","hrtime","reply","CommandFailedEvent","result","CommandSucceededEvent","writeCommand","e","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst MessageStream = require('./message_stream');\nconst MongoError = require('../core/error').MongoError;\nconst MongoNetworkError = require('../core/error').MongoNetworkError;\nconst MongoWriteConcernError = require('../core/error').MongoWriteConcernError;\nconst CommandResult = require('../core/connection/command_result');\nconst StreamDescription = require('./stream_description').StreamDescription;\nconst wp = require('../core/wireprotocol');\nconst apm = require('../core/connection/apm');\nconst updateSessionFromResponse = require('../core/sessions').updateSessionFromResponse;\nconst uuidV4 = require('../core/utils').uuidV4;\n\nconst kStream = Symbol('stream');\nconst kQueue = Symbol('queue');\nconst kMessageStream = Symbol('messageStream');\nconst kGeneration = Symbol('generation');\nconst kLastUseTime = Symbol('lastUseTime');\nconst kClusterTime = Symbol('clusterTime');\nconst kDescription = Symbol('description');\nconst kIsMaster = Symbol('ismaster');\nconst kAutoEncrypter = Symbol('autoEncrypter');\n\nclass Connection extends EventEmitter {\n  constructor(stream, options) {\n    super(options);\n\n    this.id = options.id;\n    this.address = streamIdentifier(stream);\n    this.bson = options.bson;\n    this.socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 360000;\n    this.monitorCommands =\n      typeof options.monitorCommands === 'boolean' ? options.monitorCommands : false;\n    this.closed = false;\n    this.destroyed = false;\n\n    this[kDescription] = new StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = Date.now();\n\n    // retain a reference to an `AutoEncrypter` if present\n    if (options.autoEncrypter) {\n      this[kAutoEncrypter] = options.autoEncrypter;\n    }\n\n    // setup parser stream and message handling\n    this[kQueue] = new Map();\n    this[kMessageStream] = new MessageStream(options);\n    this[kMessageStream].on('message', messageHandler(this));\n    this[kStream] = stream;\n    stream.on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    });\n\n    stream.on('close', () => {\n      if (this.closed) {\n        return;\n      }\n\n      this.closed = true;\n      this[kQueue].forEach(op =>\n        op.cb(new MongoNetworkError(`connection ${this.id} to ${this.address} closed`))\n      );\n      this[kQueue].clear();\n\n      this.emit('close');\n    });\n\n    stream.on('timeout', () => {\n      if (this.closed) {\n        return;\n      }\n\n      stream.destroy();\n      this.closed = true;\n      this[kQueue].forEach(op =>\n        op.cb(new MongoNetworkError(`connection ${this.id} to ${this.address} timed out`))\n      );\n      this[kQueue].clear();\n\n      this.emit('close');\n    });\n\n    // hook the message stream up to the passed in stream\n    stream.pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(stream);\n  }\n\n  get description() {\n    return this[kDescription];\n  }\n\n  get ismaster() {\n    return this[kIsMaster];\n  }\n\n  // the `connect` method stores the result of the handshake ismaster on the connection\n  set ismaster(response) {\n    this[kDescription].receiveResponse(response);\n\n    // TODO: remove this, and only use the `StreamDescription` in the future\n    this[kIsMaster] = response;\n  }\n\n  get generation() {\n    return this[kGeneration] || 0;\n  }\n\n  get idleTime() {\n    return Date.now() - this[kLastUseTime];\n  }\n\n  get clusterTime() {\n    return this[kClusterTime];\n  }\n\n  get stream() {\n    return this[kStream];\n  }\n\n  markAvailable() {\n    this[kLastUseTime] = Date.now();\n  }\n\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = Object.assign({ force: false }, options);\n    if (this[kStream] == null || this.destroyed) {\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    if (options.force) {\n      this[kStream].destroy();\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    this[kStream].end(err => {\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback(err);\n      }\n    });\n  }\n\n  // Wire protocol methods\n  command(ns, cmd, options, callback) {\n    wp.command(makeServerTrampoline(this), ns, cmd, options, callback);\n  }\n\n  query(ns, cmd, cursorState, options, callback) {\n    wp.query(makeServerTrampoline(this), ns, cmd, cursorState, options, callback);\n  }\n\n  getMore(ns, cursorState, batchSize, options, callback) {\n    wp.getMore(makeServerTrampoline(this), ns, cursorState, batchSize, options, callback);\n  }\n\n  killCursors(ns, cursorState, callback) {\n    wp.killCursors(makeServerTrampoline(this), ns, cursorState, callback);\n  }\n\n  insert(ns, ops, options, callback) {\n    wp.insert(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n\n  update(ns, ops, options, callback) {\n    wp.update(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n\n  remove(ns, ops, options, callback) {\n    wp.remove(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n}\n\n/// This lets us emulate a legacy `Server` instance so we can work with the existing wire\n/// protocol methods. Eventually, the operation executor will return a `Connection` to execute\n/// against.\nfunction makeServerTrampoline(connection) {\n  const server = {\n    description: connection.description,\n    clusterTime: connection[kClusterTime],\n    s: {\n      bson: connection.bson,\n      pool: { write: write.bind(connection), isConnected: () => true }\n    }\n  };\n\n  if (connection[kAutoEncrypter]) {\n    server.autoEncrypter = connection[kAutoEncrypter];\n  }\n\n  return server;\n}\n\nfunction messageHandler(conn) {\n  return function messageHandler(message) {\n    // always emit the message, in case we are streaming\n    conn.emit('message', message);\n    if (!conn[kQueue].has(message.responseTo)) {\n      return;\n    }\n\n    const operationDescription = conn[kQueue].get(message.responseTo);\n\n    // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n    conn[kQueue].delete(message.responseTo);\n    if (message.moreToCome) {\n      // requeue the callback for next synthetic request\n      conn[kQueue].set(message.requestId, operationDescription);\n    }\n\n    const callback = operationDescription.cb;\n    if (operationDescription.socketTimeoutOverride) {\n      conn[kStream].setTimeout(conn.socketTimeout);\n    }\n\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      callback(new MongoError(err));\n      return;\n    }\n\n    if (message.documents[0]) {\n      const document = message.documents[0];\n      const session = operationDescription.session;\n      if (session) {\n        updateSessionFromResponse(session, document);\n      }\n\n      if (document.$clusterTime) {\n        conn[kClusterTime] = document.$clusterTime;\n        conn.emit('clusterTimeReceived', document.$clusterTime);\n      }\n\n      if (operationDescription.command) {\n        if (document.writeConcernError) {\n          callback(new MongoWriteConcernError(document.writeConcernError, document));\n          return;\n        }\n\n        if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n          callback(new MongoError(document));\n          return;\n        }\n      }\n    }\n\n    // NODE-2382: reenable in our glorious non-leaky abstraction future\n    // callback(null, operationDescription.fullResult ? message : message.documents[0]);\n\n    callback(\n      undefined,\n      new CommandResult(\n        operationDescription.fullResult ? message : message.documents[0],\n        conn,\n        message\n      )\n    );\n  };\n}\n\nfunction streamIdentifier(stream) {\n  if (typeof stream.address === 'function') {\n    return `${stream.remoteAddress}:${stream.remotePort}`;\n  }\n\n  return uuidV4().toString('hex');\n}\n\n// Not meant to be called directly, the wire protocol methods call this assuming it is a `Pool` instance\nfunction write(command, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n  }\n\n  options = options || {};\n  const operationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    fullResult: typeof options.fullResult === 'boolean' ? options.fullResult : false,\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    command: !!options.command,\n\n    // for BSON parsing\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    raw: typeof options.raw === 'boolean' ? options.raw : false\n  };\n\n  if (this[kDescription] && this[kDescription].compressor) {\n    operationDescription.agreedCompressor = this[kDescription].compressor;\n\n    if (this[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = this[kDescription].zlibCompressionLevel;\n    }\n  }\n\n  if (typeof options.socketTimeout === 'number') {\n    operationDescription.socketTimeoutOverride = true;\n    this[kStream].setTimeout(options.socketTimeout);\n  }\n\n  // if command monitoring is enabled we need to modify the callback here\n  if (this.monitorCommands) {\n    this.emit('commandStarted', new apm.CommandStartedEvent(this, command));\n\n    operationDescription.started = process.hrtime();\n    operationDescription.cb = (err, reply) => {\n      if (err) {\n        this.emit(\n          'commandFailed',\n          new apm.CommandFailedEvent(this, command, err, operationDescription.started)\n        );\n      } else {\n        if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {\n          this.emit(\n            'commandFailed',\n            new apm.CommandFailedEvent(this, command, reply.result, operationDescription.started)\n          );\n        } else {\n          this.emit(\n            'commandSucceeded',\n            new apm.CommandSucceededEvent(this, command, reply, operationDescription.started)\n          );\n        }\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, reply);\n      }\n    };\n  }\n\n  if (!operationDescription.noResponse) {\n    this[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n\n  try {\n    this[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      this[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}\n\nmodule.exports = {\n  Connection\n};\n"]},"metadata":{},"sourceType":"script"}