import { Component, Injectable, Input, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Store, StoreModule, createFeatureSelector, createSelector } from '@ngrx/store';
import { Actions, Effect, EffectsModule } from '@ngrx/effects';
import { RouterModule } from '@angular/router';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/catch';
import 'rxjs/add/operator/startWith';
import 'rxjs/add/operator/switchMap';
import 'rxjs/add/operator/toArray';
import 'rxjs/add/observable/of';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/operator/do';
import 'rxjs/add/observable/throw';
import { HttpInterceptorService } from '@covalent/http/index';
import { FormsModule } from '@angular/forms';
import { MaterialModule } from '@angular/material';
import { FlexLayoutModule } from '@angular/flex-layout/index';
import 'hammerjs';

const LOAD_SUBSCRIPTION = '[subscription] LOAD_SUBSCRIPTION';
const LOAD_SUBSCRIPTION_SUCCESS = '[subscription] LOAD_SUBSCRIPTION_SUCCESS';
const LOAD_SUBSCRIPTION_FAILURE = '[subscription] LOAD_SUBSCRIPTION_FAILURE';
class LoadSubscription {
    constructor() {
        this.type = LOAD_SUBSCRIPTION;
    }
}
class LoadSubscriptionSuccess {
    /**
     * @param {?=} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_SUBSCRIPTION_SUCCESS;
    }
}
class LoadSubscriptionFailure {
    /**
     * @param {?=} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_SUBSCRIPTION_FAILURE;
    }
}

const initialState = {
    subscriptions: [],
    loading: false
};
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer(state = initialState, action) {
    switch (action.type) {
        case LOAD_SUBSCRIPTION: {
            return Object.assign({}, state, {
                loading: true
            });
        }
        case LOAD_SUBSCRIPTION_SUCCESS: {
            const /** @type {?} */ subscriptions = action.payload;
            return {
                subscriptions,
                loading: false
            };
        }
        case LOAD_SUBSCRIPTION_FAILURE: {
            const /** @type {?} */ subscriptions = [];
            return {
                subscriptions,
                loading: false
            };
        }
        default:
            return state;
    }
}
const getsubscriptions = (state) => state.subscriptions;
const getloading = (state) => state.loading;

const reducers = {
    subscriptionsState: reducer,
};
const selectFeatureModule = createFeatureSelector('subscriptions');
const selectFeatureState = createSelector(selectFeatureModule, (state) => state.subscriptionsState);
const getSubscriptionsStateSubscriptions = createSelector(selectFeatureState, getsubscriptions);
const getSubscriptionsStateLoading = createSelector(selectFeatureState, getloading);

class SubscriptionsLogicComponent {
    /**
     * @param {?} store
     */
    constructor(store) {
        this.store = store;
        this.subscriptions$ = store.select(getSubscriptionsStateSubscriptions);
        this.isLoading$ = store.select(getSubscriptionsStateLoading);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.store.dispatch(new LoadSubscription());
    }
}
SubscriptionsLogicComponent.decorators = [
    { type: Component, args: [{
                selector: 'slb-subscriptions-logic',
                template: `
      <slb-subscriptions [subscriptions]="subscriptions$ | async" [loading]="isLoading$ | async"></slb-subscriptions>
  `
            },] },
];
/**
 * @nocollapse
 */
SubscriptionsLogicComponent.ctorParameters = () => [
    { type: Store, },
];

const routes = [
    { path: '', component: SubscriptionsLogicComponent }
];
class SubscriptionsRoutingModule {
}
SubscriptionsRoutingModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    RouterModule.forChild(routes),
                ],
                exports: [RouterModule]
            },] },
];
/**
 * @nocollapse
 */
SubscriptionsRoutingModule.ctorParameters = () => [];

class SubscriptionsComponent {
    constructor() { }
    /**
     * @return {?}
     */
    checkForSubscriptions() {
        if (this.subscriptions && this.subscriptions.length === 0) {
            return true;
        }
        else {
            return false;
        }
    }
}
SubscriptionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'slb-subscriptions',
                template: "<md-spinner [class.show]=\"loading\" *ngIf=\"loading\"></md-spinner> <div *ngIf=\"!loading\"> <div class=\"cards-view\" fxLayout=\"row\" fxLayoutWrap fxLayoutGap=\"20px\" *ngIf=\"!checkForSubscriptions(); else message\"> <md-card class=\"card\" *ngFor=\"let tile of subscriptions;let i = index\"> <img class=\"card-image\" md-card-image src=\"assets/images/Petrel_1.PNG\"> <md-card-content> <h3 md-line>{{tile.name}}</h3> <p md-line>Active Until - {{tile.expiration | date}}</p> </md-card-content> <md-card-actions> <div fxLayout=\"row\"> <a href=\"{{tile.launcherUrl}}\" target=\"_blank\"> <button md-button color=\"primary\">Launch</button> </a> </div> </md-card-actions> </md-card> </div> <ng-template #message> <p class=\"no-subscription\">No subscription found</p> </ng-template> </div> ",
                styles: ["md-spinner { width: 4.5em; } .cards-view { padding: 30px; } .card { border-radius: 5px; margin-bottom: 10px; } .card-image { width: 250px; height: 140px; border-radius: 5px 5px 0 0; } .no-subscription { position: absolute; top: 50%; left: 50%; }"],
            },] },
];
/**
 * @nocollapse
 */
SubscriptionsComponent.ctorParameters = () => [];
SubscriptionsComponent.propDecorators = {
    'subscriptions': [{ type: Input },],
    'loading': [{ type: Input },],
};

class SubscriptionsService {
    /**
     * @param {?} httpInterceptorService
     */
    constructor(httpInterceptorService) {
        this.httpInterceptorService = httpInterceptorService;
    }
    /**
     * @return {?}
     */
    getSubscriptions() {
        return this.httpInterceptorService.get('subscriptions')
            .map((res) => {
            const /** @type {?} */ body = res.json();
            // TODO: check at runtime that body matches the structure of Sub
            return body;
        });
    }
    ;
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        // in a real world app, we should consider to some remote logging infrastructure
        // instead of just logging it to the console
        return Observable.throw(error.json().error || 'Server error');
    }
}
SubscriptionsService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
SubscriptionsService.ctorParameters = () => [
    { type: HttpInterceptorService, },
];

var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class SubscriptionEffects {
    /**
     * @param {?} actions$
     * @param {?} subscriptionsService
     */
    constructor(actions$, subscriptionsService) {
        this.actions$ = actions$;
        this.subscriptionsService = subscriptionsService;
        this.loadSubscriptions$ = this.actions$
            .ofType(LOAD_SUBSCRIPTION)
            .switchMap(() => this.subscriptionsService.getSubscriptions().toArray()
            .map((subscriptions) => new LoadSubscriptionSuccess(subscriptions[0]))
            .catch((error) => Observable.of(new LoadSubscriptionFailure(error))));
    }
}
SubscriptionEffects.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
SubscriptionEffects.ctorParameters = () => [
    { type: Actions, },
    { type: SubscriptionsService, },
];
__decorate([
    Effect()
], SubscriptionEffects.prototype, "loadSubscriptions$", void 0);

class SharedModule {
}
SharedModule.decorators = [
    { type: NgModule, args: [{
                declarations: [],
                imports: [
                    CommonModule,
                    MaterialModule,
                    FormsModule,
                    FlexLayoutModule,
                    RouterModule
                ],
                exports: [
                    CommonModule,
                    MaterialModule,
                    FormsModule,
                    FlexLayoutModule,
                    RouterModule
                ],
                providers: [],
            },] },
];
/**
 * @nocollapse
 */
SharedModule.ctorParameters = () => [];

class SubscriptionsModule {
}
SubscriptionsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    SubscriptionsLogicComponent,
                    SubscriptionsComponent,
                ],
                imports: [
                    CommonModule,
                    SubscriptionsRoutingModule,
                    StoreModule.forFeature('subscriptions', reducers, {}),
                    EffectsModule.forFeature([SubscriptionEffects]),
                    SharedModule,
                ],
                exports: [
                    SubscriptionsLogicComponent
                ],
                providers: [SubscriptionsService],
            },] },
];
/**
 * @nocollapse
 */
SubscriptionsModule.ctorParameters = () => [];

/**
 * Generated bundle index. Do not edit.
 */

export { SubscriptionsModule, reducers, selectFeatureModule, selectFeatureState, getSubscriptionsStateSubscriptions, getSubscriptionsStateLoading, LOAD_SUBSCRIPTION, LOAD_SUBSCRIPTION_SUCCESS, LOAD_SUBSCRIPTION_FAILURE, LoadSubscription, LoadSubscriptionSuccess, LoadSubscriptionFailure, initialState, reducer, getsubscriptions, getloading, SharedModule as ɵg, SubscriptionEffects as ɵe, SubscriptionsLogicComponent as ɵa, SubscriptionsComponent as ɵb, SubscriptionsRoutingModule as ɵd, routes as ɵc, SubscriptionsService as ɵf };
//# sourceMappingURL=subscriptions.js.map
